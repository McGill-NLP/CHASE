[
    {
        "function_name": "analyze_integer_frequencies",
        "file_name": "integer_analysis.py",
        "parameters": {
            "n": "int (Number of integers in the list)",
            "elements": "List[int] (List of integers to analyze)"
        },
        "objectives": [
            "Calculate the frequency of each integer in the list.",
            "Identify the integers that occur more than once and sort them in ascending order.",
            "Return the list of unique frequencies alongside their respective integers."
        ],
        "import_lines": [
            "from collections import Counter"
        ],
        "function_def": "def analyze_integer_frequencies(n, elements):\n    frequency = Counter(elements)\n    duplicates = sorted([x for x, count in frequency.items() if count > 1])\n    unique_frequencies = {x: frequency[x] for x in duplicates}\n    return unique_frequencies"
    },
    {
        "function_name": "schedule_non_overlapping_tasks",
        "file_name": "task_scheduler.py",
        "parameters": {
            "m": "int (Number of tasks)",
            "time_slots": "List[Tuple[int, int]] (List of tuples representing available time slots"
        },
        "objectives": [
            "For each task, determine if it can fit into any of the provided time slots without overlap.",
            "Arrange the tasks into the maximum number of non-overlapping time slots.",
            "Return a list of time slots representing the allocated tasks."
        ],
        "import_lines": [],
        "function_def": "def schedule_non_overlapping_tasks(m, time_slots):\n    time_slots.sort(key=lambda x: x[1])  # Sort by end time\n    selected_slots = []\n    last_end = -1\n    \n    for start, end in time_slots:\n        if start >= last_end:\n            selected_slots.append((start, end))\n            last_end = end\n            \n    return selected_slots"
    },
    {
        "function_name": "dijkstra_shortest_paths",
        "file_name": "graph_algorithms.py",
        "parameters": {
            "n": "int (Number of vertices in the graph)",
            "edges": "List[Tuple[int, int, int]] (List of edges represented by tuples",
            "start": "int (The starting vertex for Dijkstra's Algorithm)"
        },
        "objectives": [
            "Implement Dijkstra's algorithm to find the shortest path from the start vertex to all other vertices.",
            "Return a dictionary with the shortest paths and their corresponding total weights.",
            "If there's no path to a vertex, indicate this in the output as 'inf'."
        ],
        "import_lines": [
            "import heapq"
        ],
        "function_def": "def dijkstra_shortest_paths(n, edges, start):\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))  # Undirected graph\n    \n    distances = {i: float('inf') for i in range(n)}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        cur_dist, vertex = heapq.heappop(priority_queue)\n        \n        if cur_dist > distances[vertex]:\n            continue\n        \n        for neighbor, weight in graph[vertex]:\n            distance = cur_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances"
    },
    {
        "function_name": "longest_common_subsequence",
        "file_name": "lcs_computation.py",
        "parameters": {
            "n": "int (Number of unique items)",
            "sequences": "List[List[int]] (List of sequences containing the ids of items)"
        },
        "objectives": [
            "Calculate the longest common subsequence (LCS) that can be formed from the given sequences.",
            "The function must also return the count of unique LCS patterns that can form the result.",
            "Handle cases for empty sequences and sequences of different lengths."
        ],
        "import_lines": [],
        "function_def": "def longest_common_subsequence(n, sequences):\n    if not sequences:\n        return \"\", 0\n    \n    lcs = sequences[0]\n    \n    for seq in sequences[1:]:\n        dp = [[0] * (len(seq) + 1) for _ in range(len(lcs) + 1)]\n        \n        for i in range(1, len(lcs) + 1):\n            for j in range(1, len(seq) + 1):\n                if lcs[i - 1] == seq[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        length = dp[len(lcs)][len(seq)]\n        lcs = ''.join([lcs[i - 1] for i in range(1, len(lcs) + 1) if i in range(len(dp) - length, len(dp))])\n    \n    count = dp[len(lcs)][len(seq)]\n    return lcs, count"
    },
    {
        "function_name": "knapsack_max_value",
        "file_name": "knapsack_problems.py",
        "parameters": {
            "n": "int (The total number of items)",
            "capacity": "int (The maximum capacity of the knapsack)",
            "items": "List[Tuple[int, int]] (List of items represented by tuples (value, weight))"
        },
        "objectives": [
            "Implement the 0/1 Knapsack problem to maximize the total value in the knapsack without exceeding the capacity.",
            "The function must utilize dynamic programming to optimize the solution.",
            "Return the maximum value obtainable for the given items and capacity."
        ],
        "import_lines": [],
        "function_def": "def knapsack_max_value(n, capacity, items):\n    dp = [0] * (capacity + 1)\n\n    for value, weight in items:\n        for w in range(capacity, weight - 1, -1):\n            dp[w] = max(dp[w], dp[w - weight] + value)\n\n    return dp[capacity]"
    },
    {
        "function_name": "unique_combinations_with_threshold",
        "file_name": "distinct_selection.py",
        "parameters": {
            "seq": "List[int] - A sequence of integers where duplicates are allowed.",
            "r": "int - The number of distinct integers to select from the sequence."
        },
        "objectives": [
            "Count all unique combinations of exactly 'r' distinct integers from the sequence without considering the order.",
            "Ensure that the combinations do not include integers that differ by a given threshold 'T', which should be calculated internally.",
            "Return the result in a sorted manner based on the smallest value of each combination."
        ],
        "import_lines": [
            "from itertools import combinations"
        ],
        "function_def": "def unique_combinations_with_threshold(seq, r):\n    seq = sorted(set(seq))  # Remove duplicates and sort\n    combinations_list = combinations(seq, r)\n\n    # Determine T (the distance threshold) based on the unique elements\n    T = min(seq[i+1] - seq[i] for i in range(len(seq) - 1)) if len(seq) > 1 else float('inf')\n    \n    filtered_combinations = []\n    for comb in combinations_list:\n        if all(abs(comb[i] - comb[j]) >= T for i in range(len(comb)) for j in range(i + 1, len(comb))):\n            filtered_combinations.append(comb)\n    \n    return sorted(filtered_combinations)"
    },
    {
        "function_name": "stock_operations",
        "file_name": "stock_management.py",
        "parameters": {
            "lst": "List[int] - A list of integers representing current stocks.",
            "operations": "List[Tuple[int, Tuple[int, int]]] - A list of operations to perform. Each operation is either (1, (i, val)) to update a stock or (2, (x, y)) to count stocks between indices x and y."
        },
        "objectives": [
            "Implement the update operations such that each update changes the stock value at index 'i' by 'val'.",
            "Efficiently count the stocks in the specified range [x, y] that are above and below a calculated average of the list.",
            "Return a tuple with the count of stocks above average and below average after processing all operations."
        ],
        "import_lines": [],
        "function_def": "def stock_operations(lst, operations):\n    result = []\n    n = len(lst)\n\n    for op in operations:\n        if op[0] == 1:  # Update operation\n            i, val = op[1]\n            lst[i] += val\n        elif op[0] == 2:  # Count operation\n            x, y = op[1]\n            segment = lst[x:y+1]\n            avg = sum(segment) / len(segment)\n            above_avg = sum(1 for stock in segment if stock > avg)\n            below_avg = sum(1 for stock in segment if stock < avg)\n            result.append((above_avg, below_avg))\n\n    return result"
    },
    {
        "function_name": "task_scheduler",
        "file_name": "scheduler.py",
        "parameters": {
            "n": "int - The number of events.",
            "events": "List[Tuple[int, str]] - List of events where each event consists of a timestamp and an action (e.g., add, remove)."
        },
        "objectives": [
            "Maintain a timeline where actions are either adding or removing tasks based on the timestamp.",
            "Ensure tasks added at the same timestamp are uniquely identified and returned as a list at the end of processing.",
            "Implement a way to prevent removal of tasks that do not exist, thereby ensuring the integrity of action counts."
        ],
        "import_lines": [
            "from collections import defaultdict"
        ],
        "function_def": "def task_scheduler(n, events):\n    timeline = defaultdict(list)\n    active_tasks = set()\n    result = []\n\n    for timestamp, action in events:\n        if action.startswith('add'):\n            task_id = action.split(' ')[1]\n            if task_id not in active_tasks:\n                timeline[timestamp].append(task_id)\n                active_tasks.add(task_id)\n        elif action.startswith('remove'):\n            task_id = action.split(' ')[1]\n            if task_id in active_tasks:\n                active_tasks.remove(task_id)\n\n    for ts in sorted(timeline.keys()):\n        result.extend(timeline[ts])\n\n    return result"
    },
    {
        "function_name": "safe_pathfinder",
        "file_name": "pathfinding.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid representing obstacles (1) and free spaces (0).",
            "start": "Tuple[int, int] - Starting coordinates in the grid (row, column).",
            "end": "Tuple[int, int] - End coordinates in the grid (row, column)."
        },
        "objectives": [
            "Implement a pathfinding algorithm to find the shortest safe path from start to end while avoiding obstacles.",
            "Each time a valid path to end exists, it should be validated against a constraint where the number of steps should not exceed 'k.'",
            "Return all paths with length <= k along with the total count of such paths."
        ],
        "import_lines": [
            "from collections import deque"
        ],
        "function_def": "def safe_pathfinder(grid, start, end):\n    rows, cols = len(grid), len(grid[0])\n    k = rows * cols  # or another limit, we can define the max allowed steps\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([(start, 0, [start])])  # (current_position, current_length, path_taken)\n    valid_paths = []\n\n    while queue:\n        (current, length, path) = queue.popleft()\n        \n        if current == end and length <= k:\n            valid_paths.append(path)\n        \n        if length < k:\n            for direction in directions:\n                new_row = current[0] + direction[0]\n                new_col = current[1] + direction[1]\n\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0:\n                    next_position = (new_row, new_col)\n                    queue.append((next_position, length + 1, path + [next_position]))\n    \n    return valid_paths, len(valid_paths)"
    },
    {
        "function_name": "transportation_planning",
        "file_name": "supply_chain.py",
        "parameters": {
            "supply": "List[int] - An array of supply capacities for each type of resource.",
            "demand": "List[int] - An array representing the total demand for each resource.",
            "routes": "List[Tuple[int, int, int]] - A list of routes, where each route is defined as (from, to, capacity)."
        },
        "objectives": [
            "Create a transportation plan that fulfills the demand using available supply, while respecting the capacities of each route.",
            "Ensure that the plan minimizes transport costs based on a given formula (you can specify any suitable cost formula).",
            "Return a dictionary mapping each route to its transport amount, such that all demands are satisfied if feasible."
        ],
        "import_lines": [],
        "function_def": "def transportation_planning(supply, demand, routes):\n    transport_plan = {route: 0 for route in routes}\n    supply = supply[:]  # Create a mutable copy\n    demand = demand[:]  # Create a mutable copy\n    \n    for from_node, to_node, capacity in routes:\n        while supply[from_node] > 0 and demand[to_node] > 0:\n            amount = min(supply[from_node], demand[to_node], capacity)\n            transport_plan[(from_node, to_node, capacity)] += amount\n            supply[from_node] -= amount\n            demand[to_node] -= amount\n\n    if any(d > 0 for d in demand):\n        raise Exception(\"Not all demand requirements can be satisfied\")\n\n    return transport_plan"
    },
    {
        "function_name": "unique_combination_sums",
        "file_name": "combinations.py",
        "parameters": {
            "n": "int (Number of items in the set)",
            "k": "int (Size of the subset to consider)",
            "items": "List[int] (List of integers representing the items)"
        },
        "objectives": [
            "Generate all unique combinations of size \"k\" from the provided set of \"n\" items.",
            "For each combination, calculate the sum and store the results in a list.",
            "Return both the unique sums and the number of unique combinations generated."
        ],
        "import_lines": [
            "from itertools import combinations"
        ],
        "function_def": "def unique_combination_sums(n, k, items):\n    unique_sums = set()\n    combs = list(combinations(items, k))\n    \n    for comb in combs:\n        unique_sums.add(sum(comb))\n    \n    return list(unique_sums), len(combs)"
    },
    {
        "function_name": "three_sum_unique",
        "file_name": "triplets.py",
        "parameters": {
            "arr": "List[int] (Array of integers)",
            "target": "int (Target sum to find)"
        },
        "objectives": [
            "Find all unique triplets in the array that sum up to the target value.",
            "Ensure that each triplet is stored in a way that maintains the original order of elements.",
            "Return the list of unique triplets that meet the requirement."
        ],
        "import_lines": [],
        "function_def": "def three_sum_unique(arr, target):\n    arr.sort()\n    unique_triplets = []\n    \n    n = len(arr)\n    for i in range(n):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n            \n        left, right = i + 1, n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                unique_triplets.append((arr[i], arr[left], arr[right]))\n                while left < right and arr[left] == arr[left + 1]:\n                    left += 1\n                while left < right and arr[right] == arr[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return unique_triplets"
    },
    {
        "function_name": "max_profit_k_transactions",
        "file_name": "stock_trading.py",
        "parameters": {
            "prices": "List[int] (List of stock prices)",
            "n": "int (Number of days to consider)"
        },
        "objectives": [
            "Calculate the maximum profit obtainable by buying and selling the stock on different days.",
            "Consider that you can perform at most \"n\" transactions only.",
            "Ensure that you handle cases of only one buy-sell pair and return the maximum profit accordingly."
        ],
        "import_lines": [],
        "function_def": "def max_profit_k_transactions(prices, n):\n    if not prices:\n        return 0\n    if n > len(prices) // 2:\n        return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))\n    \n    profits = [[0] * len(prices) for _ in range(n + 1)]\n\n    for k in range(1, n + 1):\n        max_diff = -prices[0]\n        for day in range(1, len(prices)):\n            profits[k][day] = max(profits[k][day - 1], prices[day] + max_diff)\n            max_diff = max(max_diff, profits[k - 1][day] - prices[day])\n\n    return profits[n][-1]"
    },
    {
        "function_name": "rotate_string",
        "file_name": "string_operations.py",
        "parameters": {
            "s": "str (Input string)",
            "n": "int (Number of rotation steps)"
        },
        "objectives": [
            "Implement a function to rotate a string \"s\" to the left by \"n\" positions.",
            "If \"n\" is greater than the length of the string, adjust it using modulo.",
            "Finally, return the rotated string."
        ],
        "import_lines": [],
        "function_def": "def rotate_string(s, n):\n    n = n % len(s) if s else 0\n    return s[n:] + s[:n]"
    },
    {
        "function_name": "can_sum_to_target",
        "file_name": "subset_sum.py",
        "parameters": {
            "arr": "List[int] (List of integers)",
            "target": "int (Target sum)"
        },
        "objectives": [
            "Determine if any combination of the elements in the array can sum up to the target.",
            "Handle duplicate elements in the array while ensuring unique sums are considered.",
            "Return a boolean indicating the possibility of achieving the target sum."
        ],
        "import_lines": [],
        "function_def": "def can_sum_to_target(arr, target):\n    sums = {0}\n    \n    for num in arr:\n        new_sums = set()\n        for s in sums:\n            new_sum = s + num\n            if new_sum == target:\n                return True\n            new_sums.add(new_sum)\n        sums.update(new_sums)\n\n    return False"
    },
    {
        "function_name": "is_palindrome_in_base",
        "file_name": "palindrome_checker.py",
        "parameters": {
            "num": "int",
            "base": "int"
        },
        "objectives": [
            "Validate if the number is a palindrome in the specified base representation.",
            "Implement the logic to convert the number to the given base and then check if the string representation of the number is the same forwards and backwards.",
            "Return a boolean indicating whether the number is a palindrome in the given base."
        ],
        "import_lines": [],
        "function_def": "def is_palindrome_in_base(num, base):\n    if base < 2:\n        return False\n    \n    # Convert number to the specified base\n    converted = \"\"\n    while num > 0:\n        converted = str(num % base) + converted\n        num //= base\n    \n    # Check if the converted string is a palindrome\n    return converted == converted[::-1]"
    },
    {
        "function_name": "kmp_pattern_search",
        "file_name": "pattern_search.py",
        "parameters": {
            "string": "str",
            "pattern": "str"
        },
        "objectives": [
            "Find all unique occurrences of the pattern within the string using the Knuth-Morris-Pratt (KMP) algorithm.",
            "Implement preprocessing of the pattern to create the longest prefix which is also a suffix (LPS) array.",
            "Return a list of starting indices where the pattern occurs in the string."
        ],
        "import_lines": [],
        "function_def": "def kmp_pattern_search(string, pattern):\n    # Create the LPS array\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n        while j > 0 and pattern[i] != pattern[j]:\n            j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            lps[i] = j\n    \n    # Search the pattern in the string\n    result = []\n    m, n = len(string), len(pattern)\n    j = 0\n    for i in range(m):\n        while j > 0 and string[i] != pattern[j]:\n            j = lps[j - 1]\n        if string[i] == pattern[j]:\n            j += 1\n            if j == n:\n                result.append(i - n + 1)\n                j = lps[j - 1]\n    \n    return result"
    },
    {
        "function_name": "find_pairs_with_sum",
        "file_name": "pair_sum_finder.py",
        "parameters": {
            "n": "int (The size of the input array)",
            "array": "List[int] (The input array containing integer values)",
            "target": "int (The target sum to find as a combination of any two distinct elements)"
        },
        "objectives": [
            "Identify all unique pairs of indices (i, j) such that the sum of array[i] + array[j] equals the target and i < j.",
            "Ensure that each identified pair is sorted in ascending order.",
            "Return the pairs as a list of tuples."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def find_pairs_with_sum(n: int, array: List[int], target: int) -> List[Tuple[int, int]]:\n    pairs = set()\n    seen = {}\n    for i in range(n):\n        complement = target - array[i]\n        if complement in seen:\n            pairs.add((min(complement, array[i]), max(complement, array[i])))\n        seen[array[i]] = i\n    return sorted(pairs)"
    },
    {
        "function_name": "closest_triplet_sum",
        "file_name": "triplet_sum_finder.py",
        "parameters": {
            "n": "int (Number of elements in the list)",
            "arr": "List[int] (The input list of integers)",
            "x": "int (The target number to find the closest sum to)"
        },
        "objectives": [
            "Find the three elements in the list that produce the closest sum to a given target x.",
            "Ensure to return the unique set of elements that can produce this closest sum and that does not include repeated combinations.",
            "If there are multiple closest sums, return the one with the smallest numerical sum."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def closest_triplet_sum(n: int, arr: List[int], x: int) -> List[int]:\n    arr.sort()\n    closest_sum = float('inf')\n    result = []\n\n    for i in range(n - 2):\n        left, right = i + 1, n - 1 \n\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n\n            if abs(current_sum - x) < abs(closest_sum - x):\n                closest_sum = current_sum\n                result = [arr[i], arr[left], arr[right]]\n\n            if current_sum < x:\n                left += 1\n            elif current_sum > x:\n                right -= 1\n            else:\n                return [arr[i], arr[left], arr[right]]\n\n    return result"
    },
    {
        "function_name": "find_subsets_of_at_least_k_size",
        "file_name": "subset_generator.py",
        "parameters": {
            "n": "int (The number of elements in the list)",
            "arr": "List[int] (The input list of integers)",
            "k": "int (The minimum size of subsets)"
        },
        "objectives": [
            "Generate all subsets of the input array that are of size at least k.",
            "Ensure that the subsets returned are sorted in increasing order.",
            "Return the subsets as a list of lists."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_subsets_of_at_least_k_size(n: int, arr: List[int], k: int) -> List[List[int]]:\n    from itertools import combinations\n\n    arr.sort()\n    subsets = []\n    for size in range(k, n + 1):\n        subsets.extend(combinations(arr, size))\n    \n    return [list(subset) for subset in subsets]"
    },
    {
        "function_name": "dijkstra_shortest_path",
        "file_name": "shortest_path_finder.py",
        "parameters": {
            "n": "int (The number of nodes in the directed graph)",
            "edges": "List[Tuple[int, int, int]] (List of weighted directed edges in graph (u, v, w))",
            "start": "int (The starting node for calculating shortest path)",
            "end": "int (The end node for which shortest path is being calculated)"
        },
        "objectives": [
            "Implement Dijkstra's algorithm to calculate the shortest path from the start node to the end node.",
            "Return the length of the shortest path as well as the path taken as a list of nodes.",
            "Handle scenarios where no path exists between start and end nodes by returning an appropriate message."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List, Tuple"
        ],
        "function_def": "def dijkstra_shortest_path(n: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> Tuple[int, List[int]]:\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        graph[u].append((v, w))\n    \n    min_heap = [(0, start)]\n    visited = set()\n    distances = {i: float('inf') for i in range(n)}\n    distances[start] = 0\n    parent = {start: None}\n    \n    while min_heap:\n        current_distance, current_node = heapq.heappop(min_heap)\n        if current_node in visited:\n            continue\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                parent[neighbor] = current_node\n                heapq.heappush(min_heap, (distance, neighbor))\n\n    if distances[end] == float('inf'):\n        return -1, []\n\n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    \n    return distances[path[0]], path[::-1]"
    },
    {
        "function_name": "max_sum_subarray",
        "file_name": "subarray_sums.py",
        "parameters": {
            "n": "Integer (Number of elements in the array)",
            "k": "Integer (The size of the subarray for which the maximum sum is computed)",
            "arr": "List of integers (The array of integers)"
        },
        "objectives": [
            "Find all possible contiguous subarrays of size \"k\" in the array \"arr\".",
            "Calculate the sum of each of these subarrays.",
            "Identify the maximum sum out of all the computed sums.",
            "Return the maximum sum along with the starting index of the subarray that provided this sum."
        ],
        "import_lines": [],
        "function_def": "def max_sum_subarray(n, k, arr):\n    max_sum = -float('inf')\n    max_index = -1\n    \n    for i in range(n - k + 1):\n        current_sum = sum(arr[i:i + k])\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_index = i\n            \n    return max_sum, max_index"
    },
    {
        "function_name": "knapsack_problem",
        "file_name": "knapsack_solver.py",
        "parameters": {
            "items": "List of integers (List of item weights)",
            "capacity": "Integer (Capacity of the knapsack)",
            "n": "Integer (Number of items)"
        },
        "objectives": [
            "Determine whether each item can be included in a knapsack of given capacity.",
            "If an item is included, determine the maximum weight and value carried within the capacity constraints.",
            "Use a dynamic programming approach to keep track of maximum values.",
            "Backtrack to identify which items were included in achieving the optimal solution."
        ],
        "import_lines": [],
        "function_def": "def knapsack_problem(items, capacity, n):\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if items[i - 1] <= w:\n                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - items[i - 1]] + items[i - 1])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    return dp[n][capacity]"
    },
    {
        "function_name": "coin_change_combinations",
        "file_name": "coin_change.py",
        "parameters": {
            "n": "Integer (Number of different coins)",
            "coins": "List of integers (The denominations of the coins)",
            "amount": "Integer (The target amount to make change for)"
        },
        "objectives": [
            "Calculate the number of distinct ways to make change for the \"amount\" using the available \"coins\".",
            "Use dynamic programming to build a solution that counts combinations instead of permutations.",
            "Return the total number of unique combinations that sum to the target amount."
        ],
        "import_lines": [],
        "function_def": "def coin_change_combinations(n, coins, amount):\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # One way to create amount 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n\n    return dp[amount]"
    },
    {
        "function_name": "can_construct_word",
        "file_name": "string_manipulations.py",
        "parameters": {
            "words": "List[str]",
            "word": "str"
        },
        "objectives": [
            "Check if the \"word\" can be constructed using the characters of the words in the list \"words\" with each character being used as many times as it appears in the list.",
            "Maintain the maximum frequency of each character that can be constructed from the \"words\" and ensure that any character can be reused based on availability.",
            "Return a boolean indicating whether it\u2019s possible to construct the given \"word\"."
        ],
        "import_lines": [
            "from collections import Counter"
        ],
        "function_def": "def can_construct_word(words, word):\n    char_count = Counter()\n    for w in words:\n        char_count.update(w)  # Count occurrences of each character\n\n    word_count = Counter(word)\n    \n    for char, count in word_count.items():\n        if char_count[char] < count:  # Check availability against requested count\n            return False\n            \n    return True"
    },
    {
        "function_name": "find_k_tallest_towers",
        "file_name": "tower_utilities.py",
        "parameters": {
            "n": "int",
            "k": "int",
            "heights": "List[int]"
        },
        "objectives": [
            "Identify the k tallest towers from a given list of tower heights.",
            "Calculate the total height of these k towers.",
            "Return a list containing the heights of the k tallest towers in non-increasing order."
        ],
        "import_lines": [],
        "function_def": "def find_k_tallest_towers(n, k, heights):\n    if k > n:\n        return []\n\n    tallest_towers = sorted(heights, reverse=True)[:k]\n    total_height = sum(tallest_towers)\n    \n    return sorted(tallest_towers, reverse=True)"
    },
    {
        "function_name": "minimize_project_difficulty",
        "file_name": "project_selection.py",
        "parameters": {
            "n": "int",
            "k": "int",
            "difficulties": "List[int]"
        },
        "objectives": [
            "Select \"k\" projects from a list of \"n\" projects with given difficulty levels to minimize total difficulty.",
            "The total difficulty is defined as the sum of the \"k\" selected project difficulties.",
            "Ensure that the selected projects have unique difficulty levels."
        ],
        "import_lines": [],
        "function_def": "def minimize_project_difficulty(n, k, difficulties):\n    unique_difficulties = list(set(difficulties))\n    unique_difficulties.sort()\n    \n    if len(unique_difficulties) < k:\n        return -1  # Not enough unique projects\n    \n    return sum(unique_difficulties[:k])"
    },
    {
        "function_name": "subset_sum_exists",
        "file_name": "subset_sum.py",
        "parameters": {
            "nums": "List[int]",
            "target": "int"
        },
        "objectives": [
            "Determine if there exists a subset of \"nums\" that can sum up to \"target\".",
            "Use dynamic programming to keep track of possible subset sums.",
            "Return True if such a subset exists, otherwise return False."
        ],
        "import_lines": [],
        "function_def": "def subset_sum_exists(nums, target):\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for sum_value in range(target, num - 1, -1):\n            dp[sum_value] = dp[sum_value] or dp[sum_value - num]\n    \n    return dp[target]"
    },
    {
        "function_name": "compute_weight_distances",
        "file_name": "weight_distance_calculator.py",
        "parameters": {
            "n": "int (Size of the array)",
            "weights": "List[int] (A list of weights of size n)",
            "pairs": "List[Tuple[int, int]] (List of pairs represented by their indices which will be considered for distance calculations)"
        },
        "objectives": [
            "For each pair (i, j) in the 'pairs' list, compute the distance based on the specified weights.",
            "The distance between two weights is defined by the absolute difference of their weights.",
            "Return the sum of all distances calculated for the given pairs."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def compute_weight_distances(n: int, weights: List[int], pairs: List[Tuple[int, int]]) -> int:\n    total_distance = 0\n    for i, j in pairs:\n        if i < 0 or i >= n or j < 0 or j >= n:\n            raise IndexError(\"Index out of bounds\")\n        total_distance += abs(weights[i] - weights[j])\n    return total_distance"
    },
    {
        "function_name": "manipulate_array",
        "file_name": "array_manipulator.py",
        "parameters": {
            "arr": "List[int] (The list of integers which will be manipulated)",
            "conditions": "List[Tuple[int, int, int]] (Each tuple corresponds to a manipulation type"
        },
        "objectives": [
            "Execute operations on the provided list depending on the manipulation type.",
            "If the manipulation type is 1, increment all elements from start_index to end_index by 1.",
            "If the manipulation type is 2, decrement all elements from start_index to end_index by 1.",
            "If the manipulation type is 3, return the sum of elements from start_index to end_index without modifying them."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def manipulate_array(arr: List[int], conditions: List[Tuple[int, int, int]]) -> List[int]:\n    results = []\n    for manipulation_type, start_index, end_index in conditions:\n        if manipulation_type == 1:\n            for i in range(start_index, end_index + 1):\n                arr[i] += 1\n        elif manipulation_type == 2:\n            for i in range(start_index, end_index + 1):\n                arr[i] -= 1\n        elif manipulation_type == 3:\n            sum_result = sum(arr[start_index:end_index + 1])\n            results.append(sum_result)\n        else:\n            raise ValueError(\"Invalid manipulation type.\")\n    return results"
    },
    {
        "function_name": "generate_combination_sums",
        "file_name": "combination_sum_generator.py",
        "parameters": {
            "n": "int (Number of items)",
            "values": "List[int] (List containing the values to form combinations)",
            "k": "int (Number of combinations to consider)"
        },
        "objectives": [
            "Generate all possible unique combinations of length k from the given values.",
            "Calculate the sum of each combination and return a list of these sums.",
            "Ensure that the result is sorted in ascending order."
        ],
        "import_lines": [
            "from itertools import combinations",
            "from typing import List"
        ],
        "function_def": "def generate_combination_sums(n: int, values: List[int], k: int) -> List[int]:\n    if k > n:\n        raise ValueError(\"k cannot be greater than n.\")\n    \n    combination_sums = []\n    for combo in combinations(values, k):\n        combination_sums.append(sum(combo))\n    \n    return sorted(combination_sums)"
    },
    {
        "function_name": "find_pattern_occurrences",
        "file_name": "pattern_finder.py",
        "parameters": {
            "n": "int (Number of elements in the pattern)",
            "arr": "List[int] (The original input array)",
            "pattern": "List[int] (The pattern to match in the array)"
        },
        "objectives": [
            "Identify all starting indices in the array 'arr' where the 'pattern' occurs, allowing for overlapping occurrences.",
            "Ensure that all occurrences are included, including those that start before previously found occurrences.",
            "Return a list containing the starting indices of all matched patterns."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_pattern_occurrences(n: int, arr: List[int], pattern: List[int]) -> List[int]:\n    occurrences = []\n    len_pattern = len(pattern)\n    \n    for i in range(n - len_pattern + 1):\n        if arr[i:i + len_pattern] == pattern:\n            occurrences.append(i)\n    \n    return occurrences"
    },
    {
        "function_name": "find_unique_combinations",
        "file_name": "combination_finder.py",
        "parameters": {
            "k": "int (The target number to be reached by the combinations)",
            "nums": "List[int] (The list of integers from which to form combinations)"
        },
        "objectives": [
            "Find all unique combinations in 'nums' that add up to exactly 'k'.",
            "Ensure that each combination only uses the numbers from nums once per unique occurrence.",
            "Return a list of the unique combinations that meet the criteria sorted in ascending order."
        ],
        "import_lines": [
            "from typing import List",
            "from itertools import combinations"
        ],
        "function_def": "def find_unique_combinations(k: int, nums: List[int]) -> List[List[int]]:\n    unique_combinations = set()\n    \n    for r in range(1, len(nums) + 1):\n        for combo in combinations(nums, r):\n            if sum(combo) == k:\n                unique_combinations.add(tuple(sorted(combo)))\n    \n    return [list(combo) for combo in sorted(unique_combinations)]"
    },
    {
        "function_name": "max_profit_with_fee",
        "file_name": "stock_trading.py",
        "parameters": {
            "prices": "List[int]",
            "fee": "int"
        },
        "objectives": [
            "Implement a function to calculate the maximum profit from stock trading given a list of stock prices and a transaction fee for every buy-sell transaction.",
            "Use dynamic programming to keep track of two states: the cash state (profit when not holding a stock) and the hold state (profit when holding a stock).",
            "Transition between states based on whether we decide to buy, sell, or hold, and incorporate the transaction fee.",
            "The function should return the maximum profit achievable after all transactions."
        ],
        "import_lines": [],
        "function_def": "def max_profit_with_fee(prices, fee):\n    cash = 0\n    hold = -prices[0]\n    \n    for price in prices:\n        cash = max(cash, hold + price - fee)  # Sell operation\n        hold = max(hold, cash - price)        # Buy operation\n    \n    return cash"
    },
    {
        "function_name": "max_sum_non_adjacent",
        "file_name": "max_sum.py",
        "parameters": {
            "nums": "List[int]",
            "k": "int"
        },
        "objectives": [
            "Create a function to find the maximum sum of k non-adjacent elements in the list \"nums\".",
            "Use dynamic programming to maintain a running total of the best sums.",
            "For each element in the array, decide whether to include it in the total or not, ensuring that no two included elements are adjacent.",
            "The function should return the maximum sum you can achieve by selecting up to k non-adjacent elements."
        ],
        "import_lines": [],
        "function_def": "def max_sum_non_adjacent(nums, k):\n    n = len(nums)\n    if k == 0 or n == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + nums[i-1]) if i > 1 else nums[i-1]\n    \n    return dp[n][k]"
    },
    {
        "function_name": "k_closest_points",
        "file_name": "closest_points.py",
        "parameters": {
            "points": "List[List[int]]",
            "k": "int"
        },
        "objectives": [
            "Compute the k closest points to the origin (0, 0) from a list of points on a 2D plane.",
            "Use a max-heap to keep track of the k closest points, leveraging the distance formula to determine proximity.",
            "For each point, calculate its distance, and if this distance is less than the maximum found in the heap, replace it.",
            "Return the k closest points as a list of coordinates."
        ],
        "import_lines": [
            "import heapq"
        ],
        "function_def": "def k_closest_points(points, k):\n    max_heap = []\n    \n    for (x, y) in points:\n        distance = x * x + y * y\n        heapq.heappush(max_heap, (-distance, (x, y)))\n        if len(max_heap) > k:\n            heapq.heappop(max_heap)\n    \n    return [point for (_, point) in max_heap]"
    },
    {
        "function_name": "manipulate_array",
        "file_name": "array_manipulator.py",
        "parameters": {
            "arr": "List[int] - A list of integers to be manipulated.",
            "operations": "List[Tuple[str, int]] - A list of operations to be performed. Each operation is a tuple consisting of ('add', index) or ('remove', index)."
        },
        "objectives": [
            "Implement the specified operations on the array where 'add' appends an integer at a given index and 'remove' deletes the integer at the given index while maintaining the integrity of the operations.",
            "Ensure all invalid operations (e.g., removing from an empty array or accessing an out-of-range index) are gracefully handled without errors.",
            "After all operations, return the final state of the array."
        ],
        "import_lines": [],
        "function_def": "def manipulate_array(arr, operations):\n    for op, index in operations:\n        if op == 'add':\n            arr.append(index)\n        elif op == 'remove' and 0 <= index < len(arr):\n            arr.pop(index)\n    return arr"
    },
    {
        "function_name": "maximum_knapsack_weight",
        "file_name": "knapsack_optimizer.py",
        "parameters": {
            "n": "int - The total number of items, representing a list of 'n' items.",
            "lst": "List[Tuple[str, int]] - A list containing tuples of (item_name, item_weight).",
            "k": "int - The maximum weight capacity of the knapsack."
        },
        "objectives": [
            "Utilize dynamic programming to calculate the maximum total weight of items that can be placed in the knapsack without exceeding the weight capacity \"k\".",
            "Ensure that items can only be selected based on their given weights and cannot be duplicated within the same calculation.",
            "Return the maximum weight possible that can be achieved under the specified weight capacity."
        ],
        "import_lines": [],
        "function_def": "def maximum_knapsack_weight(n, lst, k):\n    dp = [0] * (k + 1)\n    \n    for item_name, item_weight in lst:\n        for weight in range(k, item_weight - 1, -1):\n            dp[weight] = max(dp[weight], dp[weight - item_weight] + item_weight)\n    \n    return dp[k]"
    },
    {
        "function_name": "top_n_frequent_words",
        "file_name": "word_frequency_counter.py",
        "parameters": {
            "string": "str - A string consisting of words.",
            "n": "int - The number of top frequent words to be extracted from the string."
        },
        "objectives": [
            "Parse the input string to extract words and count their occurrences, ensuring that the counting is case-insensitive.",
            "Sort the words based on their frequency in descending order and alphabetically in case of a tie.",
            "Return the top \"n\" most frequent words as a list."
        ],
        "import_lines": [
            "from collections import Counter"
        ],
        "function_def": "def top_n_frequent_words(string, n):\n    words = string.lower().split()\n    count = Counter(words)\n    \n    return [word for word, _ in count.most_common(n)]"
    },
    {
        "function_name": "generate_matrix_with_condition",
        "file_name": "matrix_generator.py",
        "parameters": {
            "size": "int - The size of the matrix (n x n) to generate.",
            "threshold": "int - A random threshold for limiting values in the matrix."
        },
        "objectives": [
            "Generate an n x n matrix with random integers up to 'threshold'.",
            "Ensure that the matrix contains at least one row and one column that meets a specific condition where the sum of the integers exceeds half of the 'threshold'.",
            "Return the generated matrix and a boolean indicating whether the condition was met."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def generate_matrix_with_condition(size, threshold):\n    matrix = np.random.randint(0, threshold, size=(size, size)).tolist()\n    condition_met = False\n    \n    for row in matrix:\n        if sum(row) > threshold / 2:\n            condition_met = True\n            break\n    \n    for col in range(size):\n        if sum(matrix[row][col] for row in range(size)) > threshold / 2:\n            condition_met = True\n            break\n    \n    return matrix, condition_met"
    },
    {
        "function_name": "validate_brackets",
        "file_name": "bracket_validator.py",
        "parameters": {
            "string": "str - The input string to check for valid brackets."
        },
        "objectives": [
            "Implement a stack-based algorithm to validate if the input string contains well-formed brackets.",
            "Differentiate between three types of brackets: parentheses, square brackets, and curly braces, ensuring they close in the correct order.",
            "Return a boolean indicating whether the string is valid, along with the number of unmatched opening brackets if any."
        ],
        "import_lines": [],
        "function_def": "def validate_brackets(string):\n    stack = []\n    brackets = {')': '(', ']': '[', '}': '{'}\n    \n    for char in string:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if stack == [] or stack[-1] != brackets[char]:\n                return False, len(stack)\n            stack.pop()\n    \n    return len(stack) == 0, len(stack)"
    },
    {
        "function_name": "find_unique_triplets",
        "file_name": "triplet_finder.py",
        "parameters": {
            "nums": "List[int] - A list of integers to be evaluated for triplets.",
            "target": "int - A target sum to compare the triplets against."
        },
        "objectives": [
            "Implement a function to find all unique triplets in the list whose sum is equal to the 'target'.",
            "Sort the initial list to facilitate eliminating duplicate triplets while exploring potential sums.",
            "Return a list of all unique triplets that meet the condition while ensuring no duplicates are present."
        ],
        "import_lines": [],
        "function_def": "def find_unique_triplets(nums, target):\n    nums.sort()\n    unique_triplets = []\n    \n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            triplet_sum = nums[i] + nums[left] + nums[right]\n            if triplet_sum == target:\n                unique_triplets.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif triplet_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return unique_triplets"
    },
    {
        "function_name": "filter_and_average",
        "file_name": "filter_average_calculator.py",
        "parameters": {
            "arr": "List[int] - The input list of integers.",
            "k": "int - A threshold value for filtering the integers."
        },
        "objectives": [
            "Implement a function that filters out integers from the input list that are greater than 'k' and returns the remaining elements.",
            "Sort the remaining elements in ascending order.",
            "Calculate and return the average of the filtered integers, along with the count of numbers below the threshold."
        ],
        "import_lines": [],
        "function_def": "def filter_and_average(arr, k):\n    filtered = [x for x in arr if x <= k]\n    filtered.sort()\n    \n    count = len(filtered)\n    average = sum(filtered) / count if count > 0 else 0\n    \n    return filtered, average, count"
    },
    {
        "function_name": "find_kth_largest",
        "file_name": "largest_finder.py",
        "parameters": {
            "numbers": "List[int] - A list of integers.",
            "k": "int - The k-th largest element to find in the list."
        },
        "objectives": [
            "Implement logic to find the k-th largest unique number in the list.",
            "Handle cases where there are not enough unique elements by returning None or a suitable message.",
            "Ensure efficient searching and sorting to achieve the desired k-th largest element."
        ],
        "import_lines": [
            "from typing import List, Optional"
        ],
        "function_def": "def find_kth_largest(numbers: List[int], k: int) -> Optional[int]:\n    unique_numbers = list(set(numbers))\n    \n    if k > len(unique_numbers):\n        return None\n    \n    unique_numbers.sort(reverse=True)\n    return unique_numbers[k - 1]  # k-th largest is at k-1 index"
    },
    {
        "function_name": "sort_points_by_distance",
        "file_name": "distance_calculator.py",
        "parameters": {
            "points": "List[Tuple[int, int]] - A list of (x, y) coordinates representing points in a 2D plane.",
            "p": "int - The p-value for p-norm distance metric."
        },
        "objectives": [
            "Calculate the distance of each point from the origin (0, 0) using the p-norm formula.",
            "Sort the points based on their distance from the origin in ascending order.",
            "Return the sorted list of points along with their computed distances."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from math import pow"
        ],
        "function_def": "def sort_points_by_distance(points: List[Tuple[int, int]], p: int) -> List[Tuple[Tuple[int, int], float]]:\n    distances = []\n    \n    for point in points:\n        distance = pow(pow(abs(point[0]), p) + pow(abs(point[1]), p), 1/p)\n        distances.append((point, distance))\n    \n    return sorted(distances, key=lambda x: x[1])  # Sort by distance"
    },
    {
        "function_name": "count_words",
        "file_name": "word_counter.py",
        "parameters": {
            "s": "str - The input string containing words and punctuation.",
            "n": "int - The minimum length of words to be counted."
        },
        "objectives": [
            "Count the frequency of words that have a length greater than or equal to 'n'.",
            "Ensure that word counts are case-insensitive and ignore punctuation when counting.",
            "Return a dictionary with words as keys and their corresponding counts as values."
        ],
        "import_lines": [
            "import string",
            "from collections import Counter"
        ],
        "function_def": "def count_words(s: str, n: int) -> dict:\n    s = s.lower()  # Case insensitive\n    table = str.maketrans('', '', string.punctuation)\n    cleaned_string = s.translate(table)\n    \n    words = cleaned_string.split()\n    filtered_words = [word for word in words if len(word) >= n]\n    \n    return dict(Counter(filtered_words))  # Converting Counter to dictionary"
    },
    {
        "function_name": "search_matrix",
        "file_name": "matrix_search.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D list of integers representing the input matrix.",
            "target": "int - The target integer to search for."
        },
        "objectives": [
            "Implement a search algorithm to find the position (row, column) of the target in the matrix.",
            "Ensure the algorithm efficiently skips rows or columns that do not contain the target.",
            "Return the position of the target as a tuple (row index, column index) or (-1, -1) if not found."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]:\n    if not matrix or not matrix[0]:\n        return -1, -1\n    \n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n    \n    while row < rows and col >= 0:\n        current = matrix[row][col]\n        if current == target:\n            return row, col\n        elif current > target:\n            col -= 1  # Move left\n        else:\n            row += 1  # Move down\n    \n    return -1, -1  # Target not found"
    },
    {
        "function_name": "count_non_overlapping_substring",
        "file_name": "substring_counter.py",
        "parameters": {
            "string": "str",
            "substr": "str"
        },
        "objectives": [
            "Implement a method to count the number of non-overlapping occurrences of a substring within the given string.",
            "Ensure that the count is case-sensitive and respects different character encodings.",
            "Return both the total count and indices where the substring occurs in the string."
        ],
        "import_lines": [
            "import re"
        ],
        "function_def": "def count_non_overlapping_substring(string: str, substr: str):\n    pattern = re.escape(substr)\n    matches = re.finditer(pattern, string)\n    indices = [match.start() for match in matches]\n    return len(indices), indices"
    },
    {
        "function_name": "generate_ngrams",
        "file_name": "ngram_generator.py",
        "parameters": {
            "text": "str",
            "n": "int"
        },
        "objectives": [
            "Create a function that generates all n-grams (subsequences of n items) from the input string while maintaining word boundaries.",
            "Ensure n-grams are created from words, not just individual characters, and handle cases with varying spaces and punctuation.",
            "Return a list of unique n-grams in a sorted manner."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def generate_ngrams(text: str, n: int) -> List[str]:\n    words = text.split()\n    ngrams = set(' '.join(words[i:i+n]) for i in range(len(words) - n + 1) if i + n <= len(words))\n    return sorted(ngrams)"
    },
    {
        "function_name": "calculate_moving_average",
        "file_name": "moving_average_calculator.py",
        "parameters": {
            "time_series": "List[float] - A list of float values representing a time series.",
            "window_size": "int - The period over which to calculate the moving average."
        },
        "objectives": [
            "Calculate the moving average of the time series, returning a new list that has the same length as the input list.",
            "Ensure that the output list contains `None` values for indices where a full window cannot be computed (e.g., the first `window_size - 1` entries).",
            "Return the moving average values, maintaining the order of the input series.",
            "If `window_size` is greater than the length of the series, return a list of the same size filled with `None`."
        ],
        "import_lines": [
            "from typing import List, Optional"
        ],
        "function_def": "def calculate_moving_average(time_series: List[float], window_size: int) -> List[Optional[float]]:\n    n = len(time_series)\n    if window_size > n:\n        return [None] * n\n    \n    moving_averages = [None] * n\n    \n    for i in range(n):\n        if i >= window_size - 1:\n            moving_average = sum(time_series[i - window_size + 1:i + 1]) / window_size\n            moving_averages[i] = moving_average\n            \n    return moving_averages"
    },
    {
        "function_name": "merge_sort",
        "file_name": "merge_sorter.py",
        "parameters": {
            "nums": "List[int] (The list of integers to be sorted)",
            "ascending": "bool (Flag indicating the order of sorting; True for ascending, False for descending)"
        },
        "objectives": [
            "Implement a sorting algorithm using Merge Sort to sort the integers in the specified order.",
            "Ensure that the algorithm is efficient with a time complexity of O(n log n).",
            "Handle edge cases such as empty lists and lists with identical elements.",
            "Return a new sorted list without modifying the original list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def merge_sort(nums: List[int], ascending: bool = True) -> List[int]:\n    if len(nums) <= 1:\n        return nums\n    \n    mid = len(nums) // 2\n    left_half = merge_sort(nums[:mid], ascending)\n    right_half = merge_sort(nums[mid:], ascending)\n    \n    merged = []\n    i = j = 0\n    \n    while i < len(left_half) and j < len(right_half):\n        if (ascending and left_half[i] < right_half[j]) or (not ascending and left_half[i] > right_half[j]):\n            merged.append(left_half[i])\n            i += 1\n        else:\n            merged.append(right_half[j])\n            j += 1\n    \n    merged.extend(left_half[i:])\n    merged.extend(right_half[j:])\n    \n    return merged"
    },
    {
        "function_name": "shortest_path_in_grid",
        "file_name": "pathfinder.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D list representing the grid)",
            "start": "Tuple[int, int] (The starting coordinates in the grid)",
            "end": "Tuple[int, int] (The target coordinates in the grid)"
        },
        "objectives": [
            "Implement a breadth-first search (BFS) algorithm to find the shortest path in the grid from the start to the end coordinates.",
            "Handle obstacles in the grid represented by 1s (where movement is not allowed).",
            "Ensure that diagonal movements are not allowed and only horizontal and vertical moves are considered.",
            "Return the length of the shortest path or -1 if no path exists."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from collections import deque"
        ],
        "function_def": "def shortest_path_in_grid(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    if not grid or not grid[0]:\n        return -1\n    \n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)\n    visited = set()\n    visited.add(start)\n    \n    while queue:\n        row, col, distance = queue.popleft()\n        \n        if (row, col) == end:\n            return distance\n        \n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0:\n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, distance + 1))\n    \n    return -1"
    },
    {
        "function_name": "longest_common_prefix",
        "file_name": "prefix_finder.py",
        "parameters": {
            "strings": "List[str] (A list of strings to be compared)"
        },
        "objectives": [
            "Determine the longest common prefix shared among the provided strings.",
            "Handle cases where the list is empty or when there are no common prefixes.",
            "Ensure the algorithm runs efficiently without unnecessary comparisons.",
            "Return the longest common prefix as a string."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_common_prefix(strings: List[str]) -> str:\n    if not strings:\n        return \"\"\n    \n    prefix = strings[0]\n    \n    for string in strings[1:]:\n        while string[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:-1]\n    \n    return prefix"
    },
    {
        "function_name": "filter_and_transform",
        "file_name": "string_transformer.py",
        "parameters": {
            "strings": "List[str]",
            "threshold": "int"
        },
        "objectives": [
            "Filter the list of strings to only include those whose lengths are greater than the specified threshold.",
            "For each remaining string, reverse it and convert it to uppercase.",
            "Return a list of tuples, where each tuple contains the original string and its transformed version."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def filter_and_transform(strings: List[str], threshold: int) -> List[Tuple[str, str]]:\n    transformed = []\n    for s in strings:\n        if len(s) > threshold:\n            transformed.append((s, s[::-1].upper()))\n    return transformed"
    },
    {
        "function_name": "high_value_coordinates",
        "file_name": "grid_analyzer.py",
        "parameters": {
            "grid": "List[List[int]]",
            "threshold": "int"
        },
        "objectives": [
            "Create a function to find all coordinates in a 2D grid where the value exceeds the specified threshold.",
            "For each coordinate found, calculate and store the Manhattan distance from that coordinate to the origin (0,0).",
            "Return a list of tuples, where each tuple contains the coordinate and its distance from the origin."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def high_value_coordinates(grid: List[List[int]], threshold: int) -> List[Tuple[Tuple[int, int], int]]:\n    result = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] > threshold:\n                distance = abs(i) + abs(j)\n                result.append(((i, j), distance))\n    return result"
    },
    {
        "function_name": "group_items_by_length",
        "file_name": "item_grouping.py",
        "parameters": {
            "items": "List[str]",
            "limit": "int"
        },
        "objectives": [
            "Implement a function to group items based on length such that no group exceeds the specified limit on the overall character count.",
            "Create groups of strings that can be concatenated to remain under or equal to the threshold.",
            "Return a list of groups, where each group is represented by a list of strings."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def group_items_by_length(items: List[str], limit: int) -> List[List[str]]:\n    groups = []\n    current_group = []\n    current_length = 0\n    \n    for item in items:\n        item_length = len(item)\n        if current_length + item_length > limit:\n            groups.append(current_group)\n            current_group = [item]\n            current_length = item_length\n        else:\n            current_group.append(item)\n            current_length += item_length\n            \n    if current_group:\n        groups.append(current_group)\n    \n    return groups"
    },
    {
        "function_name": "compute_weighted_average",
        "file_name": "average_calculator.py",
        "parameters": {
            "data": "List[float]",
            "weights": "List[float]"
        },
        "objectives": [
            "Create a function to compute the weighted average of a list of numbers, where the weights are also provided in a separate list.",
            "Ensure proper weight normalization, so that the weights sum to 1 before multiplying by the respective values.",
            "Return the weighted average value, ensuring that a proper error handling is implemented for cases where the weights are not of the same length as the data."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def compute_weighted_average(data: List[float], weights: List[float]) -> float:\n    if len(data) != len(weights):\n        raise ValueError(\"Data and weights must be of the same length.\")\n    \n    total_weight = sum(weights)\n    if total_weight == 0:\n        raise ValueError(\"Weights must not sum to zero.\")\n    \n    weighted_sum = sum(d * w for d, w in zip(data, weights))\n    normalized_average = weighted_sum / total_weight\n    \n    return normalized_average"
    },
    {
        "function_name": "count_occurrences",
        "file_name": "occurrences_counter.py",
        "parameters": {
            "arr": "List[int] (An array of integers)",
            "x": "int (The target integer whose occurrences are to be counted)"
        },
        "objectives": [
            "Count the occurrences of the target integer \"x\" in the array \"arr\".",
            "For each occurrence, record the indices at which \"x\" appears.",
            "If \"x\" is found, determine the maximum and minimum indices of occurrences.",
            "Return the count, list of indices, and the maximum and minimum index."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def count_occurrences(arr: List[int], x: int) -> Tuple[int, List[int], int, int]:\n    indices = []\n    \n    for index, value in enumerate(arr):\n        if value == x:\n            indices.append(index)\n    \n    count = len(indices)\n    if count > 0:\n        return count, indices, max(indices), min(indices)\n    \n    return 0, [], -1, -1"
    },
    {
        "function_name": "top_k_elements",
        "file_name": "top_elements.py",
        "parameters": {
            "nums": "List[int] (List of integers)",
            "k": "int (The number of top elements to find)"
        },
        "objectives": [
            "Transform the list into a heap structure for efficient max extraction.",
            "Extract the top \"k\" elements from the heap.",
            "Ensure that the extracted elements are returned in ascending order.",
            "Return the top elements along with their sum."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List, Tuple"
        ],
        "function_def": "def top_k_elements(nums: List[int], k: int) -> Tuple[List[int], int]:\n    top_elements = heapq.nlargest(k, nums)\n    top_elements.sort()\n    return top_elements, sum(top_elements)"
    },
    {
        "function_name": "find_kth_largest",
        "file_name": "kth_largest_finder.py",
        "parameters": {
            "nums": "List[int] - A list containing unique integers.",
            "k": "int - The target integer to find the kth largest element."
        },
        "objectives": [
            "Implement an algorithm to find the kth largest element in an array without sorting the array.",
            "Ensure the algorithm operates in a time complexity better than O(n log n).",
            "Return the kth largest element from the array."
        ],
        "import_lines": [
            "from typing import List",
            "import heapq"
        ],
        "function_def": "def find_kth_largest(nums: List[int], k: int) -> int:\n    return heapq.nlargest(k, nums)[-1]"
    },
    {
        "function_name": "longest_allowed_substring",
        "file_name": "substring_finder.py",
        "parameters": {
            "s": "str - The input string which may contain various characters.",
            "allowed_chars": "Set[str] - A set of characters that are allowed to be included in the substring."
        },
        "objectives": [
            "Implement a function to find the longest substring that consists of only allowed characters.",
            "Ensure that the function operates with a time complexity of O(n).",
            "Return the longest substring found, or an empty string if no such substring exists."
        ],
        "import_lines": [],
        "function_def": "def longest_allowed_substring(s: str, allowed_chars: set) -> str:\n    max_length = 0\n    max_substr = \"\"\n    current_substr = \"\"\n    \n    for char in s:\n        if char in allowed_chars:\n            current_substr += char\n            if len(current_substr) > max_length:\n                max_length = len(current_substr)\n                max_substr = current_substr\n        else:\n            current_substr = \"\"\n    \n    return max_substr"
    },
    {
        "function_name": "sum_of_primes",
        "file_name": "prime_summation.py",
        "parameters": {
            "start": "int - The starting number of the range.",
            "end": "int - The ending number of the range."
        },
        "objectives": [
            "Calculate the sum of all prime numbers within the specified range [start, end].",
            "Ensure that the function accurately identifies prime numbers through a compounded primality test to handle larger ranges efficiently.",
            "Return the sum of the prime numbers found."
        ],
        "import_lines": [],
        "function_def": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True"
    },
    {
        "function_name": "spell_check_and_correct",
        "file_name": "spell_checker.py",
        "parameters": {
            "sentences": "List[str] - A list of sentences for spell-checking and rephrasing.",
            "dictionary": "Set[str] - A set of valid words for comparison during spell-checking."
        },
        "objectives": [
            "Implement a spell-checker to identify and suggest corrections for misspelled words in the provided sentences.",
            "Ensure that each suggested correction replaces the misspelled word with the nearest valid word from the dictionary based on edit distance (Levenshtein distance).",
            "Return a list of corrected sentences."
        ],
        "import_lines": [
            "from typing import List, Set",
            "from difflib import get_close_matches"
        ],
        "function_def": "def spell_check_and_correct(sentences: List[str], dictionary: Set[str]) -> List[str]:\n    corrected_sentences = []\n    \n    for sentence in sentences:\n        words = sentence.split()\n        corrected_words = []\n        \n        for word in words:\n            if word.lower() in dictionary:\n                corrected_words.append(word)\n            else:\n                correction = get_close_matches(word.lower(), dictionary, n=1)\n                corrected_words.append(correction[0] if correction else word)\n        \n        corrected_sentences.append(' '.join(corrected_words))\n        \n    return corrected_sentences"
    },
    {
        "function_name": "max_profit_stocks",
        "file_name": "stock_profit.py",
        "parameters": {
            "prices": "List[float] - A list of stock prices over time.",
            "k": "int - The number of maximum allowed transactions."
        },
        "objectives": [
            "Implement an algorithm to determine the maximum profit that can be achieved from at most `k` transactions.",
            "Ensure the algorithm uses dynamic programming, maintaining an array that represents profits at each transaction point.",
            "Return the maximum profit achievable given the constraints."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_profit_stocks(prices: List[float], k: int) -> float:\n    if not prices or k == 0:\n        return 0.0\n       \n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n - 1))\n    \n    dp = [[0] * (k + 1) for _ in range(n)]\n    \n    for j in range(1, k + 1):\n        max_diff = -prices[0]\n        for i in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], prices[i] + max_diff)\n            max_diff = max(max_diff, dp[i][j - 1] - prices[i])\n    \n    return dp[n - 1][k]"
    },
    {
        "function_name": "top_k_frequent_elements",
        "file_name": "frequency_analysis.py",
        "parameters": {
            "nums": "List[int]",
            "k": "int"
        },
        "objectives": [
            "Implement a function to find the k most frequent elements in \"nums\".",
            "Use a hashmap to count the frequency of each element and then utilize a heap/priority queue to extract the top k frequent elements.",
            "Return the k most frequent elements in descending order of their frequency."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import Counter",
            "import heapq"
        ],
        "function_def": "def top_k_frequent_elements(nums: List[int], k: int) -> List[int]:\n    frequency_map = Counter(nums)\n    return [item for item, _ in heapq.nlargest(k, frequency_map.items(), key=lambda x: x[1])]"
    },
    {
        "function_name": "length_of_longest_substring",
        "file_name": "substring_length.py",
        "parameters": {
            "s": "str"
        },
        "objectives": [
            "Implement a function to find the length of the longest substring without repeating characters in the string \"s\".",
            "Use a sliding window approach to track the current substring and its characters in a set.",
            "Ensure efficiency by updating the start index when a repeated character is encountered."
        ],
        "import_lines": [],
        "function_def": "def length_of_longest_substring(s: str) -> int:\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n        \n    return max_length"
    },
    {
        "function_name": "spiral_order_traversal",
        "file_name": "matrix_traversal.py",
        "parameters": {
            "matrix": "List[List[int]]"
        },
        "objectives": [
            "Implement a function to perform a spiral order traversal of a 2D matrix.",
            "Ensure to handle both rectangular and square matrices without modifying the original matrix.",
            "Return the traversal order as a flattened list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def spiral_order_traversal(matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n        return []\n    \n    result = []\n    top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\n    \n    while top <= bottom and left <= right:\n        result.extend(matrix[top][left:right+1])\n        top += 1\n        \n        for row in range(top, bottom+1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        if top <= bottom:\n            result.extend(matrix[bottom][left:right+1][::-1])\n            bottom -= 1\n            \n        if left <= right:\n            for row in range(bottom, top-1, -1):\n                result.append(matrix[row][left])\n            left += 1\n            \n    return result"
    },
    {
        "function_name": "string_to_numeric_value",
        "file_name": "string_numerics.py",
        "parameters": {
            "s": "str"
        },
        "objectives": [
            "Implement a function to convert a string into its corresponding numeric value based on a specified mapping of characters to integers.",
            "Each character's value should be determined by its position in the string, where the first character has the highest multiplicative weight.",
            "Ensure that the function correctly handles both upper and lower case letters as having the same value."
        ],
        "import_lines": [],
        "function_def": "def string_to_numeric_value(s: str) -> int:\n    total_value = 0\n    length = len(s)\n    \n    for index, char in enumerate(s):\n        normalized_char = char.lower()\n        char_value = ord(normalized_char) - ord('a') + 1\n        total_value += char_value * (length - index)\n        \n    return total_value"
    },
    {
        "function_name": "max_product_of_two",
        "file_name": "product_calculator.py",
        "parameters": {
            "nums": "List[int]"
        },
        "objectives": [
            "Implement a function that finds the maximum product of any two distinct numbers from the list.",
            "Ensure the function handles cases with negative numbers correctly, where the maximum product might be formed by two negative numbers.",
            "Return the product as an integer."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_product_of_two(nums: List[int]) -> int:\n    if len(nums) < 2:\n        raise ValueError(\"At least two numbers are required.\")\n    \n    max1, max2 = float('-inf'), float('-inf')\n    min1, min2 = float('inf'), float('inf')\n    \n    for num in nums:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    return max(max1 * max2, min1 * min2)"
    },
    {
        "function_name": "knapsack_problem",
        "file_name": "knapsack_solver.py",
        "parameters": {
            "items": "List[Tuple[str, int]] - A list of tuples where each tuple consists of an item name and its weight.",
            "capacity": "int - The maximum capacity that can be carried."
        },
        "objectives": [
            "Use a greedy algorithm to select items based on their weight-to-value ratio, adding items to the knapsack until no more can fit.",
            "Ensure that no item is fractional; only complete items can be added.",
            "Return the total weight of the items that can be fit in the knapsack."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def knapsack_problem(items: List[Tuple[str, int]], capacity: int) -> int:\n    items.sort(key=lambda x: x[1], reverse=True)  # Sort by weight in descending order\n    total_weight = 0\n    \n    for item, weight in items:\n        if total_weight + weight <= capacity:\n            total_weight += weight\n    \n    return total_weight"
    },
    {
        "function_name": "search_in_sorted_matrix",
        "file_name": "matrix_search.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D matrix containing integers.",
            "target": "int - The target number to find in the matrix."
        },
        "objectives": [
            "Implement an algorithm to search for a target value in the matrix, which is sorted in ascending order both row-wise and column-wise.",
            "Ensure efficient traversal, eliminating the need to check each element and enabling rapid identification of the target's presence.",
            "Return True if the target exists in the matrix, otherwise return False."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def search_in_sorted_matrix(matrix: List[List[int]], target: int) -> bool:\n    if not matrix or not matrix[0]:\n        return False\n    \n    rows, cols = len(matrix), len(matrix[0])\n    r, c = 0, cols - 1\n    \n    while r < rows and c >= 0:\n        if matrix[r][c] == target:\n            return True\n        elif matrix[r][c] > target:\n            c -= 1\n        else:\n            r += 1\n            \n    return False"
    },
    {
        "function_name": "find_paths_bfs",
        "file_name": "path_finder.py",
        "parameters": {
            "graph": "List[List[int]]",
            "start_node": "int",
            "end_node": "int",
            "max_hops": "int"
        },
        "objectives": [
            "Implement a breadth-first search (BFS) to find all distinct paths from `start_node` to `end_node`.",
            "Ensure that the path length does not exceed `max_hops`.",
            "Return all found paths in lexicographical order."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from collections import deque"
        ],
        "function_def": "def find_paths_bfs(graph: List[List[int]], start_node: int, end_node: int, max_hops: int) -> List[List[int]]:\n    result = []\n    q = deque([(start_node, [start_node])])\n    \n    while q:\n        current_node, path = q.popleft()\n        \n        if current_node == end_node and len(path) <= max_hops + 1:\n            result.append(path)\n        \n        if len(path) - 1 < max_hops:  # Ensure we don\u2019t exceed max hops\n            for neighbor in graph[current_node]:\n                if neighbor not in path:  # Prevent cycles\n                    q.append((neighbor, path + [neighbor]))\n    \n    return sorted(result)"
    },
    {
        "function_name": "generate_unique_substrings",
        "file_name": "substring_generator.py",
        "parameters": {
            "s": "str",
            "min_length": "int"
        },
        "objectives": [
            "Generate all unique substrings of the string `s`.",
            "Filter these substrings to include only those with a length greater than or equal to `min_length`.",
            "Return the filtered substrings in sorted order."
        ],
        "import_lines": [
            "from typing import Set"
        ],
        "function_def": "def generate_unique_substrings(s: str, min_length: int) -> Set[str]:\n    unique_substrings = set()\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(i + min_length, n + 1):\n            unique_substrings.add(s[i:j])\n    \n    return sorted(unique_substrings)"
    },
    {
        "function_name": "calculate_moving_average",
        "file_name": "moving_average.py",
        "parameters": {
            "nums": "List[int]",
            "window_size": "int"
        },
        "objectives": [
            "Calculate the moving average of `nums` over a specified `window_size`.",
            "Ensure that the first few averages (where the window does not fully fit) are calculated correctly.",
            "Return the moving averages as a list of floats."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def calculate_moving_average(nums: List[int], window_size: int) -> List[float]:\n    if window_size <= 0:\n        raise ValueError(\"Window size must be positive.\")\n        \n    moving_averages = []\n    window_sum = 0\n    \n    for i in range(len(nums)):\n        window_sum += nums[i]\n        \n        # Remove the element that is exiting the window\n        if i >= window_size:\n            window_sum -= nums[i - window_size]\n        \n        # Calculate the moving average only when we have a complete window\n        if i >= window_size - 1:\n            moving_average = window_sum / window_size\n            moving_averages.append(moving_average)\n    \n    return moving_averages"
    },
    {
        "function_name": "running_total",
        "file_name": "operation_tracker.py",
        "parameters": {
            "operations": "List[Tuple[str, int]] - List of operations where each operation consists of a string (either \"add\" or \"subtract\") and an integer.",
            "target": "int - The target number to achieve."
        },
        "objectives": [
            "Process the list of operations to maintain a running total that adds or subtracts the specified integers.",
            "Track all intermediate totals in the order they are encountered.",
            "Return the list of intermediate totals along with whether the target was reached at any point."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def running_total(operations: List[Tuple[str, int]], target: int) -> Tuple[List[int], bool]:\n    total = 0\n    totals = []\n    target_reached = False\n    \n    for operation, value in operations:\n        if operation == \"add\":\n            total += value\n        elif operation == \"subtract\":\n            total -= value\n        totals.append(total)\n        if total == target:\n            target_reached = True\n    \n    return totals, target_reached"
    },
    {
        "function_name": "schedule_tasks",
        "file_name": "task_scheduler.py",
        "parameters": {
            "tasks": "List[Tuple[str, int]] - List of tasks where each task consists of a task name and priority (higher number indicates higher priority).",
            "k": "int - The maximum number of tasks to schedule based on priority."
        },
        "objectives": [
            "Sort the tasks based on their priorities in descending order.",
            "Select the top `k` tasks only.",
            "Return a list of task names for the selected top priority tasks."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def schedule_tasks(tasks: List[Tuple[str, int]], k: int) -> List[str]:\n    sorted_tasks = sorted(tasks, key=lambda x: x[1], reverse=True)\n    top_tasks = sorted_tasks[:k]\n    return [task[0] for task in top_tasks]"
    },
    {
        "function_name": "transpose_and_reverse",
        "file_name": "matrix_transformer.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D list representing a rectangular matrix.",
            "n": "int - The number of rows to consider for the transformation."
        },
        "objectives": [
            "Transpose the matrix selectively to only involve the first `n` rows.",
            "Reverse the order of elements in each transposed row.",
            "Return the transformed matrix with the transposed and reversed rows."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def transpose_and_reverse(matrix: List[List[int]], n: int) -> List[List[int]]:\n    if n > len(matrix):\n        n = len(matrix)  # Adjust n if it exceeds matrix row count\n    transposed = [[matrix[i][j] for i in range(n)] for j in range(len(matrix[0]))]\n    reversed_transposed = [row[::-1] for row in transposed]\n    \n    return reversed_transposed"
    },
    {
        "function_name": "generate_permutations",
        "file_name": "string_permutations.py",
        "parameters": {
            "s": "str"
        },
        "objectives": [
            "Create a function to generate all possible permutations of the string `s`.",
            "Ensure that the permutations are returned in lexicographical order.",
            "Handle cases where the input string contains duplicate characters by avoiding duplicate permutations."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def generate_permutations(s: str) -> List[str]:\n    from itertools import permutations\n    \n    unique_permutations = set(permutations(s))\n    sorted_permutations = sorted(''.join(p) for p in unique_permutations)\n    \n    return sorted_permutations"
    },
    {
        "function_name": "sentence_similarity",
        "file_name": "text_similarity.py",
        "parameters": {
            "sentences": "List[str]"
        },
        "objectives": [
            "Create a function to calculate the similarity between sentences based on shared words.",
            "Return a dictionary where keys are tuples of sentence indices and values are their similarity scores (based on the number of common words).",
            "Ensure that the scoring accounts only for unique words in each sentence."
        ],
        "import_lines": [
            "from typing import List, Dict, Tuple"
        ],
        "function_def": "def sentence_similarity(sentences: List[str]) -> Dict[Tuple[int, int], int]:\n    word_sets = [set(sentence.split()) for sentence in sentences]\n    similarity_scores = {}\n    \n    for i in range(len(word_sets)):\n        for j in range(i + 1, len(word_sets)):\n            common_words = word_sets[i].intersection(word_sets[j])\n            similarity_scores[(i, j)] = len(common_words)\n    \n    return similarity_scores"
    },
    {
        "function_name": "moving_average",
        "file_name": "sliding_window.py",
        "parameters": {
            "nums": "List[int] - An array of integers.",
            "window_size": "int - The size of the sliding window to consider."
        },
        "objectives": [
            "Calculate the moving average of the numbers in the provided list over a defined window size.",
            "Ensure efficient calculation by reusing the sum from the previous window rather than recalculating it from scratch.",
            "Handle edge cases where the window exceeds the number of available elements."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def moving_average(nums: List[int], window_size: int) -> List[float]:\n    if not nums or window_size <= 0:\n        return []\n    \n    result = []\n    window_sum = 0.0\n    for i in range(len(nums)):\n        window_sum += nums[i]\n        if i >= window_size:\n            window_sum -= nums[i - window_size]\n        if i >= window_size - 1:\n            result.append(window_sum / window_size)\n    \n    return result"
    },
    {
        "function_name": "filter_and_normalize_words",
        "file_name": "word_filter.py",
        "parameters": {
            "words": "List[str] - A list of words.",
            "max_length": "int - The maximum length of words to consider."
        },
        "objectives": [
            "Filter out all words that exceed the maximum specified length.",
            "Normalize the remaining words by converting them to lowercase and sorting them alphabetically.",
            "Return the unique words that meet the length criteria as a sorted list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def filter_and_normalize_words(words: List[str], max_length: int) -> List[str]:\n    filtered_words = {word.lower() for word in words if len(word) <= max_length}\n    return sorted(filtered_words)"
    },
    {
        "function_name": "find_largest_unique_integers",
        "file_name": "largest_unique.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "n": "int (The number of largest unique integers to find)"
        },
        "objectives": [
            "Identify the largest 'n' unique integers from 'nums'.",
            "Ensure that duplicates are removed while maintaining the order of first appearance.",
            "Return the resulting list sorted in descending order."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_largest_unique_integers(nums: List[int], n: int) -> List[int]:\n    unique_nums = list(dict.fromkeys(nums))  # Remove duplicates while preserving order\n    unique_nums.sort(reverse=True)  # Sort in descending order\n    return unique_nums[:n]  # Return the largest 'n' integers"
    },
    {
        "function_name": "generate_primes_in_range",
        "file_name": "prime_generator.py",
        "parameters": {
            "start": "int (The starting number of the range)",
            "end": "int (The ending number of the range)"
        },
        "objectives": [
            "Generate all prime numbers within the specified range (inclusive).",
            "Employ the Sieve of Eratosthenes algorithm for efficient prime generation.",
            "Return the list of prime numbers sorted in ascending order."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def generate_primes_in_range(start: int, end: int) -> List[int]:\n    sieve = [True] * (end + 1)\n    sieve[0], sieve[1] = False, False\n    \n    for current in range(2, int(end**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current * current, end + 1, current):\n                sieve[multiple] = False\n                \n    return [num for num in range(start, end + 1) if sieve[num]]"
    },
    {
        "function_name": "find_triplet_in_ratio",
        "file_name": "ratio_finder.py",
        "parameters": {
            "sequence": "List[int] (A list of integers representing the sequence)",
            "q": "int (The target ratio to check)"
        },
        "objectives": [
            "Determine whether there exists a triplet (i, j, k) in 'sequence' such that the ratio of the numbers at these indices meets the criteria: seq[k]/seq[j] = q and seq[j]/seq[i] = q.",
            "Ensure that the indices are distinct and respect the ordering: i < j < k.",
            "If such a triplet exists, return it as a tuple; otherwise, return None."
        ],
        "import_lines": [
            "from typing import List, Optional, Tuple"
        ],
        "function_def": "def find_triplet_in_ratio(sequence: List[int], q: int) -> Optional[Tuple[int, int, int]]:\n    n = len(sequence)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sequence[j] != 0 and sequence[i] != 0:  # Ensure division by zero does not occur\n                if sequence[j] / sequence[i] == q:\n                    for k in range(j + 1, n):\n                        if sequence[k] / sequence[j] == q:\n                            return (sequence[i], sequence[j], sequence[k])\n    return None"
    },
    {
        "function_name": "cartesian_product_sums",
        "file_name": "cartesian_product.py",
        "parameters": {
            "list1": "List[int] - A list of integers representing the first list for the Cartesian product.",
            "list2": "List[int] - A list of integers representing the second list for the Cartesian product."
        },
        "objectives": [
            "Compute the Cartesian product of the two provided lists.",
            "For each pair in the product, calculate the sum of the elements and store them in a new list.",
            "Return the new list of sums."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def cartesian_product_sums(list1: List[int], list2: List[int]) -> List[int]:\n    return [x + y for x in list1 for y in list2]"
    },
    {
        "function_name": "k_largest_unique_elements",
        "file_name": "largest_elements.py",
        "parameters": {
            "nums": "List[int] - A list of integers that can be positive, negative, or zero.",
            "k": "int - The number of largest elements to return."
        },
        "objectives": [
            "Implement a function that retrieves the `k` largest unique elements from the list.",
            "Ensure the function maintains a time complexity of O(n log k) due to sorting.",
            "Handle edge cases where `k` is greater than the available unique elements."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def k_largest_unique_elements(nums: List[int], k: int) -> List[int]:\n    unique_nums = list(set(nums))  # Get unique numbers\n    unique_nums.sort(reverse=True)  # Sort in descending order\n    return unique_nums[:k]  # Return the top k largest"
    },
    {
        "function_name": "are_parentheses_valid",
        "file_name": "parentheses_checker.py",
        "parameters": {
            "s": "str - The input string containing parentheses."
        },
        "objectives": [
            "Implement a function to determine if the parentheses in the string are valid.",
            "Ensure that every opening parenthesis has a matching closing parenthesis and they are properly nested.",
            "The function should provide an O(n) time complexity for valid substring checking."
        ],
        "import_lines": [],
        "function_def": "def are_parentheses_valid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack  # If stack is empty, parentheses are valid"
    },
    {
        "function_name": "encode_text_and_count",
        "file_name": "text_encoder.py",
        "parameters": {
            "text": "str",
            "encoding": "str"
        },
        "objectives": [
            "Convert the input `text` into bytes using the specified `encoding`.",
            "Count the number of non-ASCII characters in the original text before encoding.",
            "Return a tuple containing the byte representation and the count of non-ASCII characters."
        ],
        "import_lines": [
            "from typing import Tuple"
        ],
        "function_def": "def encode_text_and_count(text: str, encoding: str) -> Tuple[bytes, int]:\n    byte_representation = text.encode(encoding)\n    non_ascii_count = sum(1 for char in text if ord(char) > 127)\n    \n    return byte_representation, non_ascii_count"
    },
    {
        "function_name": "join_strings_with_delimiter",
        "file_name": "string_joiner.py",
        "parameters": {
            "lst": "List[str]",
            "delimiter": "str"
        },
        "objectives": [
            "Join the strings in `lst` into a single string separated by `delimiter`.",
            "Ensure that when adjacent strings are empty, the delimiter is still added between them.",
            "Return the resulting joined string."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def join_strings_with_delimiter(lst: List[str], delimiter: str) -> str:\n    return delimiter.join(lst)"
    },
    {
        "function_name": "fibonacci_in_list",
        "file_name": "fibonacci_filter.py",
        "parameters": {
            "nums": "List[int]",
            "n": "int"
        },
        "objectives": [
            "Create a function that returns a list of numbers from `nums` that are within the n-th Fibonacci sequence.",
            "Ensure that the Fibonacci sequence is generated up to the maximum value of `nums`.",
            "Return the list of Fibonacci numbers found in `nums` in ascending order without duplicates."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def fibonacci_in_list(nums: List[int], n: int) -> List[int]:\n    # Generate Fibonacci sequence up to the largest number in nums\n    fib = [0, 1]\n    while fib[-1] <= max(nums):\n        fib.append(fib[-1] + fib[-2])\n    \n    fibonacci_set = set(fib)  # Use a set for uniqueness\n    return sorted(fibonacci_set & set(nums))  # Intersection with input nums"
    },
    {
        "function_name": "significant_categories",
        "file_name": "category_analyzer.py",
        "parameters": {
            "data": "List[Tuple[str, float]] - A list of tuples where each tuple contains a category and a numerical value.",
            "threshold": "float - The minimum value to consider the category significant."
        },
        "objectives": [
            "Calculate the sum of values for each category.",
            "Identify categories that meet or exceed the threshold.",
            "Return a sorted list of significant categories based on their sums."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict"
        ],
        "function_def": "def significant_categories(data: List[Tuple[str, float]], threshold: float) -> List[str]:\n    category_sums: Dict[str, float] = {}\n    \n    for category, value in data:\n        if category in category_sums:\n            category_sums[category] += value\n        else:\n            category_sums[category] = value\n    \n    return sorted([cat for cat, total in category_sums.items() if total >= threshold])"
    },
    {
        "function_name": "longest_increasing_subsequence",
        "file_name": "lis_finder.py",
        "parameters": {
            "sequence": "List[int] - A sequence in which we want to find the longest increasing subsequence."
        },
        "objectives": [
            "Identify the longest increasing subsequence from the given sequence.",
            "Ensure that each element in the subsequence is strictly greater than the previous one.",
            "Return the length of the longest increasing subsequence."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_increasing_subsequence(sequence: List[int]) -> int:\n    if not sequence:\n        return 0\n    \n    lis = [1] * len(sequence)  # Initialize LIS array\n    \n    for i in range(1, len(sequence)):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n    \n    return max(lis)"
    },
    {
        "function_name": "three_sum_exists",
        "file_name": "three_sum_finder.py",
        "parameters": {
            "elements": "List[int]",
            "target_sum": "int"
        },
        "objectives": [
            "Determine whether any three distinct numbers in the list \"elements\" add up to a specified \"target_sum\".",
            "Sort the array to facilitate efficient searching and avoid duplicates in combinations.",
            "Use a two-pointer approach to identify pairs that complement a chosen number to reach the target sum.",
            "Return a boolean value indicating whether such a combination exists."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def three_sum_exists(elements: List[int], target_sum: int) -> bool:\n    elements.sort()\n    n = len(elements)\n    \n    for i in range(n):\n        left, right = i + 1, n - 1\n        while left < right:\n            current_sum = elements[i] + elements[left] + elements[right]\n            if current_sum == target_sum:\n                return True\n            elif current_sum < target_sum:\n                left += 1\n            else:\n                right -= 1\n            \n    return False"
    },
    {
        "function_name": "merge_intervals",
        "file_name": "interval_merger.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]]"
        },
        "objectives": [
            "Merge overlapping intervals to produce a set of non-overlapping intervals.",
            "Handle edge cases where the input list is empty or contains a single interval.",
            "Sort the intervals by their starting points, followed by their ending points as needed.",
            "Return a list of merged intervals in the correct format."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    if not intervals:\n        return []\n    \n    # Sort intervals based on the start time\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = []\n    current_interval = intervals[0]\n    \n    for next_interval in intervals[1:]:\n        if current_interval[1] >= next_interval[0]:  # Overlapping intervals\n            current_interval = (current_interval[0], max(current_interval[1], next_interval[1]))\n        else:\n            merged.append(current_interval)\n            current_interval = next_interval\n    \n    merged.append(current_interval)  # Add the last interval\n    return merged"
    },
    {
        "function_name": "longest_consecutive_sequence",
        "file_name": "consecutive_finder.py",
        "parameters": {
            "nums": "List[int]"
        },
        "objectives": [
            "Create a function that returns the longest consecutive sequence of integers from the list \"nums\".",
            "Use a set to allow for O(1) average time complexity for lookups and to avoid duplicates.",
            "Iterate through each number and check for the existence of consecutive numbers in the set.",
            "Return the length of the longest consecutive sequence found."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_consecutive_sequence(nums: List[int]) -> int:\n    num_set = set(nums)\n    longest_streak = 0\n    \n    for num in num_set:\n        if num - 1 not in num_set:  # Check if it's the start of a streak\n            current_num = num\n            current_streak = 1\n            \n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n            \n            longest_streak = max(longest_streak, current_streak)\n    \n    return longest_streak"
    },
    {
        "function_name": "filtered_word_count",
        "file_name": "word_counter.py",
        "parameters": {
            "words": "List[str] - A list of words to process.",
            "min_length": "int - The minimum length of words to consider."
        },
        "objectives": [
            "Filter words based on the specified minimum length.",
            "Count the occurrences of each filtered word and ensure case-insensitivity.",
            "Return a sorted list of tuples containing words and their counts, sorted by count in descending order."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from collections import Counter"
        ],
        "function_def": "def filtered_word_count(words: List[str], min_length: int) -> List[Tuple[str, int]]:\n    filtered_words = [word.lower() for word in words if len(word) >= min_length]\n    word_counts = Counter(filtered_words)\n    return sorted(word_counts.items(), key=lambda item: item[1], reverse=True)"
    },
    {
        "function_name": "analyze_filtered_data",
        "file_name": "data_analyzer.py",
        "parameters": {
            "data": "List[float] - A list of numeric values.",
            "threshold": "float - A threshold for filtering values."
        },
        "objectives": [
            "Filter the list to retain only values greater than the specified threshold.",
            "Calculate the mean and median of the filtered list and handle cases with no valid values.",
            "Return a dictionary with the filtered list, mean, and median."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import statistics"
        ],
        "function_def": "def analyze_filtered_data(data: List[float], threshold: float) -> Dict[str, float]:\n    filtered_data = [value for value in data if value > threshold]\n    \n    if not filtered_data:\n        return {\"filtered_data\": [], \"mean\": None, \"median\": None}\n    \n    mean_value = sum(filtered_data) / len(filtered_data)\n    median_value = statistics.median(filtered_data)\n    \n    return {\"filtered_data\": filtered_data, \"mean\": mean_value, \"median\": median_value}"
    },
    {
        "function_name": "substring_frequency",
        "file_name": "substring_counter.py",
        "parameters": {
            "strings": "List[str] - A list of strings for comparison.",
            "length": "int - The target length for substring comparison."
        },
        "objectives": [
            "Identify all substrings of the specified length from each string.",
            "Count the frequency of each substring across all strings.",
            "Return a dictionary mapping each substring to its frequency."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def substring_frequency(strings: List[str], length: int) -> Dict[str, int]:\n    substring_count = {}\n    \n    for string in strings:\n        for i in range(len(string) - length + 1):\n            substring = string[i:i + length]\n            if substring in substring_count:\n                substring_count[substring] += 1\n            else:\n                substring_count[substring] = 1\n    \n    return substring_count"
    },
    {
        "function_name": "count_percentage_occurrences",
        "file_name": "occurrence_counter.py",
        "parameters": {
            "arr": "List[int] (The list of numbers to be checked)",
            "num": "int (The target number for checking its occurrences)"
        },
        "objectives": [
            "Count the occurrences of the 'num' in the 'arr'.",
            "Calculate and return the percentage of the occurrences relative to the total size of the array.",
            "Ensure that the function can handle empty lists and return an appropriate message when the array is empty."
        ],
        "import_lines": [
            "from typing import List, Union"
        ],
        "function_def": "def count_percentage_occurrences(arr: List[int], num: int) -> Union[str, float]:\n    if not arr:\n        return \"Array is empty\"\n    \n    count = arr.count(num)\n    percentage = (count / len(arr)) * 100\n    return percentage"
    },
    {
        "function_name": "are_parentheses_balanced",
        "file_name": "parentheses_checker.py",
        "parameters": {
            "sequence": "str (The input string representing a sequence of parentheses)"
        },
        "objectives": [
            "Determine if the parentheses in the 'sequence' are balanced.",
            "Implement the logic to account for nested parentheses and variations in types (e.g., (), {}, []).",
            "Return a boolean value that confirms whether the given parentheses are balanced or not."
        ],
        "import_lines": [],
        "function_def": "def are_parentheses_balanced(sequence: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in sequence:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if stack == [] or mapping[char] != stack.pop():\n                return False\n    \n    return stack == []"
    },
    {
        "function_name": "majority_elements",
        "file_name": "majority_finder.py",
        "parameters": {
            "arr": "List[int] (The list of integers which may contain duplicates)"
        },
        "objectives": [
            "Construct a new list from 'arr' that contains only the majority elements (elements that appear more than n/3 times).",
            "Ensure that each majority element is included only once in the output list.",
            "Utilize a linear pass and a dictionary to count occurrences and filter the results efficiently."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def majority_elements(arr: List[int]) -> List[int]:\n    count = {}\n    n = len(arr)\n    \n    for num in arr:\n        count[num] = count.get(num, 0) + 1\n    \n    return [num for num, cnt in count.items() if cnt > n / 3]"
    },
    {
        "function_name": "calculate_average_pass_scores",
        "file_name": "scores_analysis.py",
        "parameters": {
            "arr": "List[int] - A list of integers where each integer is a score out of 100.",
            "threshold": "int - A minimum score threshold to filter passing scores."
        },
        "objectives": [
            "Filter out scores below the specified threshold.",
            "Calculate the average of the remaining scores and handle any division by zero if no scores are left.",
            "Return a dictionary containing the number of scores above the threshold and the average score."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def calculate_average_pass_scores(arr: List[int], threshold: int) -> Dict[str, float]:\n    passing_scores = [score for score in arr if score >= threshold]\n    count = len(passing_scores)\n    average = sum(passing_scores) / count if count > 0 else 0.0\n    return {\"count\": count, \"average\": average}"
    },
    {
        "function_name": "fibonacci_with_threshold",
        "file_name": "fibonacci_generator.py",
        "parameters": {
            "n": "int - The upper limit to generate the Fibonacci sequence.",
            "threshold": "int - The upper value to stop generating the sequence if it exceeds this value."
        },
        "objectives": [
            "Generate the Fibonacci sequence up to the upper limit n.",
            "Stop adding new Fibonacci numbers if the next number exceeds the specified threshold.",
            "Ensure all numbers in the generated sequence are unique and return them as a list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def fibonacci_with_threshold(n: int, threshold: int) -> List[int]:\n    fib_sequence = []\n    a, b = 0, 1\n    while a <= n and a <= threshold:\n        fib_sequence.append(a)\n        a, b = b, a + b\n    return fib_sequence"
    },
    {
        "function_name": "row_column_sums",
        "file_name": "matrix_sum_checker.py",
        "parameters": {
            "n": "int (Size of the matrix)",
            "matrix": "List[List[int]] (A 2D list representing the matrix of integers)",
            "k": "int (A value used to determine which sums to check for odd/even properties)"
        },
        "objectives": [
            "Identify all unique sums of the rows and columns of the given matrix.",
            "For each identified sum, determine if it is odd or even.",
            "Return a dictionary mapping each sum to a boolean value indicating whether it is odd (True) or even (False), filtered to only include sums that are greater than or equal to 'k'."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def row_column_sums(n: int, matrix: List[List[int]], k: int) -> Dict[int, bool]:\n    sum_dict = {}\n    \n    # Calculate row sums\n    for row in matrix:\n        row_sum = sum(row)\n        if row_sum >= k:\n            sum_dict[row_sum] = (row_sum % 2 != 0)  # True if odd, False if even\n    \n    # Calculate column sums\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum >= k:\n            sum_dict[col_sum] = (col_sum % 2 != 0)\n    \n    return sum_dict"
    },
    {
        "function_name": "frequent_characters",
        "file_name": "char_frequency.py",
        "parameters": {
            "string": "str (The input string to be analyzed)",
            "threshold": "int (The threshold for character frequency)"
        },
        "objectives": [
            "Count the frequency of each character in the string, ignoring case sensitivity.",
            "Identify characters that occur more than the specified 'threshold'.",
            "Return a sorted list of these characters in descending order of their frequency."
        ],
        "import_lines": [
            "from collections import Counter",
            "from typing import List"
        ],
        "function_def": "def frequent_characters(string: str, threshold: int) -> List[str]:\n    counts = Counter(string.lower())\n    return sorted([char for char, count in counts.items() if count > threshold], key=lambda x: -counts[x])"
    },
    {
        "function_name": "subsets_with_target_mean",
        "file_name": "mean_subset_finder.py",
        "parameters": {
            "arr": "List[int] (A list of integers)",
            "target_mean": "float (The target mean for the subsets)"
        },
        "objectives": [
            "Identify all subsets of the given list that have a mean equal to the specified target_mean.",
            "Return these subsets as a list of lists.",
            "Ensure that subsets are unique, and each subset must have at least two elements."
        ],
        "import_lines": [
            "from itertools import combinations",
            "from typing import List"
        ],
        "function_def": "def subsets_with_target_mean(arr: List[int], target_mean: float) -> List[List[int]]:\n    target_sum = target_mean * 2  # Start with a base, we need at least 2 elements to compute mean\n    result_subsets = []\n    \n    n = len(arr)\n    for r in range(2, n + 1):\n        for subset in combinations(arr, r):\n            if sum(subset) == target_sum and len(subset) > 0:\n                result_subsets.append(list(subset))\n    \n    return result_subsets"
    },
    {
        "function_name": "combinations_above_average",
        "file_name": "combination_filter.py",
        "parameters": {
            "arr": "List[int]",
            "size": "int"
        },
        "objectives": [
            "Determine all combinations of `size` elements from the list `arr`.",
            "Ensure each combination is unique and sorted.",
            "Calculate the sum for each combination and return the combinations that have a sum greater than a specified threshold (average of all combinations)."
        ],
        "import_lines": [
            "from typing import List",
            "import itertools"
        ],
        "function_def": "def combinations_above_average(arr: List[int], size: int) -> List[List[int]]:\n    combs = list(itertools.combinations(arr, size))\n    average = sum(sum(comb) for comb in combs) / len(combs) if combs else 0\n    return [list(comb) for comb in combs if sum(comb) > average]"
    },
    {
        "function_name": "calculate_levenshtein_distance",
        "file_name": "levenshtein_calculator.py",
        "parameters": {
            "s1": "str",
            "s2": "str"
        },
        "objectives": [
            "Compute the Levenshtein distance between strings `s1` and `s2`.",
            "Use dynamic programming to create a matrix that calculates the minimum edit distance.",
            "Return both the distance and the matrix used during computation."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def calculate_levenshtein_distance(s1: str, s2: str) -> Tuple[int, List[List[int]]]:\n    m, n = len(s1), len(s2)\n    distance_matrix = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        distance_matrix[i][0] = i\n    for j in range(n + 1):\n        distance_matrix[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                cost = 0\n            else:\n                cost = 1\n            distance_matrix[i][j] = min(distance_matrix[i - 1][j] + 1,      # Deletion\n                                         distance_matrix[i][j - 1] + 1,      # Insertion\n                                         distance_matrix[i - 1][j - 1] + cost)  # Substitution\n            \n    return distance_matrix[m][n], distance_matrix"
    },
    {
        "function_name": "transpose_and_check_symmetric",
        "file_name": "matrix_utils.py",
        "parameters": {
            "matrix": "List[List[int]]"
        },
        "objectives": [
            "Transpose a given 2D matrix.",
            "Check if the result is a symmetric matrix (i.e., matrix[i][j] == matrix[j][i] for all valid i, j).",
            "Return a tuple containing the transposed matrix and a boolean indicating whether it is symmetric."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def transpose_and_check_symmetric(matrix: List[List[int]]) -> Tuple[List[List[int]], bool]:\n    transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    \n    is_symmetric = True\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if transposed[i][j] != matrix[i][j]:\n                is_symmetric = False\n                break\n    \n    return transposed, is_symmetric"
    },
    {
        "function_name": "find_patterns_in_text",
        "file_name": "pattern_finder.py",
        "parameters": {
            "`patterns": "List[str]` (A list of string patterns)",
            "`text": "str` (The main text to search within)"
        },
        "objectives": [
            "Find all occurrences of the patterns in the text, ensuring that only non-overlapping matches are considered.",
            "For each pattern found, store the starting index and length of the match.",
            "Return the results sorted by the starting index of the matches."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def find_patterns_in_text(patterns: List[str], text: str) -> List[Tuple[int, int]]:\n    results = []\n    \n    for pattern in patterns:\n        start = 0\n        while True:\n            start = text.find(pattern, start)\n            if start == -1:\n                break\n            results.append((start, len(pattern)))\n            start += len(pattern)  # Move past the last match for non-overlap\n            \n    return sorted(results)  # Sort results by starting index"
    },
    {
        "function_name": "normalize_and_find_exceeding",
        "file_name": "data_normalizer.py",
        "parameters": {
            "series": "List[float]",
            "threshold": "float"
        },
        "objectives": [
            "Normalize the `series` by transforming data so that it lies within the range [0, 1].",
            "Identify any values in the normalized series that exceed the specified `threshold`.",
            "Return a tuple containing the normalized series and a list of indices where the values exceed the threshold."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def normalize_and_find_exceeding(series: List[float], threshold: float) -> Tuple[List[float], List[int]]:\n    min_value = min(series)\n    max_value = max(series)\n    normalized = [(value - min_value) / (max_value - min_value) if max_value != min_value else 0 for value in series]\n    exceeding_indices = [i for i, value in enumerate(normalized) if value > threshold]\n    \n    return normalized, exceeding_indices"
    },
    {
        "function_name": "find_k_nearest_points",
        "file_name": "neighbor_finder.py",
        "parameters": {
            "points": "List[Tuple[float, float]] - List of (x, y) coordinate tuples.",
            "k": "int - The number of nearest neighbors to find."
        },
        "objectives": [
            "Calculate the distance for each point from the origin (0, 0).",
            "Sort the points based on their distance from the origin.",
            "Return the k nearest points based on the calculated distances."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import math"
        ],
        "function_def": "def find_k_nearest_points(points: List[Tuple[float, float]], k: int) -> List[Tuple[float, float]]:\n    distances = [(math.sqrt(x**2 + y**2), (x, y)) for x, y in points]\n    sorted_points = sorted(distances, key=lambda item: item[0])\n    return [point[1] for point in sorted_points[:k]]"
    },
    {
        "function_name": "unique_long_strings",
        "file_name": "string_filter.py",
        "parameters": {
            "strings": "List[str] - A list of strings.",
            "min_length": "int - The minimum length of strings to consider."
        },
        "objectives": [
            "Identify all unique strings in the list that are longer than or equal to `min_length`.",
            "For each unique string, ensure that it is counted only once regardless of duplicates in the input.",
            "Return the results sorted in reverse alphabetical order."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def unique_long_strings(strings: List[str], min_length: int) -> List[str]:\n    unique_strings = set([s for s in strings if len(s) >= min_length])\n    return sorted(unique_strings, reverse=True)"
    },
    {
        "function_name": "find_points_within_radius",
        "file_name": "point_proximity.py",
        "parameters": {
            "points": "List[Tuple[int, int]] - A list of 2D points represented as (x, y) tuples.",
            "radius": "float - The radius to define an area of influence."
        },
        "objectives": [
            "Identify all pairs of points that fall within the specified `radius` of each other.",
            "Ensure that each pair is represented only once, irrespective of the order of points.",
            "Return the identified pairs sorted in ascending order based on the first point."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from math import sqrt"
        ],
        "function_def": "def find_points_within_radius(points: List[Tuple[int, int]], radius: float) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    pairs = set()\n    \n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2)\n            if distance <= radius:\n                pairs.add((points[i], points[j]))\n    \n    return sorted(pairs, key=lambda x: (x[0], x[1]))"
    },
    {
        "function_name": "average_top_k_scores",
        "file_name": "score_calculator.py",
        "parameters": {
            "arr": "List[int] - A list of integers representing scores.",
            "k": "int - The number of top scores to consider."
        },
        "objectives": [
            "Calculate the average score of the top `k` scores from the list while filtering out duplicates.",
            "Ensure that the resulting top scores are sorted in descending order before averaging.",
            "Handle cases where the size of the list is less than `k`, returning zero in that case."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def average_top_k_scores(arr: List[int], k: int) -> float:\n    if len(arr) < k:\n        return 0.0\n    \n    unique_scores = sorted(set(arr), reverse=True)[:k]\n    return sum(unique_scores) / len(unique_scores)"
    },
    {
        "function_name": "search_2d_matrix",
        "file_name": "matrix_search.py",
        "parameters": {
            "`matrix": "List[List[int]]` (A 2D matrix of integers)",
            "`target": "int` (The number to search for)"
        },
        "objectives": [
            "Traverse the entire matrix in a row-wise manner and identify if the `target` exists.",
            "If the `target` is found, return its row and column indices.",
            "If the `target` does not exist, return (-1, -1) indicating it was not found."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def search_2d_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]:\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == target:\n                return (i, j)\n    return (-1, -1)"
    },
    {
        "function_name": "find_repeating_sequences",
        "file_name": "sequence_analyzer.py",
        "parameters": {
            "`text": "str` (The string to analyze)",
            "`n": "int` (The minimum length of repeating sequences)"
        },
        "objectives": [
            "Identify all unique sequences in the text that are at least `n` characters long and contain repeating characters.",
            "Create a frequency map that counts how many times each sequence appears.",
            "Return these sequences sorted by their frequencies in descending order."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from collections import defaultdict"
        ],
        "function_def": "def find_repeating_sequences(text: str, n: int) -> List[str]:\n    length = len(text)\n    frequency_map = defaultdict(int)\n    \n    for i in range(length):\n        for j in range(i + n, length + 1):\n            sequence = text[i:j]\n            if len(set(sequence)) < len(sequence):  # check for repeating characters\n                frequency_map[sequence] += 1\n                \n    sorted_sequences = sorted(frequency_map, key=lambda seq: frequency_map[seq], reverse=True)\n    return sorted_sequences"
    },
    {
        "function_name": "top_k_largest_products",
        "file_name": "product_calculator.py",
        "parameters": {
            "`numbers": "List[int]` (A list of integers)",
            "`k": "int` (The number of top largest products to consider)"
        },
        "objectives": [
            "Calculate the products of every combination of three distinct integers in `numbers`.",
            "Determine the `k` largest unique product values.",
            "Return these products sorted in descending order."
        ],
        "import_lines": [
            "from typing import List",
            "from itertools import combinations"
        ],
        "function_def": "def top_k_largest_products(numbers: List[int], k: int) -> List[int]:\n    products = set()\n    \n    for a, b, c in combinations(numbers, 3):\n        products.add(a * b * c)\n    \n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:k]"
    },
    {
        "function_name": "longest_common_subsequence",
        "file_name": "lcs_calculator.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences for which the subsequence needs to be found.",
            "subsequence": "List[int] - A sequence for which the longest common subsequence needs to be found in each of the sequences."
        },
        "objectives": [
            "Implement the Longest Common Subsequence (LCS) algorithm for each sequence against the given subsequence.",
            "Return the lengths of the LCS for each sequence indicating how many elements matched.",
            "Ensure optimality using dynamic programming while managing edge cases where sequences might be empty."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_common_subsequence(sequences: List[List[int]], subsequence: List[int]) -> List[int]:\n    lcs_lengths = []\n    \n    for seq in sequences:\n        dp = [[0] * (len(subsequence) + 1) for _ in range(len(seq) + 1)]\n        for i in range(1, len(seq) + 1):\n            for j in range(1, len(subsequence) + 1):\n                if seq[i - 1] == subsequence[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        lcs_lengths.append(dp[len(seq)][len(subsequence)])\n    \n    return lcs_lengths"
    },
    {
        "function_name": "kth_largest",
        "file_name": "kth_finder.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The index of the kth largest element to find)"
        },
        "objectives": [
            "Find the kth largest element in the list.",
            "Ensure that the function handles cases where k is larger than the number of unique elements.",
            "Return the kth largest element, ensuring it is unique (not duplicated in the list).",
            "Handle empty lists gracefully."
        ],
        "import_lines": [
            "from typing import List, Optional"
        ],
        "function_def": "def kth_largest(nums: List[int], k: int) -> Optional[int]:\n    unique_nums = list(set(nums))\n    unique_nums.sort(reverse=True)\n    \n    if k > len(unique_nums) or k <= 0:\n        return None  # k is out of bounds\n    \n    return unique_nums[k - 1]"
    },
    {
        "function_name": "trend_analysis",
        "file_name": "trend_calculator.py",
        "parameters": {
            "prices": "List[float] (A list of stock prices over time)",
            "n": "int (The number of days to analyze for trend)"
        },
        "objectives": [
            "Calculate the rate of change for stock prices over 'n' days and classify them into trends (increasing, decreasing, stable).",
            "Return a summary count of how many days fell into each trend category.",
            "Ensure to avoid division by zero or invalid calculations when prices are unchanged.",
            "Return a dictionary with the count of trends."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def trend_analysis(prices: List[float], n: int) -> Dict[str, int]:\n    if len(prices) < n:\n        return {\"increasing\": 0, \"decreasing\": 0, \"stable\": 0}\n    \n    trends = {\"increasing\": 0, \"decreasing\": 0, \"stable\": 0}\n    \n    for i in range(len(prices) - n):\n        change = prices[i + n] - prices[i]\n        if change > 0:\n            trends[\"increasing\"] += 1\n        elif change < 0:\n            trends[\"decreasing\"] += 1\n        else:\n            trends[\"stable\"] += 1\n            \n    return trends"
    },
    {
        "function_name": "distribute_items",
        "file_name": "distribution_calculator.py",
        "parameters": {
            "n": "int - The total number of items to distribute.",
            "k": "int - The number of groups to distribute the items into."
        },
        "objectives": [
            "Calculate the number of ways to distribute `n` indistinguishable items into `k` distinguishable groups.",
            "Ensure the calculation handles cases where `n < 0` or `k < 1` appropriately.",
            "Return the result as an integer, representing the number of distributions."
        ],
        "import_lines": [
            "from math import comb"
        ],
        "function_def": "def distribute_items(n: int, k: int) -> int:\n    if n < 0 or k < 1:\n        return 0\n    return comb(n + k - 1, k - 1)"
    },
    {
        "function_name": "longest_subsequence_above_threshold",
        "file_name": "subsequence_finder.py",
        "parameters": {
            "sequence": "List[int] - A list of integers representing a sequence of numbers.",
            "threshold": "int - The threshold for evaluating the subsequence."
        },
        "objectives": [
            "Find the longest contiguous subsequence whose sum is greater than the `threshold`.",
            "If there are multiple subsequences of the same maximum length, return the first one found.",
            "Handle cases where no subsequence meets the criteria by returning an empty list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_subsequence_above_threshold(sequence: List[int], threshold: int) -> List[int]:\n    max_length = 0\n    max_subseq = []\n    current_sum = 0\n    current_start = 0\n    \n    for i in range(len(sequence)):\n        current_sum += sequence[i]\n        \n        while current_sum > threshold and current_start <= i:\n            if (i - current_start + 1) > max_length:\n                max_length = i - current_start + 1\n                max_subseq = sequence[current_start:i + 1]\n            current_sum -= sequence[current_start]\n            current_start += 1\n            \n    return max_subseq"
    },
    {
        "function_name": "bfs_traversal",
        "file_name": "graph_traversal.py",
        "parameters": {
            "graph": "Dict[int, List[int]] - An adjacency list representation of the graph.",
            "start": "int - The starting node for traversal."
        },
        "objectives": [
            "Implement a breadth-first search (BFS) to traverse the graph from the `start` node.",
            "Record the order of traversal in a list and return it as the output.",
            "Ensure that each node is visited only once, and handle cases of disconnected graphs by returning the traversal only from the connected component containing the `start` node."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import deque"
        ],
        "function_def": "def bfs_traversal(graph: Dict[int, List[int]], start: int) -> List[int]:\n    visited = set()\n    traversal_order = []\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            traversal_order.append(node)\n            queue.extend(n for n in graph[node] if n not in visited)\n    \n    return traversal_order"
    },
    {
        "function_name": "modular_product",
        "file_name": "modular_calculator.py",
        "parameters": {
            "numbers": "List[int] - A list of integers for which to calculate the product.",
            "modulus": "int - The modulus to apply to the product of all integers."
        },
        "objectives": [
            "Calculate the product of all numbers in the list and return the result modulo `modulus`.",
            "Handle edge cases such as empty lists by returning 1.",
            "Ensure that the function can accommodate very large integers without overflow."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def modular_product(numbers: List[int], modulus: int) -> int:\n    if not numbers:\n        return 1\n    \n    product = 1\n    for number in numbers:\n        product = (product * number) % modulus\n        \n    return product"
    },
    {
        "function_name": "get_divisible_numbers",
        "file_name": "divisibility_filter.py",
        "parameters": {
            "numbers": "List[int] (A list of integers to manipulate)",
            "divisor": "int (Divisor to check divisibility against)"
        },
        "objectives": [
            "Implement a function that returns a list of numbers from the input list that are divisible by the given divisor.",
            "Ensure that the returned list is sorted in ascending order.",
            "Handle the case where no numbers are divisible by the divisor by returning an empty list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def get_divisible_numbers(numbers: List[int], divisor: int) -> List[int]:\n    divisible_numbers = [num for num in numbers if num % divisor == 0]\n    return sorted(divisible_numbers)"
    },
    {
        "function_name": "extract_word_frequencies",
        "file_name": "word_extractor.py",
        "parameters": {
            "text": "str",
            "min_length": "int"
        },
        "objectives": [
            "Extract all distinct words from the input text that are at least `min_length` characters long.",
            "Count the frequency of each word while ignoring punctuation and capitalizing uniformly.",
            "Return a dictionary mapping each word to its frequency."
        ],
        "import_lines": [
            "from typing import Dict",
            "import re"
        ],
        "function_def": "def extract_word_frequencies(text: str, min_length: int) -> Dict[str, int]:\n    words = re.findall(r'\\b\\w{%d,}\\b' % min_length, text.lower())\n    frequency = {}\n    \n    for word in words:\n        frequency[word] = frequency.get(word, 0) + 1\n    \n    return frequency"
    },
    {
        "function_name": "max_product_subset",
        "file_name": "product_calculator.py",
        "parameters": {
            "nums": "List[int] (List of integers for which to find the maximum product)",
            "k": "int (The number of elements to multiply)"
        },
        "objectives": [
            "Generate all possible subsets of size `k` from the list.",
            "Calculate the product of elements in each subset.",
            "Return the maximum product found among those subsets."
        ],
        "import_lines": [
            "from itertools import combinations",
            "from typing import List"
        ],
        "function_def": "def max_product_subset(nums: List[int], k: int) -> int:\n    max_product = float('-inf')\n    \n    for subset in combinations(nums, k):\n        product = 1\n        for number in subset:\n            product *= number\n        max_product = max(max_product, product)\n    \n    return max_product"
    },
    {
        "function_name": "max_average_subarray",
        "file_name": "average_calculator.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The window size for evaluating the maximum average)"
        },
        "objectives": [
            "Calculate the maximum average of any contiguous subarray of size `k` within the list.",
            "Ensure that the function handles lists smaller than `k` by returning None.",
            "Optimize the calculation to have a time complexity of O(n) rather than a naive O(n*k) approach."
        ],
        "import_lines": [
            "from typing import List, Optional"
        ],
        "function_def": "def max_average_subarray(nums: List[int], k: int) -> Optional[float]:\n    if len(nums) < k:\n        return None\n    current_sum = sum(nums[:k])\n    max_sum = current_sum\n    \n    for i in range(k, len(nums)):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum / k"
    },
    {
        "function_name": "find_anagrams",
        "file_name": "anagram_finder.py",
        "parameters": {
            "words": "List[str] (A list of words)",
            "target": "str (The target word to search anagrams for)"
        },
        "objectives": [
            "Find all the anagrams of the target word within the list of words.",
            "Ensure that the anagrams are returned in a case-insensitive manner (e.g., \"Listen\" and \"Silent\" are the same).",
            "Only return unique anagrams without duplicates."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_anagrams(words: List[str], target: str) -> List[str]:\n    target_sorted = sorted(target.lower())\n    anagrams = set()\n    \n    for word in words:\n        if sorted(word.lower()) == target_sorted:\n            anagrams.add(word)\n            \n    return sorted(anagrams)"
    },
    {
        "function_name": "filter_unique_words",
        "file_name": "unique_word_filter.py",
        "parameters": {
            "words": "List[str]",
            "length": "int"
        },
        "objectives": [
            "Create a function to filter words from the list `words` that have a length equal to `length`.",
            "While filtering, maintain the original order of words.",
            "Handle the case where the output should be unique words, ignoring the order of the duplicates."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def filter_unique_words(words: List[str], length: int) -> List[str]:\n    seen = set()\n    unique_words = []\n    \n    for word in words:\n        if len(word) == length and word not in seen:\n            unique_words.append(word)\n            seen.add(word)\n    \n    return unique_words"
    },
    {
        "function_name": "rotate_array",
        "file_name": "array_rotator.py",
        "parameters": {
            "arr": "List[int]",
            "n": "int"
        },
        "objectives": [
            "Implement a function that rotates the array `arr` to the right by `n` steps, where `n` can be greater than the length of the array.",
            "The solution should handle cases where `n` is negative or zero and return the original array if `n` is equal to the length.",
            "Ensure that this is done without using an additional array for storage."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def rotate_array(arr: List[int], n: int) -> List[int]:\n    length = len(arr)\n    if length == 0:\n        return arr\n    n = n % length  # normalize n\n    if n == 0:\n        return arr\n    \n    # Reverse the whole array\n    arr.reverse()\n    # Reverse the first n elements\n    arr[:n] = reversed(arr[:n])\n    # Reverse the rest of the elements\n    arr[n:] = reversed(arr[n:])\n    \n    return arr"
    },
    {
        "function_name": "calculate_prefix_sums",
        "file_name": "prefix_sum_calculator.py",
        "parameters": {
            "data": "List[int] - A list of integers for which the prefix sums will be calculated.",
            "threshold": "int - A threshold value to determine how many prefix sums are greater than this value."
        },
        "objectives": [
            "Calculate the prefix sums of the input list of integers.",
            "Count how many of these prefix sums exceed the provided threshold.",
            "Return a list of the prefix sums that are greater than the threshold."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def calculate_prefix_sums(data: List[int], threshold: int) -> List[int]:\n    prefix_sums = []\n    current_sum = 0\n    \n    for num in data:\n        current_sum += num\n        prefix_sums.append(current_sum)\n    \n    return [sum for sum in prefix_sums if sum > threshold]"
    },
    {
        "function_name": "find_contiguous_subarrays",
        "file_name": "row_subarray_finder.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D list representing a matrix of integers.",
            "target": "int - The target sum we want to find in the rows."
        },
        "objectives": [
            "Identify which rows contain a contiguous subarray whose sum equals the target.",
            "Return all such rows along with the starting and ending indices of the found subarrays.",
            "Ensure that multiple subarrays within the same row are included in the result if they both sum to the target."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def find_contiguous_subarrays(matrix: List[List[int]], target: int) -> List[Tuple[int, List[Tuple[int, int]]]]:\n    result = []\n    \n    for i, row in enumerate(matrix):\n        current_sum = 0\n        start = 0\n        subarrays = []\n        \n        for end in range(len(row)):\n            current_sum += row[end]\n            \n            while current_sum > target and start <= end:\n                current_sum -= row[start]\n                start += 1\n            \n            if current_sum == target:\n                subarrays.append((start, end))\n        \n        if subarrays:\n            result.append((i, subarrays))\n    \n    return result"
    },
    {
        "function_name": "top_k_unique_integers",
        "file_name": "unique_integer_finder.py",
        "parameters": {
            "nums": "List[int] - A list of integers that may contain duplicates.",
            "k": "int - The number of unique integers to return."
        },
        "objectives": [
            "Identify the unique integers from the list and sort them in descending order.",
            "Return the top `k` unique integers from the sorted list.",
            "Handle edge cases where `k` exceeds the number of unique integers available."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def top_k_unique_integers(nums: List[int], k: int) -> List[int]:\n    unique_nums = list(set(nums))\n    unique_nums.sort(reverse=True)\n    return unique_nums[:k]"
    },
    {
        "function_name": "extract_palindromic_words",
        "file_name": "palindrome_extractor.py",
        "parameters": {
            "text": "str - A string from which to extract palindromic words.",
            "min_length": "int - The minimum length of a palindrome to consider."
        },
        "objectives": [
            "Extract all words from the text that are palindromes, ignoring case sensitivity.",
            "Ensure that each palindrome has at least the specified minimum length and retain their original case.",
            "Return the unique palindromic words in a sorted list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def extract_palindromic_words(text: str, min_length: int) -> List[str]:\n    words = text.split()\n    palindromes = {word for word in words if word.lower() == word[::-1].lower() and len(word) >= min_length}\n    return sorted(palindromes)"
    },
    {
        "function_name": "matrix_multiply",
        "file_name": "matrix_multiplier.py",
        "parameters": {
            "matrix1": "List[List[int]] - The first matrix for multiplication.",
            "matrix2": "List[List[int]] - The second matrix for multiplication."
        },
        "objectives": [
            "Implement matrix multiplication where the number of columns in matrix1 equals the number of rows in matrix2.",
            "Ensure the resulting matrix is correctly formatted and sized based on the multiplication rules.",
            "Return the resultant matrix as a list of lists."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]:\n    if len(matrix1[0]) != len(matrix2):\n        raise ValueError(\"Number of columns in matrix1 must be equal to number of rows in matrix2.\")\n    \n    result = [[0 for _ in range(len(matrix2[0]))] for _ in range(len(matrix1))]\n    for i in range(len(matrix1)):\n        for j in range(len(matrix2[0])):\n            result[i][j] = sum(matrix1[i][k] * matrix2[k][j] for k in range(len(matrix2)))\n            \n    return result"
    },
    {
        "function_name": "max_sliding_window_sum",
        "file_name": "window_sum_calculator.py",
        "parameters": {
            "lst": "List[int] - A list of integers.",
            "window_size": "int - The size of the sliding window for calculation."
        },
        "objectives": [
            "Compute the maximum sum of any contiguous subarray of size 'window_size'.",
            "Ensure that the function handles cases when the window size is greater than the list length appropriately.",
            "Return the maximum sum value."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_sliding_window_sum(lst: List[int], window_size: int) -> int:\n    if window_size > len(lst):\n        raise ValueError(\"Window size must not exceed the length of the list.\")\n    \n    max_sum = float('-inf')\n    current_sum = sum(lst[:window_size])\n    max_sum = max(max_sum, current_sum)\n    \n    for i in range(len(lst) - window_size):\n        current_sum = current_sum - lst[i] + lst[i + window_size]\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
    },
    {
        "function_name": "analyze_stock_prices",
        "file_name": "stock_analyzer.py",
        "parameters": {
            "prices": "List[float] - A list of stock prices over time.",
            "threshold": "float - A price threshold to determine sell actions."
        },
        "objectives": [
            "Identify dates where the stock price exceeds the specified threshold for the first time.",
            "Count the occurrences of each unique price above the threshold.",
            "Return a dictionary with unique prices above the threshold as keys and their corresponding counts as values."
        ],
        "import_lines": [
            "from collections import Counter",
            "from typing import List, Dict"
        ],
        "function_def": "def analyze_stock_prices(prices: List[float], threshold: float) -> Dict[float, int]:\n    price_dict = {}\n    for idx, price in enumerate(prices):\n        if price > threshold and price not in price_dict:\n            price_dict[price] = 1\n        elif price > threshold:\n            price_dict[price] += 1\n            \n    return price_dict"
    },
    {
        "function_name": "calculate_fuel_efficiency",
        "file_name": "fuel_efficiency.py",
        "parameters": {
            "distances": "List[float] - A list of distances traveled.",
            "fuel_consumed": "List[float] - A list corresponding to fuel consumed for each distance."
        },
        "objectives": [
            "Calculate the fuel efficiency (miles per gallon) for each entry.",
            "Identify the maximum fuel efficiency from the calculated values.",
            "Return a tuple containing the list of fuel efficiencies and the maximum efficiency."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def calculate_fuel_efficiency(distances: List[float], fuel_consumed: List[float]) -> Tuple[List[float], float]:\n    fuel_efficiencies = []\n    for distance, fuel in zip(distances, fuel_consumed):\n        if fuel == 0:\n            continue  # Avoid division by zero\n        efficiency = distance / fuel\n        fuel_efficiencies.append(efficiency)\n    \n    max_efficiency = max(fuel_efficiencies) if fuel_efficiencies else 0.0\n    \n    return fuel_efficiencies, max_efficiency"
    },
    {
        "function_name": "keyword_analysis",
        "file_name": "text_analysis.py",
        "parameters": {
            "text": "str - A block of text for analysis.",
            "keyword": "str - A target word to find and analyze within the text."
        },
        "objectives": [
            "Count the total occurrences of the specified keyword, disregarding case sensitivity.",
            "Identify the sentences in which the keyword appears.",
            "Return a tuple containing the total count of the keyword and a list of sentences containing it."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def keyword_analysis(text: str, keyword: str) -> Tuple[int, List[str]]:\n    sentences = text.split('.')\n    count = 0\n    sentences_with_keyword = []\n    \n    for sentence in sentences:\n        if keyword.lower() in sentence.lower():\n            count += sentence.lower().count(keyword.lower())\n            sentences_with_keyword.append(sentence.strip())\n    \n    return count, sentences_with_keyword"
    },
    {
        "function_name": "merge_sorted_lists",
        "file_name": "list_merger.py",
        "parameters": {
            "list1": "List[int] - A sorted list of integers.",
            "list2": "List[int] - Another sorted list of integers."
        },
        "objectives": [
            "Merge the two sorted lists into a single sorted list without duplicates.",
            "Implement a two-pointer technique to efficiently merge the lists.",
            "Return the merged sorted list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]:\n    merged_list = []\n    i, j = 0, 0\n        \n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            if list1[i] not in merged_list:\n                merged_list.append(list1[i])\n            i += 1\n        elif list1[i] > list2[j]:\n            if list2[j] not in merged_list:\n                merged_list.append(list2[j])\n            j += 1\n        else:\n            if list1[i] not in merged_list:\n                merged_list.append(list1[i])\n            i += 1\n            j += 1\n            \n    while i < len(list1):\n        if list1[i] not in merged_list:\n            merged_list.append(list1[i])\n        i += 1\n        \n    while j < len(list2):\n        if list2[j] not in merged_list:\n            merged_list.append(list2[j])\n        j += 1\n        \n    return merged_list"
    },
    {
        "function_name": "prim_minimum_spanning_tree",
        "file_name": "minimum_spanning_tree.py",
        "parameters": {
            "graph": "Dict[str, List[Tuple[str, int]]] (An adjacency list representation of a graph where each node is a string and each edge is a tuple of the connected node and the weight of the edge)",
            "source": "str (The source node for the minimum spanning tree)"
        },
        "objectives": [
            "Construct a minimum spanning tree for the given graph using Prim's algorithm.",
            "Handle the case where the graph is not connected by returning the minimum spanning tree for each connected component separately.",
            "Include the weights of the edges in the resulting minimum spanning tree."
        ],
        "import_lines": [
            "from typing import Dict, List, Tuple",
            "from collections import defaultdict"
        ],
        "function_def": "def prim_minimum_spanning_tree(graph, source):\n    # Initialize the minimum spanning tree as an empty graph\n    minimum_spanning_tree = defaultdict(list)\n    \n    # Initialize the set of visited nodes\n    visited = set()\n    \n    # Initialize the priority queue with the source node\n    priority_queue = [(0, source, source)]\n    \n    while priority_queue:\n        # Extract the node with the minimum edge weight from the priority queue\n        weight, node, parent = min(priority_queue)\n        priority_queue.remove((weight, node, parent))\n        \n        # If the node has already been visited, skip it\n        if node in visited:\n            continue\n        \n        # Mark the node as visited\n        visited.add(node)\n        \n        # If the node is not the source node, add the edge to the minimum spanning tree\n        if parent != node:\n            minimum_spanning_tree[parent].append((node, weight))\n            minimum_spanning_tree[node].append((parent, weight))\n        \n        # Add the neighbors of the node to the priority queue\n        for neighbor, edge_weight in graph[node]:\n            if neighbor not in visited:\n                priority_queue.append((edge_weight, neighbor, node))\n    \n    return dict(minimum_spanning_tree)"
    },
    {
        "function_name": "segments_above_threshold",
        "file_name": "segments.py",
        "parameters": {
            "sequence": "List[int] (A list of integers representing a sequence of numbers)",
            "threshold": "int (A threshold value for the sequence)"
        },
        "objectives": [
            "Find all segments in the sequence where the sum of the elements is greater than the threshold.",
            "Return a list of tuples, where each tuple contains the start and end indices of the segment.",
            "Handle the case where the sequence is empty."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def segments_above_threshold(sequence, threshold):\n    # Initialize a list to store the segments\n    segments = []\n    \n    # Initialize the current sum and start index\n    current_sum = 0\n    start = 0\n    \n    # Iterate over the sequence\n    for end, num in enumerate(sequence):\n        # Add the current number to the sum\n        current_sum += num\n        \n        # If the sum is greater than the threshold, add the segment to the list\n        while current_sum > threshold:\n            segments.append((start, end))\n            current_sum -= sequence[start]\n            start += 1\n    \n    return segments"
    },
    {
        "function_name": "largest_strongly_connected_component",
        "file_name": "graph_analyzer.py",
        "parameters": {
            "matrix": "List[List[float]] (A 2D matrix of floating-point numbers)",
            "threshold": "float (The minimum value for a cell to be considered significant)"
        },
        "objectives": [
            "Identify the strongly connected components in the graph represented by the matrix, where each cell represents the weight of an edge between two nodes.",
            "Filter out the components that have a total weight less than the specified threshold.",
            "Return the largest strongly connected component (by total weight) along with its corresponding sub-matrix."
        ],
        "import_lines": [
            "from scipy.sparse import csr_matrix",
            "from scipy.sparse.csgraph import connected_components"
        ],
        "function_def": "def largest_strongly_connected_component(matrix, threshold):\n    graph = csr_matrix(matrix)\n    num_components, labels = connected_components(graph, directed=False, connection='strong')\n    \n    max_component_size = 0\n    max_component_label = -1\n    max_component_matrix = None\n    \n    for label in range(num_components):\n        component_matrix = [row[:] for row, label_i in zip(matrix, labels) if label_i == label]\n        component_weights = [abs(cell) for row in component_matrix for cell in row]\n        total_weight = sum(component_weights)\n        \n        if total_weight > threshold and total_weight > max_component_size:\n            max_component_size = total_weight\n            max_component_label = label\n            max_component_matrix = component_matrix\n    \n    return max_component_label, max_component_matrix"
    },
    {
        "function_name": "min_sum_subset_with_constraint",
        "file_name": "subset_selector.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The number of elements to select)"
        },
        "objectives": [
            "Select k elements from the list such that their sum is minimized.",
            "Ensure that no two selected elements have a difference greater than max_diff.",
            "Return the selected elements along with their sum."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_sum_subset_with_constraint(nums, k, max_diff):\n    nums.sort()\n    selected_elements = []\n    current_sum = 0\n    \n    for num in nums:\n        if len(selected_elements) < k and (not selected_elements or num - selected_elements[-1] <= max_diff):\n            selected_elements.append(num)\n            current_sum += num\n    \n    return selected_elements, current_sum"
    },
    {
        "function_name": "shortest_path_without_cycles",
        "file_name": "path_finder.py",
        "parameters": {
            "graph": "Dict[int, List[int]] (An adjacency list representing a graph)",
            "source": "int (The source node)",
            "destination": "int (The destination node)"
        },
        "objectives": [
            "Find the shortest path between the source and destination nodes in the graph.",
            "Ensure that the path does not traverse any node more than once.",
            "Return the shortest path along with its length."
        ],
        "import_lines": [
            "from collections import deque"
        ],
        "function_def": "def shortest_path_without_cycles(graph, source, destination):\n    queue = deque([(source, [source])])\n    visited = set()\n    \n    while queue:\n        node, path = queue.popleft()\n        if node == destination:\n            return path, len(path)\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                queue.append((neighbor, path + [neighbor]))\n                visited.add(neighbor)\n    \n    return None, float('inf')"
    },
    {
        "function_name": "cluster_numbers_with_threshold",
        "file_name": "cluster_analyzer.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "threshold": "int (The minimum value for a number to be considered significant)"
        },
        "objectives": [
            "Identify the clusters of numbers in the list such that each cluster has a sum greater than or equal to the threshold.",
            "Ensure that each cluster contains at least two numbers.",
            "Return the clusters along with their sums."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def cluster_numbers_with_threshold(nums, threshold):\n    nums.sort()\n    clusters = []\n    current_cluster = []\n    current_sum = 0\n    \n    for num in nums:\n        if current_sum + num >= threshold:\n            current_cluster.append(num)\n            current_sum += num\n            if len(current_cluster) >= 2:\n                clusters.append(current_cluster[:])\n                current_cluster = []\n                current_sum = 0\n        else:\n            current_cluster.append(num)\n            current_sum += num\n    \n    if len(current_cluster) >= 2 and current_sum >= threshold:\n        clusters.append(current_cluster)\n    \n    return clusters, [sum(cluster) for cluster in clusters]"
    },
    {
        "function_name": "submatrix_sum",
        "file_name": "matrix_sum.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "target": "int (The target sum)"
        },
        "objectives": [
            "Find all unique subsets of the matrix that sum up to the target value.",
            "Each subset must be a contiguous submatrix (i.e., all elements in the subset are adjacent to each other).",
            "The function should return a list of these subsets."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def submatrix_sum(matrix: List[List[int]], target: int) -> List[List[List[int]]]:\n    result = []\n    rows, cols = len(matrix), len(matrix[0])\n    \n    for row in range(rows):\n        for col in range(cols):\n            total = 0\n            for i in range(row, rows):\n                for j in range(col, cols):\n                    total += matrix[i][j]\n                    if total == target:\n                        subset = [row[i:rows] for row in matrix[i:j+1]]\n                        result.append(subset)\n    \n    return result"
    },
    {
        "function_name": "keyword_substrings",
        "file_name": "text_analyzer.py",
        "parameters": {
            "text": "str (The input string)",
            "keywords": "List[str] (The list of keywords to search for)",
            "max_distance": "int (The maximum distance between keywords)"
        },
        "objectives": [
            "Find all occurrences of the given keywords in the input string, ignoring case.",
            "For each occurrence of a keyword, check if any other keyword is present within the specified maximum distance.",
            "If multiple keywords are found within the maximum distance, return the shortest substring that contains all the keywords.",
            "Return a list of these substrings."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def keyword_substrings(text: str, keywords: List[str], max_distance: int) -> List[str]:\n    text = text.lower()\n    keywords = [keyword.lower() for keyword in keywords]\n    result = []\n    \n    for keyword in keywords:\n        index = text.find(keyword)\n        while index != -1:\n            left = max(0, index - max_distance)\n            right = min(len(text), index + len(keyword) + max_distance)\n            substring = text[left:right]\n            for other_keyword in keywords:\n                if other_keyword != keyword and other_keyword in substring:\n                    result.append(substring)\n                    break\n            index = text.find(keyword, index + 1)\n    \n    # Remove duplicates and find the shortest substring\n    result = list(set(result))\n    result.sort(key=len)\n    \n    return result"
    },
    {
        "function_name": "close_point_midpoints",
        "file_name": "geometry_calculator.py",
        "parameters": {
            "points": "List[List[int]] (A list of points in 2D space)",
            "distance_threshold": "int (The maximum distance between points)"
        },
        "objectives": [
            "Find all pairs of points that are within the specified distance threshold of each other.",
            "Calculate the midpoint of each pair of points.",
            "Return a list of these midpoints."
        ],
        "import_lines": [
            "from typing import List",
            "import math"
        ],
        "function_def": "def close_point_midpoints(points: List[List[int]], distance_threshold: int) -> List[List[float]]:\n    result = []\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            if distance <= distance_threshold:\n                midpoint = [(points[i][0] + points[j][0]) / 2, (points[i][1] + points[j][1]) / 2]\n                result.append(midpoint)\n    \n    return result"
    },
    {
        "function_name": "max_staircase_height",
        "file_name": "staircase_calculator.py",
        "parameters": {
            "arr": "List[int] - A list of integers representing the heights of blocks.",
            "k": "int - The maximum number of blocks that can be used to build the staircase."
        },
        "objectives": [
            "Implement dynamic programming to find the maximum height of the staircase that can be built using at most `k` blocks.",
            "Ensure that the staircase is constructed in such a way that the width of each step is equal to its height.",
            "Handle cases where the input list is empty or `k` is 0."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_staircase_height(arr: List[int], k: int) -> int:\n    if not arr or k == 0:\n        return 0\n    \n    max_height = [0] * (k + 1)\n    for height in arr:\n        for i in range(k, height - 1, -1):\n            max_height[i] = max(max_height[i], max_height[i - height] + height)\n    \n    return max_height[k]"
    },
    {
        "function_name": "particle_simulation",
        "file_name": "particle_simulator.py",
        "parameters": {
            "coordinates": "List[Tuple[int, int]] - A list of (x, y) coordinates representing the positions of particles.",
            "velocities": "List[Tuple[int, int]] - A list of (vx, vy) velocities corresponding to the particles.",
            "time": "int - The time step to simulate the particles' movement."
        },
        "objectives": [
            "Create a function to simulate the movement of particles based on their velocities and time step.",
            "Ensure that particles do not move out of the bounded region defined by the minimum and maximum x and y coordinates.",
            "Handle edge cases where the input lists are empty or the time step is zero.",
            "Return the updated coordinates of the particles after the simulation."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def particle_simulation(coordinates: List[Tuple[int, int]], velocities: List[Tuple[int, int]], time: int) -> List[Tuple[int, int]]:\n    if not coordinates or not velocities or time <= 0:\n        return coordinates\n    \n    min_x, min_y = min(x for x, y in coordinates), min(y for x, y in coordinates)\n    max_x, max_y = max(x for x, y in coordinates), max(y for x, y in coordinates)\n    \n    updated_coordinates = []\n    for (x, y), (vx, vy) in zip(coordinates, velocities):\n        new_x, new_y = x + vx * time, y + vy * time\n        new_x = max(min_x, min(new_x, max_x))\n        new_y = max(min_y, min(new_y, max_y))\n        updated_coordinates.append((new_x, new_y))\n    \n    return updated_coordinates"
    },
    {
        "function_name": "capacity_balancer",
        "file_name": "network_optimizer.py",
        "parameters": {
            "dni": "List[List[int]] - A list of unique transaction IDs for each node in the graph.",
            "graph": "List[List[int]] - An adjacency list representing the graph structure.",
            "capacity": "int - The maximum capacity of each node in the graph."
        },
        "objectives": [
            "Develop an algorithm to detect and prevent over-capacity conditions in a network of nodes, where each node has a limited capacity.",
            "Identify nodes that are at risk of over-capacity due to the current transaction volume.",
            "Rebalance transactions across the network to minimize the number of over-capacity nodes."
        ],
        "import_lines": [
            "from collections import deque"
        ],
        "function_def": "def capacity_balancer(dni, graph, capacity):\n    queue = deque()\n    node_trans_count = {i: 0 for i in range(len(dni))}\n    \n    for i, node in enumerate(dni):\n        for transaction in node:\n            node_trans_count[i] += 1\n            if node_trans_count[i] > capacity:\n                queue.append(i)\n    \n    while queue:\n        node = queue.popleft()\n        neighbors = graph[node]\n        for neighbor in neighbors:\n            if node_trans_count[neighbor] < capacity:\n                trans_to_rebalance = min(node_trans_count[node] - capacity, capacity - node_trans_count[neighbor])\n                node_trans_count[node] -= trans_to_rebalance\n                node_trans_count[neighbor] += trans_to_rebalance\n                if node_trans_count[node] <= capacity:\n                    break\n    \n    at_risk_nodes = [node for node, count in node_trans_count.items() if count > capacity]\n    return at_risk_nodes"
    },
    {
        "function_name": "first_pair_sum",
        "file_name": "pair_sum.py",
        "parameters": {
            "nums": "List[int]",
            "target": "int"
        },
        "objectives": [
            "Find the first pair of elements in the list that sum up to the target value.",
            "If no such pair exists, return -1.",
            "Implement a function that maintains a time complexity of O(n) by using a hash set."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def first_pair_sum(nums: List[int], target: int) -> int:\n    num_set = set()\n    for num in nums:\n        if target - num in num_set:\n            return 1\n        num_set.add(num)\n    return -1"
    },
    {
        "function_name": "kth_smallest_element",
        "file_name": "matrix_element.py",
        "parameters": {
            "matrix": "List[List[int]]",
            "k": "int"
        },
        "objectives": [
            "Find the kth smallest element in the given 2D matrix.",
            "The matrix can be non-square and the elements can be unsorted.",
            "Implement a function that maintains a time complexity of O(k log n), where n is the total number of elements in the matrix."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def kth_smallest_element(matrix: List[List[int]], k: int) -> int:\n    min_heap = []\n    for row in matrix:\n        for num in row:\n            heapq.heappush(min_heap, num)\n    for _ in range(k):\n        smallest = heapq.heappop(min_heap)\n    return smallest"
    },
    {
        "function_name": "calculate_hamming_distance",
        "file_name": "binary_string_analyzer.py",
        "parameters": {
            "strings": "List[str] (List of binary strings)",
            "threshold": "int (The minimum number of strings to have the same bit at a given position)",
            "positions": "List[int] (List of positions to check)"
        },
        "objectives": [
            "Filter the input list of binary strings to only include strings that have at least a certain number of '1's at specified positions.",
            "Calculate the hamming distance between each pair of filtered strings.",
            "Return a dictionary containing the filtered strings, their corresponding hamming distances, and the average hamming distance."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import itertools"
        ],
        "function_def": "def calculate_hamming_distance(strings: List[str], threshold: int, positions: List[int]) -> Dict[str, object]:\n    filtered_strings = [string for string in strings if sum(string[position] == '1' for position in positions) >= threshold]\n    hamming_distances = {}\n    total_distance = 0\n    \n    for pair in itertools.combinations(filtered_strings, 2):\n        distance = sum(el1 != el2 for el1, el2 in zip(pair[0], pair[1]))\n        hamming_distances[pair] = distance\n        total_distance += distance\n    \n    average_distance = total_distance / len(hamming_distances) if hamming_distances else 0\n    return {\"filtered_strings\": filtered_strings, \"hamming_distances\": hamming_distances, \"average_distance\": average_distance}"
    },
    {
        "function_name": "k_means_clustering",
        "file_name": "clustering_algorithm.py",
        "parameters": {
            "points": "List[Tuple[int, int]] (List of 2D points)",
            "k": "int (The number of clusters)"
        },
        "objectives": [
            "Implement the k-means clustering algorithm to group the input points into k clusters.",
            "Calculate the centroid of each cluster after the clustering process.",
            "Return a dictionary containing the points assigned to each cluster and their respective centroids."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict",
            "import random",
            "import math"
        ],
        "function_def": "def k_means_clustering(points: List[Tuple[int, int]], k: int) -> Dict[int, Dict[str, object]]:\n    clusters = {i: [] for i in range(k)}\n    centroids = [(random.choice(points)) for _ in range(k)]\n    \n    while True:\n        for point in points:\n            min_distance = float('inf')\n            assigned_cluster = None\n            \n            for i, centroid in enumerate(centroids):\n                distance = math.sqrt((point[0] - centroid[0]) ** 2 + (point[1] - centroid[1]) ** 2)\n                if distance < min_distance:\n                    min_distance = distance\n                    assigned_cluster = i\n            clusters[assigned_cluster].append(point)\n        \n        new_centroids = []\n        for cluster in clusters.values():\n            x_coords = [point[0] for point in cluster]\n            y_coords = [point[1] for point in cluster]\n            new_centroid = (sum(x_coords) / len(cluster), sum(y_coords) / len(cluster))\n            new_centroids.append(new_centroid)\n        \n        if new_centroids == centroids:\n            break\n        \n        centroids = new_centroids\n        clusters = {i: [] for i in range(k)}\n    \n    result = {i: {\"points\": cluster, \"centroid\": centroid} for i, (cluster, centroid) in enumerate(zip(clusters.values(), centroids))}\n    return result"
    },
    {
        "function_name": "evaluate_expression",
        "file_name": "expression_evaluator.py",
        "parameters": {
            "expression": "str (A mathematical expression)",
            "variables": "Dict[str, float] (A dictionary of variable names and their corresponding values)"
        },
        "objectives": [
            "Parse the input mathematical expression to handle variables and constants.",
            "Evaluate the expression using the provided variable values.",
            "Return the evaluated result and a dictionary containing the variables used in the expression and their values."
        ],
        "import_lines": [
            "from typing import Dict",
            "import re"
        ],
        "function_def": "def evaluate_expression(expression: str, variables: Dict[str, float]) -> Dict[str, object]:\n    used_variables = {}\n    for variable, value in variables.items():\n        if re.search(r'\\b' + variable + r'\\b', expression):\n            used_variables[variable] = value\n            expression = expression.replace(variable, str(value))\n    \n    try:\n        result = eval(expression)\n    except Exception as e:\n        return {\"error\": str(e)}\n    \n    return {\"result\": result, \"used_variables\": used_variables}"
    },
    {
        "function_name": "dfs_traversal",
        "file_name": "matrix_traverser.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix)",
            "row": "int (The row index to start from)",
            "col": "int (The column index to start from)"
        },
        "objectives": [
            "Perform a depth-first search (DFS) traversal of the matrix starting from the given row and column.",
            "Return a set containing all the visited elements and a dictionary containing the parent of each element."
        ],
        "import_lines": [
            "from typing import List, Dict, Set"
        ],
        "function_def": "def dfs_traversal(matrix: List[List[int]], row: int, col: int) -> Dict[str, object]:\n    visited = set()\n    parent = {}\n    stack = [(row, col, None)]\n    \n    while stack:\n        current_row, current_col, parent_node = stack.pop()\n        \n        if (current_row, current_col) not in visited:\n            visited.add((current_row, current_col))\n            parent[(current_row, current_col)] = parent_node\n            \n            for neighbor_row, neighbor_col in [(current_row - 1, current_col), (current_row + 1, current_col), (current_row, current_col - 1), (current_row, current_col + 1)]:\n                if 0 <= neighbor_row < len(matrix) and 0 <= neighbor_col < len(matrix[0]):\n                    stack.append((neighbor_row, neighbor_col, (current_row, current_col)))\n    \n    return {\"visited\": visited, \"parent\": parent}"
    },
    {
        "function_name": "highlight_exceeding_elements",
        "file_name": "matrix_highlighter.py",
        "parameters": {
            "matrix": "List[List[float]] - A 2D list of floats representing the input matrix.",
            "threshold": "float - The target threshold to filter the matrix."
        },
        "objectives": [
            "Normalize the input matrix by scaling all its elements to the range [0, 1].",
            "Identify the positions (row, column) of all elements in the normalized matrix that exceed the specified threshold.",
            "Return a list of tuples, where each tuple contains the row index, column index, and normalized value of the element that exceeds the threshold."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def highlight_exceeding_elements(matrix: List[List[float]], threshold: float) -> List[Tuple[int, int, float]]:\n    min_value = min(min(row) for row in matrix)\n    max_value = max(max(row) for row in matrix)\n    normalized_matrix = [[(value - min_value) / (max_value - min_value) if max_value != min_value else 0 for value in row] for row in matrix]\n    exceeding_elements = [(i, j, value) for i, row in enumerate(normalized_matrix) for j, value in enumerate(row) if value > threshold]\n    \n    return exceeding_elements"
    },
    {
        "function_name": "subset_sum_dynamic",
        "file_name": "subset_sum.py",
        "parameters": {
            "numbers": "List[int] - A list of integers representing the input numbers.",
            "target_sum": "int - The target sum to find a subset of numbers that adds up to."
        },
        "objectives": [
            "Implement the dynamic programming algorithm to find a subset of numbers that adds up to the target sum.",
            "Ensure the algorithm uses a 2D table to store the intermediate results.",
            "Return a boolean value indicating whether a subset was found that adds up to the target sum."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def subset_sum_dynamic(numbers: List[int], target_sum: int) -> bool:\n    n = len(numbers)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if numbers[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - numbers[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[n][target_sum]"
    },
    {
        "function_name": "points_in_sphere",
        "file_name": "geometry_calculator.py",
        "parameters": {
            "points": "List[List[float]] (A list of points in 3D space)",
            "center": "List[float] (The center of the sphere)",
            "radius": "float (The radius of the sphere)"
        },
        "objectives": [
            "Calculate the distance between each point and the center of the sphere.",
            "Check if each point is within the sphere (i.e., the distance is less than or equal to the radius).",
            "Use the NumPy library to perform vectorized calculations.",
            "Return a list of boolean values indicating whether each point is within the sphere."
        ],
        "import_lines": [
            "import numpy as np",
            "from typing import List"
        ],
        "function_def": "def points_in_sphere(points: List[List[float]], center: List[float], radius: float) -> List[bool]:\n    center_array = np.array(center)\n    points_array = np.array(points)\n    distances = np.linalg.norm(points_array - center_array, axis=1)\n    return distances <= radius"
    },
    {
        "function_name": "is_palindrome",
        "file_name": "palindrome_checker.py",
        "parameters": {
            "s": "str - The input string."
        },
        "objectives": [
            "Implement a function to check if the input string is a palindrome.",
            "Use a two-pointer approach to efficiently compare characters from both ends of the string.",
            "Handle cases where the input string is empty or contains only one character."
        ],
        "import_lines": [],
        "function_def": "def is_palindrome(s: str) -> bool:\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True"
    },
    {
        "function_name": "interval_coverage",
        "file_name": "interval_utilities.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] - A list of intervals where each interval is represented as a tuple of two integers.",
            "n": "int - The number of random intervals to generate.",
            "max_val": "int - The maximum value for the randomly generated intervals."
        },
        "objectives": [
            "Generate 'n' random intervals within the range [0, max_val] and add them to the existing list of intervals.",
            "Merge all overlapping intervals in the updated list.",
            "Check if the merged intervals cover the entire range [0, max_val].",
            "Return a boolean indicating whether the range is fully covered."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import random"
        ],
        "function_def": "def interval_coverage(intervals: List[Tuple[int, int]], n: int, max_val: int) -> bool:\n    # Generate random intervals\n    for _ in range(n):\n        start = random.randint(0, max_val)\n        end = random.randint(start, max_val)\n        intervals.append((start, end))\n    \n    # Merge overlapping intervals\n    intervals.sort(key=lambda x: x[0])\n    merged_intervals = [intervals[0]]\n    for current_interval in intervals[1:]:\n        last_merged_interval = merged_intervals[-1]\n        if current_interval[0] <= last_merged_interval[1]:\n            merged_intervals[-1] = (last_merged_interval[0], max(last_merged_interval[1], current_interval[1]))\n        else:\n            merged_intervals.append(current_interval)\n    \n    # Check if the merged intervals cover the entire range [0, max_val]\n    return merged_intervals[0][0] == 0 and merged_intervals[-1][1] == max_val"
    },
    {
        "function_name": "dfs_maze_solver",
        "file_name": "maze_solver.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid of integers representing a maze.",
            "start": "Tuple[int, int] - The starting coordinates in the maze."
        },
        "objectives": [
            "Find the shortest path from the start to all other reachable cells in the maze using a depth-first search (DFS) approach.",
            "Mark all visited cells in the maze with a special value (-1).",
            "Return the updated maze with the visited cells marked."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def dfs_maze_solver(grid: List[List[int]], start: Tuple[int, int]) -> List[List[int]]:\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    stack = [start]\n    grid[start[0]][start[1]] = -1  # Mark start as visited\n    \n    while stack:\n        row, col = stack.pop()\n        \n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != -1 and grid[new_row][new_col] != 1:\n                grid[new_row][new_col] = -1  # Mark as visited\n                stack.append((new_row, new_col))\n    \n    return grid"
    },
    {
        "function_name": "max_distinct_subarray",
        "file_name": "bit_stream_processor.py",
        "parameters": {
            "nums": "List[int] - A list of integers representing a bit stream.",
            "k": "int - The window size."
        },
        "objectives": [
            "Find the longest subarray within any window of size 'k' that contains a set of distinct bits (0s and 1s).",
            "Use a sliding window approach to efficiently traverse the bit stream.",
            "Return the maximum length of the subarray with distinct bits."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def max_distinct_subarray(nums: List[int], k: int) -> int:\n    if not nums or k == 0:\n        return 0\n    \n    window_counts = defaultdict(int)\n    left = 0\n    max_len = 0\n    distinct_bits = 0\n    \n    for right in range(len(nums)):\n        window_counts[nums[right]] += 1\n        if window_counts[nums[right]] == 1:\n            distinct_bits += 1\n        \n        while distinct_bits > 2 or right - left + 1 > k:\n            window_counts[nums[left]] -= 1\n            if window_counts[nums[left]] == 0:\n                distinct_bits -= 1\n            left += 1\n        \n        max_len = max(max_len, right - left + 1)\n    \n    return max_len if distinct_bits == 2 else 0"
    },
    {
        "function_name": "find_substrings",
        "file_name": "substring_finder.py",
        "parameters": {
            "text": "str (The input text)",
            "max_length": "int (The maximum length of substrings)"
        },
        "objectives": [
            "Find all unique substrings in the input text within the specified maximum length.",
            "Use a sliding window approach to efficiently generate substrings.",
            "Handle cases with repeating characters by storing unique substrings in a set.",
            "Return a list of unique substrings in a sorted manner."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_substrings(text: str, max_length: int) -> List[str]:\n    substrings = set()\n    \n    for length in range(1, max_length + 1):\n        for start in range(len(text) - length + 1):\n            substrings.add(text[start:start + length])\n    \n    return sorted(list(substrings))"
    },
    {
        "function_name": "select_max_sum",
        "file_name": "selector.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The number of elements to select)"
        },
        "objectives": [
            "Implement a greedy algorithm to select k elements from the list that have the maximum sum.",
            "Sort the list in descending order to prioritize larger numbers.",
            "Handle cases where k is larger than the list length by selecting all elements.",
            "Return the selected elements along with their sum."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def select_max_sum(nums: List[int], k: int) -> List[int]:\n    nums.sort(reverse=True)\n    \n    selected = nums[:k]\n    \n    return selected"
    },
    {
        "function_name": "sub_matrix_sum",
        "file_name": "matrix_processor.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid of integers representing a matrix.",
            "target": "int - The target sum to be found in the grid.",
            "window_size": "int - The size of the window to consider."
        },
        "objectives": [
            "Find all sub-matrices of size 'window_size' within the grid where the sum of the elements is equal to 'target'.",
            "Ensure efficient calculation by reusing the sum from the previous window rather than recalculating it from scratch.",
            "Handle edge cases where the window exceeds the number of available elements in the grid."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def sub_matrix_sum(grid: List[List[int]], target: int, window_size: int) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    if not grid or window_size <= 0:\n        return []\n    \n    result = []\n    row_sum = [0] * len(grid[0])\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if j >= window_size:\n                row_sum[j] -= grid[i][j - window_size]\n            row_sum[j] += grid[i][j]\n        \n        if i >= window_size - 1:\n            for j in range(len(grid[0]) - window_size + 1):\n                window_sum = 0\n                for k in range(window_size):\n                    window_sum += row_sum[j + k]\n                if window_sum == target:\n                    result.append(((i - window_size + 1, j), (i, j + window_size - 1)))\n    \n    return result"
    },
    {
        "function_name": "disjoint_segments",
        "file_name": "segments.py",
        "parameters": {
            "sequence": "List[int] - A list of integers representing a sequence of numbers.",
            "threshold": "int - A threshold value for the sequence."
        },
        "objectives": [
            "Find all segments in the sequence where the sum of the elements is greater than the threshold.",
            "Ensure that each segment is non-empty and does not overlap with other segments.",
            "Return a list of tuples, where each tuple contains the start and end indices of the segment."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def disjoint_segments(sequence: List[int], threshold: int) -> List[Tuple[int, int]]:\n    # Initialize a list to store the segments\n    segments = []\n    \n    # Initialize the current sum and start index\n    current_sum = 0\n    start = 0\n    \n    # Iterate over the sequence\n    for end, num in enumerate(sequence):\n        # Add the current number to the sum\n        current_sum += num\n        \n        # If the sum is greater than the threshold, add the segment to the list\n        if current_sum > threshold:\n            segments.append((start, end))\n            current_sum = 0\n            start = end + 1\n    \n    return segments"
    },
    {
        "function_name": "generate_substrings",
        "file_name": "substring_generator.py",
        "parameters": {
            "text": "str",
            "min_length": "int",
            "max_length": "int"
        },
        "objectives": [
            "Implement a function that generates all possible substrings of a given text within a specified length range.",
            "The function should be case-insensitive and ignore special characters.",
            "The substrings should be returned in lexicographical order."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def generate_substrings(text: str, min_length: int, max_length: int) -> List[str]:\n    text = ''.join(filter(str.isalnum, text)).lower()\n    substrings = set()\n    for length in range(min_length, max_length + 1):\n        for i in range(len(text) - length + 1):\n            substrings.add(text[i:i + length])\n    return sorted(list(substrings))"
    },
    {
        "function_name": "sieve_of_eratosthenes",
        "file_name": "prime_numbers.py",
        "parameters": {
            "nums": "List[int]"
        },
        "objectives": [
            "Implement a function that uses the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit.",
            "The function should return a list of prime numbers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def sieve_of_eratosthenes(nums: List[int]) -> List[int]:\n    limit = max(nums)\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(limit ** 0.5) + 1):\n        if sieve[i]:\n            for j in range(i * i, limit + 1, i):\n                sieve[j] = False\n    return [num for num in nums if sieve[num]]"
    },
    {
        "function_name": "max_water_trapped",
        "file_name": "histogram_algorithms.py",
        "parameters": {
            "array": "List[int] (A list of integers representing the heights of bars in a histogram)",
            "width": "int (The width of each bar in the histogram)"
        },
        "objectives": [
            "Implement a function that calculates the maximum water that can be trapped between bars in the histogram.",
            "The function should handle the case where the histogram has only one bar or no bars at all.",
            "Use a two-pointer technique for efficient computation."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_water_trapped(array: List[int], width: int) -> int:\n    if len(array) < 2:\n        return 0\n    left = 0\n    right = len(array) - 1\n    max_water = 0\n    \n    while left < right:\n        min_height = min(array[left], array[right])\n        max_water = max(max_water, min_height * (right - left - 1) * width)\n        if array[left] < array[right]:\n            left += 1\n        else:\n            right -= 1\n            \n    return max_water"
    },
    {
        "function_name": "compress_strings",
        "file_name": "compression_algorithms.py",
        "parameters": {
            "strings": "List[str] (A list of strings to be compressed)"
        },
        "objectives": [
            "Implement a function that compresses a list of strings using Run-Length Encoding (RLE).",
            "The function should ignore repeated strings with less than 2 occurrences.",
            "The function should handle empty strings and strings with only one unique character."
        ],
        "import_lines": [
            "from typing import List",
            "from itertools import groupby"
        ],
        "function_def": "def compress_strings(strings: List[str]) -> List[str]:\n    compressed = []\n    \n    for string in strings:\n        encoded_string = \"\"\n        for char, group in groupby(string):\n            count = len(list(group))\n            if count < 2:\n                encoded_string += char\n            else:\n                encoded_string += f\"{char}{count}\"\n        compressed.append(encoded_string)\n        \n    return compressed"
    },
    {
        "function_name": "image_binarization",
        "file_name": "image_processing.py",
        "parameters": {
            "image": "List[List[int]] (A 2D matrix representing the image)",
            "threshold": "int (The threshold value for image binarization)"
        },
        "objectives": [
            "Implement a binarization algorithm to convert the grayscale image into a binary image.",
            "Use the given threshold value to determine whether a pixel is black (0) or white (255).",
            "Return the binarized image."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def image_binarization(image: List[List[int]], threshold: int) -> List[List[int]]:\n    binarized_image = []\n    for row in image:\n        binarized_row = []\n        for pixel in row:\n            binarized_pixel = 0 if pixel < threshold else 255\n            binarized_row.append(binarized_pixel)\n        binarized_image.append(binarized_row)\n    return binarized_image"
    },
    {
        "function_name": "kmeans_clustering",
        "file_name": "clustering.py",
        "parameters": {
            "data": "List[List[float]] (A 2D list of float values representing the data points)",
            "k": "int (The number of clusters to identify)"
        },
        "objectives": [
            "Implement the K-Means clustering algorithm to group similar data points into clusters.",
            "Initialize centroids randomly and update them iteratively based on the mean of assigned data points.",
            "Return the cluster assignments for each data point."
        ],
        "import_lines": [
            "import random",
            "from typing import List"
        ],
        "function_def": "def kmeans_clustering(data: List[List[float]], k: int) -> List[int]:\n    centroids = random.sample(data, k)\n    cluster_assignments = [0] * len(data)\n    \n    while True:\n        new_cluster_assignments = []\n        for i, point in enumerate(data):\n            min_distance = float('inf')\n            cluster_index = 0\n            for j, centroid in enumerate(centroids):\n                distance = sum((a - b) ** 2 for a, b in zip(point, centroid))\n                if distance < min_distance:\n                    min_distance = distance\n                    cluster_index = j\n            new_cluster_assignments.append(cluster_index)\n        \n        if new_cluster_assignments == cluster_assignments:\n            break\n        \n        cluster_assignments = new_cluster_assignments\n        \n        for i in range(k):\n            points_in_cluster = [point for j, point in enumerate(data) if cluster_assignments[j] == i]\n            if points_in_cluster:\n                centroids[i] = [sum(x) / len(points_in_cluster) for x in zip(*points_in_cluster)]\n    \n    return cluster_assignments"
    },
    {
        "function_name": "ngram_extraction",
        "file_name": "nlp_utils.py",
        "parameters": {
            "text": "str (The input text to be analyzed)",
            "ngrams": "int (The size of the n-grams to extract)"
        },
        "objectives": [
            "Implement a function to extract n-grams from the given text.",
            "Split the text into words and pad the beginning and end of the text with a special token to handle edge cases.",
            "Return a list of extracted n-grams."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def ngram_extraction(text: str, ngrams: int) -> List[List[str]]:\n    words = text.split()\n    padded_words = ['<SOS>'] * (ngrams - 1) + words + ['<EOS>'] * (ngrams - 1)\n    \n    ngrams_list = []\n    for i in range(len(padded_words) - ngrams + 1):\n        ngram = padded_words[i:i + ngrams]\n        ngrams_list.append(ngram)\n    \n    return ngrams_list"
    },
    {
        "function_name": "apriori_algorithm",
        "file_name": "association_mining.py",
        "parameters": {
            "transaction_data": "List[List[int]] (A list of transactions where each transaction is a list of item IDs)",
            "min_support": "float (The minimum support threshold for frequent itemsets)"
        },
        "objectives": [
            "Implement the Apriori algorithm to find frequent itemsets in the transaction data.",
            "Generate candidate itemsets iteratively based on the minimum support threshold.",
            "Return a list of frequent itemsets."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def apriori_algorithm(transaction_data: List[List[int]], min_support: float) -> List[List[int]]:\n    item_counts = defaultdict(int)\n    for transaction in transaction_data:\n        for item in transaction:\n            item_counts[item] += 1\n    \n    frequent_items = [item for item, count in item_counts.items() if count / len(transaction_data) >= min_support]\n    \n    frequent_itemsets = []\n    frequent_itemsets.append([item] for item in frequent_items)\n    \n    k = 2\n    while True:\n        candidate_itemsets = []\n        for i in range(len(frequent_itemsets)):\n            for j in range(i + 1, len(frequent_itemsets)):\n                candidate_itemset = set(frequent_itemsets[i]).union(set(frequent_itemsets[j]))\n                if len(candidate_itemset) == k:\n                    candidate_itemsets.append(list(candidate_itemset))\n        \n        if not candidate_itemsets:\n            break\n        \n        itemset_counts = defaultdict(int)\n        for transaction in transaction_data:\n            for candidate_itemset in candidate_itemsets:\n                if set(candidate_itemset).issubset(set(transaction)):\n                    itemset_counts[tuple(candidate_itemset)] += 1\n        \n        frequent_itemsets = [list(itemset) for itemset, count in itemset_counts.items() if count / len(transaction_data) >= min_support]\n        \n        k += 1\n    \n    return frequent_itemsets"
    },
    {
        "function_name": "markov_predictor",
        "file_name": "markov_predictor.py",
        "parameters": {
            "sequence": "List[int] (A list of integers representing a sequence of numbers)",
            "k": "int (The number of previous elements to consider for prediction)"
        },
        "objectives": [
            "Use the given sequence to train a Markov model for predicting the next element.",
            "Calculate the transition probabilities between elements.",
            "Use the trained model to predict the next K elements in the sequence."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict",
            "import random"
        ],
        "function_def": "def markov_predictor(sequence: List[int], k: int) -> List[int]:\n    # Calculate transition probabilities\n    transition_probabilities = defaultdict(dict)\n    for i in range(len(sequence) - 1):\n        current = sequence[i]\n        next = sequence[i + 1]\n        if next not in transition_probabilities[current]:\n            transition_probabilities[current][next] = 0\n        transition_probabilities[current][next] += 1\n    \n    for current in transition_probabilities:\n        total = sum(transition_probabilities[current].values())\n        for next in transition_probabilities[current]:\n            transition_probabilities[current][next] /= total\n    \n    # Predict next K elements\n    predictions = []\n    current = sequence[-1]\n    for _ in range(k):\n        next = random.choices(list(transition_probabilities[current].keys()), weights=list(transition_probabilities[current].values()))[0]\n        predictions.append(next)\n        current = next\n    \n    return predictions"
    },
    {
        "function_name": "partition_numbers",
        "file_name": "partitioner.py",
        "parameters": {
            "numbers": "List[int] (A list of integers to partition)",
            "k": "int (The number of partitions)"
        },
        "objectives": [
            "Partition the given list of numbers into K non-empty partitions such that the sum of the elements in each partition is as close to equal as possible.",
            "Use a greedy approach to assign elements to partitions.",
            "Return a list of partitions, where each partition is a list of numbers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def partition_numbers(numbers: List[int], k: int) -> List[List[int]]:\n    partitions = [[] for _ in range(k)]\n    sums = [0] * k\n    \n    for num in numbers:\n        min_sum_index = sums.index(min(sums))\n        partitions[min_sum_index].append(num)\n        sums[min_sum_index] += num\n    \n    return partitions"
    },
    {
        "function_name": "analyze_strings",
        "file_name": "string_analyzer.py",
        "parameters": {
            "strings": "List[str] (A list of strings to analyze)",
            "substring": "str (The substring to find in the strings)"
        },
        "objectives": [
            "Find the strings that contain the given substring and filter them out.",
            "Calculate the frequency of each character in the filtered strings and the remaining strings.",
            "Return a dictionary with the frequency of each character for both filtered and remaining strings."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from collections import Counter"
        ],
        "function_def": "def analyze_strings(strings: List[str], substring: str) -> Dict[str, Dict[str, int]]:\n    filtered_strings = [string for string in strings if substring in string]\n    remaining_strings = [string for string in strings if substring not in string]\n    \n    filtered_frequency = Counter(''.join(filtered_strings))\n    remaining_frequency = Counter(''.join(remaining_strings))\n    \n    return {\"filtered_frequency\": dict(filtered_frequency), \"remaining_frequency\": dict(remaining_frequency)}"
    },
    {
        "function_name": "floyd_cycle_detection",
        "file_name": "cycle_detection.py",
        "parameters": {
            "numbers": "List[float] (A list of floating-point numbers)",
            "precision": "int (The desired precision for the result)"
        },
        "objectives": [
            "Implement the Floyd's cycle-finding algorithm to detect floating-point cycles.",
            "Use a tortoise and hare approach to find the cycle.",
            "Handle cases where there are no cycles or the cycle is of length 1.",
            "Return a tuple containing a boolean indicating the presence of a cycle and the length of the cycle."
        ],
        "import_lines": [],
        "function_def": "def floyd_cycle_detection(numbers, precision):\n    tortoise = numbers[0]\n    hare = numbers[0]\n    \n    while True:\n        tortoise = numbers[int(tortoise * precision) % len(numbers)]\n        hare = numbers[int(numbers[int(hare * precision) % len(numbers)] * precision) % len(numbers)]\n        \n        if abs(tortoise - hare) < 1e-6:\n            break\n    \n    ptr1 = numbers[0]\n    ptr2 = tortoise\n    \n    while abs(ptr1 - ptr2) >= 1e-6:\n        ptr1 = numbers[int(ptr1 * precision) % len(numbers)]\n        ptr2 = numbers[int(ptr2 * precision) % len(numbers)]\n    \n    cycle_length = 1\n    ptr2 = numbers[int(ptr2 * precision) % len(numbers)]\n    \n    while abs(ptr1 - ptr2) >= 1e-6:\n        ptr2 = numbers[int(ptr2 * precision) % len(numbers)]\n        cycle_length += 1\n    \n    return (cycle_length > 1, cycle_length)"
    },
    {
        "function_name": "rearrange_array",
        "file_name": "array_rearranger.py",
        "parameters": {
            "arr": "List[int]",
            "k": "int",
            "val": "int"
        },
        "objectives": [
            "Create a function to rearrange the elements in the given array such that all elements less than the specified value are at the left side, all elements equal to the value are in the middle, and all elements greater than the value are at the right side.",
            "Ensure the relative order of elements within each group is maintained.",
            "The rearrangement should be done in a way that minimizes the number of swaps required."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def rearrange_array(arr: List[int], k: int, val: int) -> List[int]:\n    left, mid, right = 0, 0, len(arr) - 1\n    \n    while mid <= right:\n        if arr[mid] < val:\n            arr[left], arr[mid] = arr[mid], arr[left]\n            left += 1\n            mid += 1\n        elif arr[mid] > val:\n            arr[mid], arr[right] = arr[right], arr[mid]\n            right -= 1\n        else:\n            mid += 1\n    \n    return arr"
    },
    {
        "function_name": "shortest_path_with_visits",
        "file_name": "graph_traversal.py",
        "parameters": {
            "graph": "Dict[int, List[int]]",
            "start_node": "int",
            "end_node": "int",
            "max_visits": "int"
        },
        "objectives": [
            "Develop a function to find the shortest path in a graph from a start node to an end node, with a constraint on the maximum number of visits to any node.",
            "The path should be represented as a list of nodes in the order they are visited.",
            "If no path is found within the maximum number of visits, return an empty list."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import deque"
        ],
        "function_def": "def shortest_path_with_visits(graph: Dict[int, List[int]], start_node: int, end_node: int, max_visits: int) -> List[int]:\n    queue = deque([(start_node, [start_node], {start_node: 1})])\n    min_path = []\n    \n    while queue:\n        node, path, visits = queue.popleft()\n        \n        if node == end_node:\n            min_path = path\n            break\n        \n        for neighbor in graph[node]:\n            if neighbor not in visits or visits[neighbor] < max_visits:\n                new_visits = visits.copy()\n                new_visits[neighbor] = new_visits.get(neighbor, 0) + 1\n                new_path = path + [neighbor]\n                queue.append((neighbor, new_path, new_visits))\n    \n    return min_path"
    },
    {
        "function_name": "update_matrix",
        "file_name": "matrix_updater.py",
        "parameters": {
            "mat": "List[List[int]]",
            "row": "int",
            "col": "int",
            "val": "int"
        },
        "objectives": [
            "Design a function to update the specified row and column in a matrix with the given value, following these rules:",
            "If the element at the specified position is already the given value, no update is made.",
            "If the element at the specified position is not the given value, the element is updated to the given value, and all other elements in the same row and column are updated to zero.",
            "Return the updated matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def update_matrix(mat: List[List[int]], row: int, col: int, val: int) -> List[List[int]]:\n    if mat[row][col] == val:\n        return mat\n    \n    mat[row][col] = val\n    for j in range(len(mat[0])):\n        if j != col:\n            mat[row][j] = 0\n    for i in range(len(mat)):\n        if i != row:\n            mat[i][col] = 0\n    \n    return mat"
    },
    {
        "function_name": "find_pairs",
        "file_name": "pair_finder.py",
        "parameters": {
            "nums": "List[int]",
            "k1": "int",
            "k2": "int"
        },
        "objectives": [
            "Write a function to find all pairs of elements in the list that meet the following conditions:",
            "The absolute difference between the two elements is less than or equal to k1.",
            "The sum of the two elements is less than or equal to k2.",
            "Return a list of pairs satisfying the conditions."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_pairs(nums: List[int], k1: int, k2: int) -> List[List[int]]:\n    nums.sort()\n    result = []\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        if abs(nums[left] - nums[right]) <= k1 and nums[left] + nums[right] <= k2:\n            result.append([nums[left], nums[right]])\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] > k2 or abs(nums[left] - nums[right]) > k1:\n            right -= 1\n        else:\n            left += 1\n    \n    return result"
    },
    {
        "function_name": "longest_subsequences_with_target_sum",
        "file_name": "sequence_sum.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences of integers.",
            "min_length": "int - The minimum length of sequences to consider.",
            "target_sum": "int - The target sum to find in the sequences."
        },
        "objectives": [
            "Identify all sequences that meet the minimum length requirement.",
            "For each sequence, find the longest subsequence that sums up to the target sum.",
            "Return the longest subsequences from all sequences."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_subsequences_with_target_sum(sequences: List[List[int]], min_length: int, target_sum: int) -> List[List[int]]:\n    result = []\n    \n    for sequence in sequences:\n        if len(sequence) >= min_length:\n            longest_subsequence = []\n            current_sum = 0\n            \n            for i in range(len(sequence)):\n                current_sum = 0\n                subsequence = []\n                \n                for j in range(i, len(sequence)):\n                    current_sum += sequence[j]\n                    subsequence.append(sequence[j])\n                    \n                    if current_sum == target_sum and len(subsequence) > len(longest_subsequence):\n                        longest_subsequence = subsequence\n            \n            if longest_subsequence:\n                result.append(longest_subsequence)\n    \n    return result"
    },
    {
        "function_name": "intervals_containing_points",
        "file_name": "interval_points.py",
        "parameters": {
            "intervals": "List[List[int]] - A list of intervals where each interval is a list of two integers representing the start and end points.",
            "points": "List[int] - A list of points."
        },
        "objectives": [
            "For each point, find all intervals that the point lies within.",
            "Return a dictionary where the keys are the points and the values are lists of intervals that the point lies within."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def intervals_containing_points(intervals: List[List[int]], points: List[int]) -> Dict[int, List[List[int]]]:\n    result = {}\n    \n    for point in points:\n        containing_intervals = []\n        \n        for interval in intervals:\n            if interval[0] <= point <= interval[1]:\n                containing_intervals.append(interval)\n        \n        result[point] = containing_intervals\n    \n    return result"
    },
    {
        "function_name": "first_occurrence_binary_search",
        "file_name": "binary_search.py",
        "parameters": {
            "array": "List[int] (A sorted array of integers)",
            "value": "int (The value to search for)"
        },
        "objectives": [
            "Find the first occurrence of the given value in the array.",
            "Implement a function that uses binary search to efficiently find the first occurrence.",
            "Return the index of the first occurrence if found, otherwise return -1."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def first_occurrence_binary_search(array: List[int], value: int) -> int:\n    low, high = 0, len(array) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if array[mid] < value:\n            low = mid + 1\n        elif array[mid] > value:\n            high = mid - 1\n        else:\n            if mid == 0 or array[mid - 1] != value:\n                return mid\n            high = mid - 1\n    \n    return -1"
    },
    {
        "function_name": "longest_contiguous_subsequence",
        "file_name": "sequence_analyzer.py",
        "parameters": {
            "sequence": "List[int] (A list of integers representing a sequence)",
            "length": "int (The length of the subsequence to be found)"
        },
        "objectives": [
            "Find the longest contiguous subsequence in the given sequence that has the maximum sum.",
            "The subsequence should be at least 'length' long.",
            "Return the longest contiguous subsequence as a list of integers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_contiguous_subsequence(sequence: List[int], length: int) -> List[int]:\n    max_sum = float('-inf')\n    max_subsequence = []\n    current_sum = 0\n    current_subsequence = []\n    \n    for num in sequence:\n        current_sum += num\n        current_subsequence.append(num)\n        \n        if len(current_subsequence) > length:\n            current_sum -= current_subsequence.pop(0)\n        \n        if current_sum > max_sum and len(current_subsequence) >= length:\n            max_sum = current_sum\n            max_subsequence = current_subsequence[:]\n    \n    return max_subsequence"
    },
    {
        "function_name": "lowest_common_ancestor",
        "file_name": "tree_analyzer.py",
        "parameters": {
            "tree": "Dict[int, List[int]] (An adjacency list representation of a tree)",
            "root": "int (The root node)"
        },
        "objectives": [
            "Find the lowest common ancestor of all nodes in the tree.",
            "The lowest common ancestor is the node that is farthest from the root and is an ancestor of all nodes.",
            "Return the lowest common ancestor as an integer."
        ],
        "import_lines": [
            "from typing import Dict, List"
        ],
        "function_def": "def lowest_common_ancestor(tree: Dict[int, List[int]], root: int) -> int:\n    ancestors = set()\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        ancestors.add(node)\n        \n        for child in tree.get(node, []):\n            stack.append(child)\n    \n    lca = root\n    \n    for node in ancestors:\n        if all(node in ancestors for child in tree.get(node, [])):\n            lca = node\n    \n    return lca"
    },
    {
        "function_name": "floyd_warshall",
        "file_name": "floyd_warshall.py",
        "parameters": {
            "matrix": "List[List[int]] - A square matrix representing a graph.",
            "source": "int - The source node."
        },
        "objectives": [
            "Implement a Floyd-Warshall algorithm to find the shortest path between all pairs of nodes in the graph.",
            "Ensure that the algorithm handles the case where there is no path between two nodes.",
            "Return a 2D list representing the shortest distances between all pairs of nodes."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def floyd_warshall(matrix: List[List[int]], source: int) -> List[List[int]]:\n    num_nodes = len(matrix)\n    distances = [[float('inf')] * num_nodes for _ in range(num_nodes)]\n    \n    for i in range(num_nodes):\n        for j in range(num_nodes):\n            distances[i][j] = matrix[i][j]\n            if i == j:\n                distances[i][j] = 0\n    \n    for k in range(num_nodes):\n        for i in range(num_nodes):\n            for j in range(num_nodes):\n                distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])\n    \n    return distances"
    },
    {
        "function_name": "is_ip_address_in_range",
        "file_name": "ip_address_range.py",
        "parameters": {
            "ip_addresses": "List[str] - A list of IP addresses in CIDR notation (e.g., '192.168.1.0/24').",
            "target_address": "str - A target IP address."
        },
        "objectives": [
            "Implement logic to check whether the target IP address falls within the range of any IP address in the list.",
            "Ensure efficient IP address range checking.",
            "Return a boolean indicating whether the target IP address is in any of the ranges."
        ],
        "import_lines": [
            "from typing import List",
            "import ipaddress"
        ],
        "function_def": "def is_ip_address_in_range(ip_addresses: List[str], target_address: str) -> bool:\n    target_ip = ipaddress.ip_address(target_address)\n    for ip_address in ip_addresses:\n        network = ipaddress.ip_network(ip_address, strict=False)\n        if target_ip in network:\n            return True\n    return False"
    },
    {
        "function_name": "detect_anomalies",
        "file_name": "anomaly_detection.py",
        "parameters": {
            "data": "List[float] - A list of numeric values.",
            "window_size": "int - The size of the moving window.",
            "threshold": "float - A threshold for detecting anomalies."
        },
        "objectives": [
            "Implement a moving window algorithm to detect anomalies in the data.",
            "Use the Z-score method for anomaly detection.",
            "Return a list of boolean values indicating whether each data point is an anomaly."
        ],
        "import_lines": [
            "from typing import List",
            "import statistics",
            "import math"
        ],
        "function_def": "def detect_anomalies(data: List[float], window_size: int, threshold: float) -> List[bool]:\n    anomalies = []\n    window_sum = sum(data[:window_size])\n    window_mean = window_sum / window_size\n    window_stddev = statistics.stdev(data[:window_size])\n    \n    for i in range(len(data)):\n        if i >= window_size:\n            window_sum = window_sum - data[i - window_size] + data[i]\n            window_mean = window_sum / window_size\n            window_stddev = statistics.stdev(data[i - window_size + 1:i + 1])\n        \n        z_score = (data[i] - window_mean) / window_stddev if window_stddev != 0 else 0\n        anomalies.append(abs(z_score) > threshold)\n    \n    return anomalies"
    },
    {
        "function_name": "pair_products",
        "file_name": "pairwise_calculations.py",
        "parameters": {
            "nums": "List[int]",
            "k": "int",
            "threshold": "int"
        },
        "objectives": [
            "Find all pairs of numbers in the list that sum to k.",
            "Calculate the product of each pair and filter out those that exceed the threshold.",
            "Return a list of pairs that meet the conditions."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def pair_products(nums: List[int], k: int, threshold: int) -> List[Tuple[int, int]]:\n    result = []\n    seen = set()\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == k:\n                product = nums[i] * nums[j]\n                if product <= threshold:\n                    pair = tuple(sorted([nums[i], nums[j]]))\n                    if pair not in seen:\n                        result.append(pair)\n                        seen.add(pair)\n    return result"
    },
    {
        "function_name": "dijkstra_algorithm",
        "file_name": "dijkstra.py",
        "parameters": {
            "graph": "Dict[str, List[str]]",
            "source": "str"
        },
        "objectives": [
            "Implement Dijkstra's algorithm to find the shortest path from the source to all other nodes.",
            "Use a priority queue to efficiently select the next node to visit.",
            "Return a dictionary with the shortest distances and previous nodes for each node."
        ],
        "import_lines": [
            "import heapq",
            "from typing import Dict, List"
        ],
        "function_def": "def dijkstra_algorithm(graph: Dict[str, List[str]], source: str) -> Dict[str, Dict[str, str]]:\n    distances = {node: float('inf') for node in graph}\n    previous_nodes = {node: None for node in graph}\n    distances[source] = 0\n    priority_queue = [(0, source)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor in graph[current_node]:\n            distance = current_distance + 1\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous_nodes[neighbor] = current_node\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return {'distances': distances, 'previous_nodes': previous_nodes}"
    },
    {
        "function_name": "topological_sort",
        "file_name": "topological_sort.py",
        "parameters": {
            "graph": "Dict[int, List[int]] (An adjacency list representation of a graph)",
            "source": "int (The source node for the graph traversal)"
        },
        "objectives": [
            "Implement a topological sorting algorithm to order the nodes in the graph such that for every edge (u, v), node u comes before node v in the ordering.",
            "Ensure that the graph is directed and acyclic (DAG) before performing the topological sort.",
            "Handle cycles in the graph by raising a ValueError.",
            "Return the topologically sorted list of nodes."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import defaultdict, deque"
        ],
        "function_def": "def topological_sort(graph: Dict[int, List[int]], source: int) -> List[int]:\n    in_degree = defaultdict(int)\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n    \n    queue = deque([node for node in graph if in_degree[node] == 0])\n    sorted_order = []\n    \n    while queue:\n        node = queue.popleft()\n        sorted_order.append(node)\n        \n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(sorted_order) != len(graph):\n        raise ValueError(\"Graph contains a cycle\")\n    \n    return sorted_order"
    },
    {
        "function_name": "validate_parentheses",
        "file_name": "validate_parentheses.py",
        "parameters": {
            "text": "str (A string containing parentheses)",
            "max_depth": "int (The maximum allowed nesting depth)"
        },
        "objectives": [
            "Implement a function to validate whether the parentheses in the given string are balanced and nested correctly.",
            "Ensure that the function handles cases where the maximum depth is exceeded.",
            "Use a stack to keep track of the opening parentheses.",
            "Return a boolean indicating whether the parentheses are valid."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def validate_parentheses(text: str, max_depth: int) -> bool:\n    stack = []\n    depth = 0\n    \n    for char in text:\n        if char == '(':\n            stack.append(char)\n            depth += 1\n            \n            if depth > max_depth:\n                return False\n        elif char == ')':\n            if not stack:\n                return False\n            \n            stack.pop()\n            depth -= 1\n    \n    return not stack"
    },
    {
        "function_name": "filter_strings",
        "file_name": "string_filter.py",
        "parameters": {
            "strings": "List[str]",
            "min_length": "int",
            "max_length": "int"
        },
        "objectives": [
            "Filter out strings that are not within the specified length range (inclusive).",
            "Use regular expressions to remove any strings containing non-alphanumeric characters.",
            "Return the filtered list of strings, preserving the original order."
        ],
        "import_lines": [
            "from typing import List",
            "import re"
        ],
        "function_def": "def filter_strings(strings: List[str], min_length: int, max_length: int) -> List[str]:\n    filtered_strings = []\n    \n    for string in strings:\n        if min_length <= len(string) <= max_length and re.match(\"^[a-zA-Z0-9]*$\", string):\n            filtered_strings.append(string)\n    \n    return filtered_strings"
    },
    {
        "function_name": "is_magic_square",
        "file_name": "matrix_magic.py",
        "parameters": {
            "matrix": "List[List[int]]"
        },
        "objectives": [
            "Check if the given matrix is a magic square (i.e., the sum of each row, column, and diagonal is equal).",
            "Calculate the sum of each row and column.",
            "Verify that the sums of the diagonals are equal to the sums of the rows.",
            "Return True if the matrix is a magic square, False otherwise."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def is_magic_square(matrix: List[List[int]]) -> bool:\n    row_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != row_sum:\n            return False\n    \n    # Check columns\n    for col in range(len(matrix[0])):\n        if sum(matrix[row][col] for row in range(len(matrix))) != row_sum:\n            return False\n    \n    # Check diagonals\n    diagonal1_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    diagonal2_sum = sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix)))\n    \n    return diagonal1_sum == row_sum and diagonal2_sum == row_sum"
    },
    {
        "function_name": "generate_gray_code",
        "file_name": "gray_code_generator.py",
        "parameters": {
            "bits": "int",
            "n": "int"
        },
        "objectives": [
            "Generate the Gray code sequence for a given number of bits.",
            "Use bitwise operations to efficiently generate the sequence.",
            "Return the Gray code sequence as a list of integers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def generate_gray_code(bits: int, n: int) -> List[int]:\n    sequence = []\n    \n    for i in range(1 << n):\n        gray_code = i ^ (i >> 1)\n        sequence.append(gray_code)\n    \n    return sequence"
    },
    {
        "function_name": "k_means_clustering",
        "file_name": "k_means.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The number of clusters to create)"
        },
        "objectives": [
            "Cluster the given list of integers using the K-Means algorithm.",
            "Use a random initialization for the centroids.",
            "Handle cases with duplicate numbers and return unique cluster assignments."
        ],
        "import_lines": [
            "from typing import List",
            "import random",
            "import math"
        ],
        "function_def": "def k_means_clustering(nums: List[int], k: int) -> List[int]:\n    if not nums or k <= 0:\n        return []\n    \n    centroids = random.sample(nums, k)\n    cluster_assignments = {num: None for num in nums}\n    \n    while True:\n        new_centroids = []\n        clusters = [[] for _ in range(k)]\n        \n        for num in nums:\n            min_distance = float('inf')\n            closest_centroid = None\n            for centroid in centroids:\n                distance = math.sqrt((num - centroid) ** 2)\n                if distance < min_distance:\n                    min_distance = distance\n                    closest_centroid = centroid\n            \n            cluster_assignments[num] = closest_centroid\n            clusters[centroids.index(closest_centroid)].append(num)\n        \n        for cluster in clusters:\n            if cluster:\n                new_centroids.append(sum(cluster) / len(cluster))\n            else:\n                new_centroids.append(centroids[clusters.index(cluster)])\n        \n        if new_centroids == centroids:\n            break\n        \n        centroids = new_centroids\n    \n    return [cluster_assignments[num] for num in nums]"
    },
    {
        "function_name": "top_player_identifier",
        "file_name": "game_analytics.py",
        "parameters": {
            "top_moves": "List[int] (A list of top moves made by players in a game)",
            "bottom_moves": "List[int] (A list of bottom moves made by players in a game)",
            "threshold": "int (The threshold value for top player identification)"
        },
        "objectives": [
            "Implement a function to determine the top players in a game based on their moves.",
            "Use the mean and standard deviation of top moves to identify top players.",
            "Handle edge cases where the lists are empty or the threshold is invalid."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def top_player_identifier(top_moves: List[int], bottom_moves: List[int], threshold: int) -> List[int]:\n    if not top_moves or not bottom_moves:\n        return []\n    \n    top_mean = np.mean(top_moves)\n    top_std_dev = np.std(top_moves)\n    top_players = [move for move in top_moves if move > top_mean + threshold * top_std_dev]\n    \n    return top_players"
    },
    {
        "function_name": "calculate_medians",
        "file_name": "sequence_median.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences where each sequence is a list of integers.",
            "window_size": "int - The size of the sliding window."
        },
        "objectives": [
            "Apply a sliding window to each sequence to calculate the median of the elements within the window.",
            "Return the medians for each sequence as a list of lists."
        ],
        "import_lines": [
            "from typing import List",
            "import statistics"
        ],
        "function_def": "def calculate_medians(sequences: List[List[int]], window_size: int) -> List[List[float]]:\n    medians = []\n    for sequence in sequences:\n        window_medians = []\n        for i in range(len(sequence) - window_size + 1):\n            window = sequence[i:i + window_size]\n            window_medians.append(statistics.median(window))\n        medians.append(window_medians)\n    return medians"
    },
    {
        "function_name": "lexicographically_smallest_string",
        "file_name": "string_optimizer.py",
        "parameters": {
            "string": "str (The input string)",
            "k": "int (The number of operations)"
        },
        "objectives": [
            "Find the lexicographically smallest string that can be formed by performing at most k operations on the input string.",
            "Employ a greedy approach to remove the largest characters first.",
            "Handle cases where the same character appears multiple times by using a heap data structure.",
            "Return the resulting lexicographically smallest string."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def lexicographically_smallest_string(string: str, k: int) -> str:\n    char_count = {}\n    \n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    max_heap = []\n    \n    for char, count in char_count.items():\n        heapq.heappush(max_heap, (-ord(char), char, count))\n    \n    while k > 0 and max_heap:\n        _, char, count = heapq.heappop(max_heap)\n        \n        if count <= k:\n            k -= count\n        else:\n            char_count[char] -= k\n            k = 0\n    \n    result = \"\"\n    \n    for char in sorted(char_count.keys()):\n        result += char * char_count[char]\n    \n    return result"
    },
    {
        "function_name": "syntax_highlighter",
        "file_name": "syntax_highlighter.py",
        "parameters": {
            "text": "str (The input text for syntax highlighting)",
            "keywords": "List[str] (A list of programming language keywords)",
            "syntax": "Dict[str, str] (A dictionary of syntax highlighting rules)"
        },
        "objectives": [
            "Implement a syntax highlighting system that identifies and highlights programming language keywords in the input text.",
            "Use a dictionary of syntax highlighting rules to determine the highlighting style for each keyword.",
            "Return a string with the highlighted text."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def syntax_highlighter(text: str, keywords: List[str], syntax: Dict[str, str]) -> str:\n    highlighted_text = \"\"\n    \n    words = text.split()\n    for word in words:\n        if word in keywords:\n            highlighting = syntax.get(word, \"\")\n            highlighted_text += f\"<span style='{highlighting}'>{word}</span> \"\n        else:\n            highlighted_text += f\"{word} \"\n    \n    return highlighted_text"
    },
    {
        "function_name": "power_iteration",
        "file_name": "power_iteration.py",
        "parameters": {
            "matrix": "List[List[float]] (A list of lists representing a matrix)",
            "k": "int (The number of eigenvalues and eigenvectors to compute)"
        },
        "objectives": [
            "Implement the power iteration method to compute the top k eigenvalues and eigenvectors of the input matrix.",
            "Use a Gram-Schmidt process to orthogonalize the eigenvectors.",
            "Return a list of eigenvalues and a list of eigenvectors."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def power_iteration(matrix: List[List[float]], k: int) -> List[float]:\n    eigenvalues = []\n    eigenvectors = []\n    \n    for _ in range(k):\n        # Initialize a random vector\n        vector = np.random.rand(len(matrix))\n        \n        # Normalize the vector\n        vector /= np.linalg.norm(vector)\n        \n        # Perform power iteration\n        for _ in range(100):\n            vector = np.dot(matrix, vector)\n            vector /= np.linalg.norm(vector)\n        \n        # Append the eigenvalue and eigenvector\n        eigenvalues.append(np.dot(vector, np.dot(matrix, vector)) / np.dot(vector, vector))\n        eigenvectors.append(vector)\n        \n        # Orthogonalize the vector using Gram-Schmidt process\n        for i in range(len(eigenvalues) - 1):\n            vector -= np.dot(eigenvectors[i], vector) * eigenvectors[i]\n        vector /= np.linalg.norm(vector)\n    \n    return eigenvalues, eigenvectors"
    },
    {
        "function_name": "parse_text",
        "file_name": "text_parser.py",
        "parameters": {
            "text": "str (The input text to parse)",
            "separator": "str (The separator to split the text by)"
        },
        "objectives": [
            "Implement a parser to split the input text into substrings based on the separator.",
            "Return a list of substrings, excluding any empty strings.",
            "Handle cases where the separator is not present in the text.",
            "If the separator is an empty string, return a list of individual characters in the text."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def parse_text(text: str, separator: str) -> List[str]:\n    if not text:\n        return []\n    \n    if not separator:\n        return list(text)\n    \n    substrings = text.split(separator)\n    \n    return [sub for sub in substrings if sub]"
    },
    {
        "function_name": "rotate_sub_matrix",
        "file_name": "matrix_rotator.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix represented as a list of lists)",
            "row": "int (The row index to start the rotation from)",
            "col": "int (The column index to start the rotation from)",
            "size": "int (The size of the sub-matrix to rotate)"
        },
        "objectives": [
            "Implement a function to rotate a sub-matrix within the given matrix.",
            "The sub-matrix is defined by the top-left cell at (row, col) and the size.",
            "Rotate the sub-matrix clockwise by 90 degrees.",
            "Return the modified matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def rotate_sub_matrix(matrix: List[List[int]], row: int, col: int, size: int) -> List[List[int]]:\n    if not matrix or size <= 0:\n        return matrix\n    \n    for _ in range(4):\n        for layer in range(size // 2):\n            first, last = layer, size - layer - 1\n            \n            for i in range(first, last):\n                top = matrix[layer + row][i + col]\n                \n                matrix[layer + row][i + col] = matrix[-i - 1 + row + size - 1][layer + col]\n                matrix[-i - 1 + row + size - 1][layer + col] = matrix[-layer - 1 + row + size - 1][-i - 1 + col + size - 1]\n                matrix[-layer - 1 + row + size - 1][-i - 1 + col + size - 1] = matrix[i + row][last + col]\n                matrix[i + row][last + col] = top\n                \n    return matrix"
    },
    {
        "function_name": "merge_intervals",
        "file_name": "interval_merger.py",
        "parameters": {
            "intervals": "List[List[int]] (A list of intervals where each interval is a list of two integers)",
            "new_interval": "List[int] (The new interval to insert into the list)"
        },
        "objectives": [
            "Implement a function to insert a new interval into the list of existing intervals.",
            "Merge any overlapping intervals.",
            "Return the updated list of intervals."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def merge_intervals(intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\n    if not intervals:\n        return [new_interval]\n    \n    result = []\n    i = 0\n    \n    while i < len(intervals) and intervals[i][1] < new_interval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    while i < len(intervals) and intervals[i][0] <= new_interval[1]:\n        new_interval[0] = min(intervals[i][0], new_interval[0])\n        new_interval[1] = max(intervals[i][1], new_interval[1])\n        i += 1\n    \n    result.append(new_interval)\n    \n    while i < len(intervals):\n        result.append(intervals[i])\n        i += 1\n    \n    return result"
    },
    {
        "function_name": "max_marbles_in_boxes",
        "file_name": "marble_solver.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "max_marbles": "int (The maximum number of marbles)"
        },
        "objectives": [
            "Implement a method to find the maximum number of marbles that can be put in boxes.",
            "Each box can hold a certain number of marbles, and the total number of marbles is limited by max_marbles.",
            "Return the maximum number of marbles that can be put in the boxes."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_marbles_in_boxes(nums: List[int], max_marbles: int) -> int:\n    dp = [0] * (max_marbles + 1)\n    for num in nums:\n        for i in range(max_marbles, num - 1, -1):\n            dp[i] = max(dp[i], dp[i - num] + num)\n    return dp[max_marbles]"
    },
    {
        "function_name": "shortest_path_to_all_cells",
        "file_name": "dijkstra.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D list representing the grid)",
            "start": "Tuple[int, int] (The starting coordinates in the grid)"
        },
        "objectives": [
            "Implement a method to find the shortest path from the start to all other cells in the grid using Dijkstra's algorithm.",
            "The grid can contain obstacles represented by 1s.",
            "Ensure that diagonal movements are not allowed and only horizontal and vertical moves are considered.",
            "Return a 2D list representing the shortest distance to each cell from the start."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import heapq"
        ],
        "function_def": "def shortest_path_to_all_cells(grid: List[List[int]], start: Tuple[int, int]) -> List[List[int]]:\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[start[0]][start[1]] = 0\n    queue = [(0, start[0], start[1])]\n    \n    while queue:\n        distance, row, col = heapq.heappop(queue)\n        \n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and distance + 1 < distances[new_row][new_col]:\n                distances[new_row][new_col] = distance + 1\n                heapq.heappush(queue, (distance + 1, new_row, new_col))\n    \n    return distances"
    },
    {
        "function_name": "sentence_extractor",
        "file_name": "sentence_extractor.py",
        "parameters": {
            "text": "str",
            "keywords": "List[str]"
        },
        "objectives": [
            "Create a function to extract all sentences from the given text that contain at least one of the specified keywords.",
            "The function should split the text into individual sentences using punctuation marks as delimiters.",
            "The function should use regular expressions to remove punctuation marks from the extracted sentences.",
            "Return a list of extracted sentences in the order they appear in the text."
        ],
        "import_lines": [
            "import re",
            "from typing import List"
        ],
        "function_def": "def sentence_extractor(text: str, keywords: List[str]) -> List[str]:\n    sentences = re.split(r'[.!?]', text)\n    extracted_sentences = []\n    \n    for sentence in sentences:\n        sentence = re.sub(r'[^\\w\\s]', '', sentence).strip()\n        if any(keyword.lower() in sentence.lower() for keyword in keywords):\n            extracted_sentences.append(sentence)\n            \n    return extracted_sentences"
    },
    {
        "function_name": "sequence_variations",
        "file_name": "sequence_variations.py",
        "parameters": {
            "sequences": "List[str]",
            "variations": "int"
        },
        "objectives": [
            "Implement a function to generate all possible variations of a given list of DNA sequences, where each variation is obtained by replacing one or more characters with their complements.",
            "The DNA complement mapping is as follows: 'A' -> 'T', 'T' -> 'A', 'G' -> 'C', 'C' -> 'G'.",
            "The function should return a list of all unique variations."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def sequence_variations(sequences: List[str], variations: int) -> List[str]:\n    complements = {'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'}\n    unique_variations = set(sequences)\n    \n    for _ in range(variations):\n        new_variations = set()\n        for sequence in unique_variations:\n            for i in range(len(sequence)):\n                for base, complement in complements.items():\n                    new_sequence = sequence[:i] + complement + sequence[i+1:]\n                    new_variations.add(new_sequence)\n        unique_variations.update(new_variations)\n        \n    return list(unique_variations)"
    },
    {
        "function_name": "moving_window_max",
        "file_name": "window_max.py",
        "parameters": {
            "numbers": "List[int] - A list of integers",
            "threshold": "int - The threshold value",
            "window_size": "int - The size of the window"
        },
        "objectives": [
            "Implement a moving window maximum calculation over the given list of numbers.",
            "Ensure that the maximum value is calculated for each window size where the window does not fully fit at the start and end.",
            "Filter out the calculated maximum values that exceed the given threshold.",
            "Return the filtered list of maximum values."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def moving_window_max(numbers: List[int], threshold: int, window_size: int) -> List[int]:\n    if window_size <= 0:\n        raise ValueError(\"Window size must be positive.\")\n        \n    max_values = []\n    queue = []\n    \n    for i in range(len(numbers)):\n        # Remove elements from the back of the queue that are out of the window\n        while queue and queue[0] < i - window_size + 1:\n            queue.pop(0)\n        \n        # Remove elements from the front of the queue that are smaller than the current number\n        while queue and numbers[queue[-1]] < numbers[i]:\n            queue.pop()\n        \n        queue.append(i)\n        \n        # Calculate the maximum value for the current window\n        if i >= window_size - 1:\n            max_value = numbers[queue[0]]\n            # Filter out the maximum values that exceed the threshold\n            if max_value <= threshold:\n                max_values.append(max_value)\n    \n    return max_values"
    },
    {
        "function_name": "max_profit_with_fee",
        "file_name": "stock_trader.py",
        "parameters": {
            "prices": "List[int] - A list of stock prices",
            "fees": "int - The transaction fee"
        },
        "objectives": [
            "Implement a function to calculate the maximum profit from buying and selling stocks with a transaction fee.",
            "Buy and sell stocks multiple times to maximize the profit.",
            "Return the maximum profit."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_profit_with_fee(prices: List[int], fees: int) -> int:\n    if not prices:\n        return 0\n        \n    cash, hold = 0, -prices[0]\n    \n    for i in range(1, len(prices)):\n        cash = max(cash, hold + prices[i] - fees)\n        hold = max(hold, cash - prices[i])\n    \n    return cash"
    },
    {
        "function_name": "plant_flowers",
        "file_name": "gardener.py",
        "parameters": {
            "flowers": "List[int] - A list of flower types",
            "garden_size": "int - The size of the garden"
        },
        "objectives": [
            "Implement a function to plant flowers in the garden based on their types.",
            "Plant flowers of different types in adjacent plots.",
            "Plant flowers of the same type at a distance of at least `garden_size` plots.",
            "Return the maximum number of flowers that can be planted."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def plant_flowers(flowers: List[int], garden_size: int) -> int:\n    if not flowers:\n        return 0\n        \n    last_planted = {}\n    planted = 0\n    \n    for flower in flowers:\n        if flower not in last_planted or planted - last_planted[flower] >= garden_size:\n            last_planted[flower] = planted\n            planted += 1\n    \n    return planted"
    },
    {
        "function_name": "dijkstra_k_nodes",
        "file_name": "dijkstra_k_nodes.py",
        "parameters": {
            "graph": "Dict[str, List[Tuple[str, int]]] - An adjacency list representing a weighted graph where each key is a node and its corresponding value is a list of tuples, each tuple containing an adjacent node and the weight of the edge between them.",
            "start": "str - The starting node in the graph.",
            "end": "str - The ending node in the graph.",
            "k": "int - The maximum number of nodes to visit before reaching the end node."
        },
        "objectives": [
            "Implement a variant of Dijkstra's algorithm to find the shortest path from the start node to the end node while ensuring that the path visits at most k nodes.",
            "Validate the path to ensure that it starts and ends at the specified nodes and that all intermediate nodes are distinct.",
            "Return the shortest path along with its total weight."
        ],
        "import_lines": [
            "import heapq"
        ],
        "function_def": "def dijkstra_k_nodes(graph, start, end, k):\n    queue = [(0, [start], start)]\n    visited = set()\n    shortest_path = None\n    min_weight = float('inf')\n    \n    while queue:\n        (weight, path, current) = heapq.heappop(queue)\n        \n        if current not in visited and len(path) <= k + 1:\n            visited.add(current)\n            \n            if current == end and weight < min_weight:\n                min_weight = weight\n                shortest_path = path\n            \n            for neighbor, neighbor_weight in graph[current]:\n                if neighbor not in visited:\n                    heapq.heappush(queue, (weight + neighbor_weight, path + [neighbor], neighbor))\n    \n    return shortest_path, min_weight"
    },
    {
        "function_name": "select_top_rooms",
        "file_name": "room_selector.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D matrix representing the number of machines in different rooms.",
            "rows": "int - The number of rows in the matrix.",
            "cols": "int - The number of columns in the matrix.",
            "k": "int - The number of rooms to select."
        },
        "objectives": [
            "Implement a greedy algorithm to select the top k rooms with the most machines.",
            "Validate the selection to ensure that the rooms are distinct and that each room has at least one machine.",
            "Return the selected rooms as a list of tuples, where each tuple contains the row and column indices of the room."
        ],
        "import_lines": [],
        "function_def": "def select_top_rooms(matrix, rows, cols, k):\n    room_machines = []\n    \n    for i in range(rows):\n        for j in range(cols):\n            room_machines.append((i, j, matrix[i][j]))\n    \n    room_machines.sort(key=lambda x: x[2], reverse=True)\n    \n    selected_rooms = []\n    \n    for room in room_machines:\n        if len(selected_rooms) < k and room[2] > 0:\n            selected_rooms.append((room[0], room[1]))\n    \n    return selected_rooms"
    },
    {
        "function_name": "extract_entities",
        "file_name": "entity_extractor.py",
        "parameters": {
            "text": "str - The input text to be parsed.",
            "entities": "List[str] - A list of entities to be extracted from the text."
        },
        "objectives": [
            "Implement a natural language processing algorithm using regular expressions to extract the specified entities from the text.",
            "Validate the extracted entities to ensure that they match the specified entities.",
            "Return the extracted entities as a list of tuples, where each tuple contains the entity and its start index in the text."
        ],
        "import_lines": [
            "import re"
        ],
        "function_def": "def extract_entities(text, entities):\n    extracted_entities = []\n    \n    for entity in entities:\n        pattern = r'\\b' + re.escape(entity) + r'\\b'\n        matches = re.finditer(pattern, text)\n        \n        for match in matches:\n            extracted_entities.append((entity, match.start()))\n    \n    return extracted_entities"
    },
    {
        "function_name": "find_interesting_cells",
        "file_name": "matrix_analyzer.py",
        "parameters": {
            "matrix": "List[List[float]] (A list of lists representing a matrix)",
            "threshold": "float (The threshold value for determining \"interesting\" cells)"
        },
        "objectives": [
            "Implement an algorithm to find all \"interesting\" cells in the matrix.",
            "A cell is considered \"interesting\" if its value is greater than the threshold.",
            "Return a list of coordinates (i, j) representing the positions of the \"interesting\" cells."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_interesting_cells(matrix: List[List[float]], threshold: float) -> List[tuple]:\n    interesting_cells = []\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] > threshold:\n                interesting_cells.append((i, j))\n    \n    return interesting_cells"
    },
    {
        "function_name": "find_common_motifs",
        "file_name": "sequence_analyzer.py",
        "parameters": {
            "sequences": "List[str] (A list of DNA or protein sequences)",
            "motif_length": "int (The length of the motif to be found)"
        },
        "objectives": [
            "Implement an algorithm to find all common motifs in the given sequences.",
            "Use a combination of sliding window and hashing to efficiently find the motifs.",
            "Return a list of motifs found in all sequences."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_common_motifs(sequences: List[str], motif_length: int) -> List[str]:\n    # Initialize a set to store the motifs\n    motifs = set()\n    \n    # Iterate over each sequence\n    for seq in sequences:\n        # Iterate over each possible motif in the sequence\n        for i in range(len(seq) - motif_length + 1):\n            # Extract the motif\n            motif = seq[i:i + motif_length]\n            \n            # Check if the motif is present in all other sequences\n            if all(motif in other_seq for other_seq in sequences):\n                # Add the motif to the set\n                motifs.add(motif)\n    \n    return list(motifs)"
    },
    {
        "function_name": "classify_numbers",
        "file_name": "classification.py",
        "parameters": {
            "numbers": "List[float] (A list of floating-point numbers)",
            "threshold": "float (The threshold value to use for classification)"
        },
        "objectives": [
            "Implement a function that classifies each number as either \"high\" or \"low\" based on the threshold.",
            "Return a list of tuples, where each tuple contains the original number and its corresponding classification.",
            "Handle the case where the input list is empty."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def classify_numbers(numbers, threshold):\n    classifications = []\n    \n    for number in numbers:\n        if number >= threshold:\n            classification = \"high\"\n        else:\n            classification = \"low\"\n        classifications.append((number, classification))\n    \n    return classifications"
    },
    {
        "function_name": "extract_substrings",
        "file_name": "string_processing.py",
        "parameters": {
            "strings": "List[str] (A list of strings to process)",
            "pattern": "str (A regular expression pattern to match)"
        },
        "objectives": [
            "Implement a function that uses a regular expression to extract substrings from each input string.",
            "Return a list of lists, where each inner list contains the extracted substrings for the corresponding input string.",
            "Handle the case where the input list is empty or the pattern does not match any substrings."
        ],
        "import_lines": [
            "import re",
            "from typing import List"
        ],
        "function_def": "def extract_substrings(strings, pattern):\n    extracted = []\n    \n    for string in strings:\n        matches = re.findall(pattern, string)\n        extracted.append(matches)\n    \n    return extracted"
    },
    {
        "function_name": "smooth_time_series",
        "file_name": "time_series_analysis.py",
        "parameters": {
            "time_series": "List[int] (A list of integers representing a time series)",
            "window_size": "int (The size of the window to use for smoothing)"
        },
        "objectives": [
            "Implement a function that applies a moving average to the time series.",
            "Return a new list that contains the smoothed values, using the same length as the input list.",
            "Handle the case where the window size is greater than the length of the series.",
            "If the window size is 1, return the original time series."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def smooth_time_series(time_series, window_size):\n    if window_size == 1:\n        return time_series\n    \n    if window_size > len(time_series):\n        return [None] * len(time_series)\n    \n    smoothed = []\n    \n    for i in range(len(time_series)):\n        if i < window_size - 1:\n            smoothed.append(None)\n        else:\n            window = time_series[i - window_size + 1:i + 1]\n            smoothed.append(sum(window) / window_size)\n    \n    return smoothed"
    },
    {
        "function_name": "truncate_binary_strings",
        "file_name": "binary_string_processing.py",
        "parameters": {
            "binary_strings": "List[str] (A list of binary strings)",
            "max_length": "int (The maximum length of the output binary strings)"
        },
        "objectives": [
            "Implement a function that truncates each binary string to the maximum length.",
            "Return a new list containing the truncated binary strings.",
            "Handle the case where the input list is empty or the maximum length is 0.",
            "If the maximum length is greater than the length of a binary string, return the original binary string."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def truncate_binary_strings(binary_strings, max_length):\n    truncated = []\n    \n    for binary_string in binary_strings:\n        if max_length == 0:\n            truncated.append(\"\")\n        elif len(binary_string) > max_length:\n            truncated.append(binary_string[:max_length])\n        else:\n            truncated.append(binary_string)\n    \n    return truncated"
    },
    {
        "function_name": "merge_intervals",
        "file_name": "interval_merger.py",
        "parameters": {
            "intervals": "List[List[int]] (A list of intervals where each interval is a list of two integers)"
        },
        "objectives": [
            "Merge all overlapping intervals in the list.",
            "Return the merged intervals in a sorted order.",
            "Ensure that the merged intervals do not overlap with each other."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def merge_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        if merged[-1][1] >= current[0]:\n            merged[-1][1] = max(merged[-1][1], current[1])\n        else:\n            merged.append(current)\n    \n    return merged"
    },
    {
        "function_name": "bellman_ford",
        "file_name": "bellman_ford.py",
        "parameters": {
            "graph": "List[List[int]] (An adjacency list representation of a graph)",
            "source": "int (The source node)"
        },
        "objectives": [
            "Find the shortest path from the source node to all other nodes in the graph using Bellman-Ford algorithm.",
            "Return the shortest distances from the source node to all other nodes."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def bellman_ford(graph: List[List[int]], source: int) -> List[int]:\n    distances = [float('inf')] * len(graph)\n    distances[source] = 0\n    \n    for _ in range(len(graph) - 1):\n        for u in range(len(graph)):\n            for v, w in graph[u]:\n                distances[v] = min(distances[v], distances[u] + w)\n    \n    for u in range(len(graph)):\n        for v, w in graph[u]:\n            if distances[u] + w < distances[v]:\n                raise ValueError(\"Graph contains a negative-weight cycle\")\n    \n    return distances"
    },
    {
        "function_name": "multi_target_dijkstra",
        "file_name": "graph_search.py",
        "parameters": {
            "graph": "Dict[int, List[int]] - An adjacency list representation of a graph.",
            "start_node": "int - The node to start the search from.",
            "target_nodes": "List[int] - A list of target nodes to reach."
        },
        "objectives": [
            "Find the shortest path to each target node using Dijkstra's algorithm.",
            "Calculate the minimum cost to reach all target nodes.",
            "Return a dictionary with the shortest paths and the minimum cost."
        ],
        "import_lines": [
            "import sys",
            "from typing import Dict, List"
        ],
        "function_def": "def multi_target_dijkstra(graph: Dict[int, List[int]], start_node: int, target_nodes: List[int]) -> Dict[int, List[int]]:\n    distances = {node: sys.maxsize for node in graph}\n    distances[start_node] = 0\n    shortest_paths = {node: [] for node in graph}\n    shortest_paths[start_node] = [start_node]\n    \n    unvisited_nodes = list(graph.keys())\n    \n    while unvisited_nodes:\n        current_node = min(unvisited_nodes, key=lambda node: distances[node])\n        unvisited_nodes.remove(current_node)\n        \n        for neighbor in graph[current_node]:\n            tentative_distance = distances[current_node] + 1\n            if tentative_distance < distances[neighbor]:\n                distances[neighbor] = tentative_distance\n                shortest_paths[neighbor] = shortest_paths[current_node] + [neighbor]\n    \n    min_cost = sum(distances[node] for node in target_nodes)\n    result = {node: shortest_paths[node] for node in target_nodes}\n    result['min_cost'] = min_cost\n    \n    return result"
    },
    {
        "function_name": "budget_tracker",
        "file_name": "budget_analyzer.py",
        "parameters": {
            "transactions": "List[Tuple[str, int, str]] - A list of transactions, where each transaction is a tuple of (date, amount, description).",
            "budget": "int - The total budget for the month."
        },
        "objectives": [
            "Categorize transactions into different categories (e.g., food, entertainment, etc.).",
            "Calculate the total amount spent in each category.",
            "Identify categories that exceed the budget and return a list of these categories."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict"
        ],
        "function_def": "def budget_tracker(transactions: List[Tuple[str, int, str]], budget: int) -> List[str]:\n    categories = {}\n    \n    for date, amount, description in transactions:\n        category = description.split(':')[0].strip()\n        if category in categories:\n            categories[category] += amount\n        else:\n            categories[category] = amount\n    \n    exceeded_categories = [category for category, amount in categories.items() if amount > budget]\n    \n    return exceeded_categories"
    },
    {
        "function_name": "bin_packing",
        "file_name": "bin_packer.py",
        "parameters": {
            "weights": "List[int] - A list of weights for the objects.",
            "capacities": "List[int] - A list of capacities for the bins."
        },
        "objectives": [
            "Use the first-fit decreasing algorithm to assign objects to bins.",
            "Ensure that the total weight of objects in each bin does not exceed its capacity.",
            "Return a list of bins with their assigned objects."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def bin_packing(weights: List[int], capacities: List[int]) -> List[List[int]]:\n    weights.sort(reverse=True)\n    bins = [[] for _ in range(len(capacities))]\n    bin_weights = [0] * len(capacities)\n    \n    for weight in weights:\n        for i, capacity in enumerate(capacities):\n            if bin_weights[i] + weight <= capacity:\n                bins[i].append(weight)\n                bin_weights[i] += weight\n                break\n    \n    return bins"
    },
    {
        "function_name": "greedy_sequence_selection",
        "file_name": "sequence_selection.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of integer sequences.",
            "duration": "int - The maximum allowed duration for each sequence."
        },
        "objectives": [
            "Implement a greedy algorithm to determine the optimal subset of sequences that do not exceed the maximum duration.",
            "Calculate the total value of the selected sequences based on the sum of their elements.",
            "Ensure that if multiple sequences have the same total value but different durations, the one with the shorter duration is chosen.",
            "Return the optimal subset of sequences and their total value."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def greedy_sequence_selection(sequences: List[List[int]], duration: int) -> (List[List[int]], int):\n    sequences.sort(key=lambda x: (sum(x), len(x)))\n    total_value = 0\n    selected_sequences = []\n    current_duration = 0\n    \n    for sequence in sequences:\n        sequence_duration = len(sequence)\n        if current_duration + sequence_duration <= duration:\n            total_value += sum(sequence)\n            selected_sequences.append(sequence)\n            current_duration += sequence_duration\n    \n    return selected_sequences, total_value"
    },
    {
        "function_name": "interval_partitioning",
        "file_name": "interval_partitioning.py",
        "parameters": {
            "intervals": "List[List[int]] - A list of integer intervals, where each interval is represented as [start, end].",
            "num_partitions": "int - The target number of partitions for the intervals."
        },
        "objectives": [
            "Implement a dynamic programming solution to partition the intervals into a specified number of non-overlapping partitions.",
            "Ensure that the end point of each partition is the start point of the next partition.",
            "Handle the case where the input intervals are empty or the target number of partitions is invalid.",
            "Return the partitioned intervals."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def interval_partitioning(intervals: List[List[int]], num_partitions: int) -> List[List[int]]:\n    if not intervals or num_partitions < 1:\n        raise ValueError(\"Invalid input\")\n    \n    intervals.sort(key=lambda x: x[1])\n    partitioned_intervals = []\n    \n    for _ in range(num_partitions):\n        current_partition = []\n        end_point = float('-inf')\n        for interval in intervals:\n            if interval[0] > end_point:\n                current_partition.append(interval)\n                end_point = interval[1]\n        partitioned_intervals.append(current_partition)\n        intervals = [interval for interval in intervals if interval not in current_partition]\n    \n    return partitioned_intervals"
    },
    {
        "function_name": "overlapping_intervals",
        "file_name": "interval_matcher.py",
        "parameters": {
            "intervals": "List[List[int]]",
            "target": "int"
        },
        "objectives": [
            "Implement a function to find the total number of intervals that overlap with the target interval.",
            "Use a sweep line approach to sort the intervals by their start times.",
            "Update the count of overlapping intervals as we sweep through the sorted intervals."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def overlapping_intervals(intervals: List[List[int]], target: int) -> int:\n    start = [(interval[0], 1) for interval in intervals]\n    end = [(interval[1], -1) for interval in intervals]\n    points = sorted(start + end)\n    \n    count = 0\n    total = 0\n    for _, value in points:\n        count += value\n        if count > 0:\n            total += 1\n    \n    return total"
    },
    {
        "function_name": "rabin_karp_search",
        "file_name": "pattern_searcher.py",
        "parameters": {
            "text": "str (The input text to search for patterns)",
            "patterns": "List[str] (A list of patterns to search for in the text)"
        },
        "objectives": [
            "Implement the Rabin-Karp algorithm to search for multiple patterns in the text.",
            "The function should return a dictionary where the keys are the patterns and the values are lists of indices where the patterns were found in the text.",
            "Handle cases where the text or patterns are empty."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import hashlib"
        ],
        "function_def": "def rabin_karp_search(text: str, patterns: List[str]) -> Dict[str, List[int]]:\n    results = {pattern: [] for pattern in patterns}\n    pattern_hashes = {pattern: hashlib.sha256(pattern.encode()).hexdigest() for pattern in patterns}\n    text_length = len(text)\n    \n    for pattern, pattern_hash in pattern_hashes.items():\n        pattern_length = len(pattern)\n        text_hash = hashlib.sha256(text[:pattern_length].encode()).hexdigest()\n        for i in range(text_length - pattern_length + 1):\n            if text_hash == pattern_hash and text[i:i+pattern_length] == pattern:\n                results[pattern].append(i)\n            if i < text_length - pattern_length:\n                text_hash = hashlib.sha256((text[i+1:i+1+pattern_length]).encode()).hexdigest()\n    \n    return results"
    },
    {
        "function_name": "interval_clustering",
        "file_name": "interval_clusterer.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] (A list of intervals)",
            "k": "int (The number of clusters to form)"
        },
        "objectives": [
            "Implement the k-means clustering algorithm to cluster the intervals.",
            "The function should handle cases where the number of clusters is greater than the number of intervals.",
            "Return a dictionary where the keys are the cluster centers and the values are lists of intervals assigned to each cluster."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict",
            "import random"
        ],
        "function_def": "def interval_clustering(intervals: List[Tuple[int, int]], k: int) -> Dict[float, List[Tuple[int, int]]]:\n    if k > len(intervals):\n        k = len(intervals)\n    \n    # Randomly initialize cluster centers\n    centers = random.sample([interval[0] for interval in intervals], k)\n    \n    while True:\n        clusters = {center: [] for center in centers}\n        for start, end in intervals:\n            closest_center = min(centers, key=lambda x: abs(x - (start + end) / 2))\n            clusters[closest_center].append((start, end))\n        \n        new_centers = []\n        for center, cluster in clusters.items():\n            if cluster:\n                new_center = sum(start + end for start, end in cluster) / (2 * len(cluster))\n                new_centers.append(new_center)\n            else:\n                new_centers.append(center)\n        \n        if new_centers == centers:\n            break\n        centers = new_centers\n    \n    return clusters"
    },
    {
        "function_name": "longest_substring_with_n_distinct_chars",
        "file_name": "substring_analyzer.py",
        "parameters": {
            "s": "str - A string containing a sequence of characters.",
            "n": "int - The number of distinct characters to be counted."
        },
        "objectives": [
            "Find the longest substring with at most 'n' distinct characters.",
            "Ensure the substring has a minimum length of 2 characters.",
            "Use a sliding window approach to efficiently traverse the string.",
            "Return a tuple containing the longest substring and its length."
        ],
        "import_lines": [
            "from collections import defaultdict"
        ],
        "function_def": "def longest_substring_with_n_distinct_chars(s: str, n: int) -> tuple:\n    char_count = defaultdict(int)\n    max_length = 0\n    max_substring = \"\"\n    window_start = 0\n    \n    for window_end in range(len(s)):\n        right_char = s[window_end]\n        char_count[right_char] += 1\n        \n        while len(char_count) > n:\n            left_char = s[window_start]\n            char_count[left_char] -= 1\n            if char_count[left_char] == 0:\n                del char_count[left_char]\n            window_start += 1\n        \n        if window_end - window_start + 1 > max_length and window_end - window_start + 1 >= 2:\n            max_length = window_end - window_start + 1\n            max_substring = s[window_start:window_end + 1]\n    \n    return max_substring, max_length"
    },
    {
        "function_name": "find_k_sum_combinations",
        "file_name": "k_sum_combinations.py",
        "parameters": {
            "num_list": "List[int]",
            "target_sum": "int",
            "k": "int"
        },
        "objectives": [
            "Find all unique combinations of exactly 'k' integers from the list that sum up to the target value.",
            "Ensure that the combinations do not contain duplicate triplets.",
            "Ignore any invalid input (less than 'k' numbers in the list).",
            "Return the result in a sorted manner based on the smallest value of each combination."
        ],
        "import_lines": [
            "from typing import List",
            "import itertools"
        ],
        "function_def": "def find_k_sum_combinations(num_list: List[int], target_sum: int, k: int) -> List[List[int]]:\n    if len(num_list) < k:\n        return []\n    \n    num_list.sort()\n    result = set()\n    \n    for comb in itertools.combinations(num_list, k):\n        if sum(comb) == target_sum:\n            result.add(tuple(sorted(comb)))\n    \n    return [list(comb) for comb in sorted(result)]"
    },
    {
        "function_name": "concatenate_strings",
        "file_name": "string_concatenator.py",
        "parameters": {
            "`strings`": "List[str] - A list of strings",
            "`max_length`": "int - The maximum length of the concatenated string"
        },
        "objectives": [
            "Implement a function to find the maximum number of strings that can be concatenated within the maximum length.",
            "The function should return the concatenated string.",
            "The function should prioritize longer strings."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def concatenate_strings(strings: List[str], max_length: int) -> str:\n    strings.sort(key=len, reverse=True)\n    concatenated = \"\"\n    for string in strings:\n        if len(concatenated) + len(string) <= max_length:\n            concatenated += string\n    return concatenated"
    },
    {
        "function_name": "most_frequent_digit",
        "file_name": "digit_frequency.py",
        "parameters": {
            "`numbers`": "List[int] - A list of integers",
            "`k`": "int - The number of digits to consider"
        },
        "objectives": [
            "Implement a function to find the most frequent digit that appears in the last k digits of each number.",
            "The function should return a dictionary where the keys are the digits and the values are their frequencies.",
            "The function should handle the case where a number has less than k digits."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def most_frequent_digit(numbers: List[int], k: int) -> dict:\n    frequency = defaultdict(int)\n    for number in numbers:\n        num_str = str(number)\n        for i in range(min(k, len(num_str))):\n            frequency[int(num_str[-i-1])] += 1\n    return dict(frequency)"
    },
    {
        "function_name": "is_vertex_reachable",
        "file_name": "graph_traversal.py",
        "parameters": {
            "graph": "Dict[str, List[str]] - An adjacency list representation of a graph.",
            "start_vertex": "str - The starting vertex for the traversal.",
            "target_vertex": "str - The target vertex to reach."
        },
        "objectives": [
            "Implement logic to detect whether a target vertex is reachable from a given start vertex in a graph.",
            "Ensure efficient traversal using Breadth-First Search (BFS) algorithm.",
            "Return a boolean indicating whether the target vertex is reachable."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import deque"
        ],
        "function_def": "def is_vertex_reachable(graph: Dict[str, List[str]], start_vertex: str, target_vertex: str) -> bool:\n    visited = set()\n    queue = deque([start_vertex])\n    visited.add(start_vertex)\n    \n    while queue:\n        vertex = queue.popleft()\n        if vertex == target_vertex:\n            return True\n        \n        for neighbor in graph.get(vertex, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False"
    },
    {
        "function_name": "longest_subarray",
        "file_name": "subarray_sum.py",
        "parameters": {
            "nums": "List[int]",
            "k": "int"
        },
        "objectives": [
            "Find the longest subarray of the given list of numbers that has a sum closest to the target sum k.",
            "Ensure that the solution handles cases where the input list contains negative numbers and the target sum is zero.",
            "Return the longest subarray as a list of numbers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_subarray(nums: List[int], k: int) -> List[int]:\n    prefix_sum = {0: -1}\n    current_sum = 0\n    closest_sum = float('inf')\n    closest_start = -1\n    closest_end = -1\n    max_len = 0\n    for i, num in enumerate(nums):\n        current_sum += num\n        if current_sum not in prefix_sum:\n            prefix_sum[current_sum] = i\n        if current_sum - k in prefix_sum:\n            temp_sum = current_sum - k\n            temp_start = prefix_sum[temp_sum] + 1\n            temp_len = i - temp_start + 1\n            if abs(temp_sum) < abs(closest_sum) or (abs(temp_sum) == abs(closest_sum) and temp_len > max_len):\n                closest_sum = temp_sum\n                closest_start = temp_start\n                closest_end = i\n                max_len = temp_len\n    return nums[closest_start: closest_end + 1]"
    },
    {
        "function_name": "kmeans",
        "file_name": "clustering_algorithms.py",
        "parameters": {
            "data": "List[List[float]] (A 2D list of floating point numbers)",
            "k": "int (The number of clusters)",
            "max_iterations": "int (The maximum number of iterations)"
        },
        "objectives": [
            "Cluster a given dataset into k clusters using the k-means algorithm.",
            "Handle cases where the number of clusters is greater than the number of data points.",
            "Return a list of cluster assignments, one for each data point."
        ],
        "import_lines": [
            "from typing import List",
            "import random",
            "import math"
        ],
        "function_def": "def kmeans(data: List[List[float]], k: int, max_iterations: int) -> List[int]:\n    num_data_points = len(data)\n    if k > num_data_points:\n        return list(range(num_data_points))\n    \n    cluster_assignments = [random.randint(0, k-1) for _ in range(num_data_points)]\n    centroids = [[random.random() for _ in range(len(data[0]))] for _ in range(k)]\n    \n    for _ in range(max_iterations):\n        old_centroids = centroids[:]\n        for i, point in enumerate(data):\n            min_distance = float('inf')\n            closest_centroid = -1\n            for j, centroid in enumerate(centroids):\n                distance = math.sqrt(sum([(a-b)**2 for a, b in zip(point, centroid)]))\n                if distance < min_distance:\n                    min_distance = distance\n                    closest_centroid = j\n            cluster_assignments[i] = closest_centroid\n        \n        for j in range(k):\n            points_in_cluster = [point for i, point in enumerate(data) if cluster_assignments[i] == j]\n            if points_in_cluster:\n                centroids[j] = [sum([point[m] for point in points_in_cluster]) / len(points_in_cluster) for m in range(len(points_in_cluster[0]))]\n        \n        if centroids == old_centroids:\n            break\n    \n    return cluster_assignments"
    },
    {
        "function_name": "max_submatrix_sum_finder",
        "file_name": "matrix_utils.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "target_sum": "int (The target sum to be achieved by adding numbers in a submatrix)"
        },
        "objectives": [
            "Find the maximum submatrix sum in a given 2D matrix that is close to but does not exceed the target sum.",
            "Use a prefix sum approach to efficiently calculate submatrix sums.",
            "Return the coordinates of the top-left and bottom-right corners of the maximum submatrix."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def max_submatrix_sum_finder(matrix: List[List[int]], target_sum: int) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    rows, cols = len(matrix), len(matrix[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] + matrix[i-1][j-1]\n    \n    max_sum = float('-inf')\n    top_left, bottom_right = None, None\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for end_col in range(j, cols + 1):\n                    submatrix_sum = prefix_sum[k][end_col] - prefix_sum[k][j-1] - prefix_sum[i-1][end_col] + prefix_sum[i-1][j-1]\n                    if submatrix_sum <= target_sum and submatrix_sum > max_sum:\n                        max_sum = submatrix_sum\n                        top_left, bottom_right = (i-1, j-1), (k-1, end_col-1)\n    \n    return top_left, bottom_right"
    },
    {
        "function_name": "list_rotator",
        "file_name": "rotation_utils.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The number of rotations to perform)"
        },
        "objectives": [
            "Rotate the given list of integers to the right by 'k' steps.",
            "Ensure that 'k' can be larger than the length of the list.",
            "Return the rotated list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def list_rotator(nums: List[int], k: int) -> List[int]:\n    k = k % len(nums)\n    return nums[-k:] + nums[:-k]"
    },
    {
        "function_name": "text_compressor",
        "file_name": "text_compression.py",
        "parameters": {
            "text": "str - The input text to be compressed.",
            "threshold": "int - The minimum frequency for a word to be compressed."
        },
        "objectives": [
            "Compress the input text by replacing repeated words with their frequency.",
            "Ensure that words with frequency less than the threshold are not compressed.",
            "Maintain the original order of words in the text.",
            "Return the compressed text."
        ],
        "import_lines": [
            "from collections import Counter",
            "from typing import List",
            "import re"
        ],
        "function_def": "def text_compressor(text: str, threshold: int) -> str:\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    freq_dict = Counter(words)\n    \n    compressed_text = []\n    for word in words:\n        if freq_dict[word] >= threshold:\n            compressed_text.append(f\"{word}({freq_dict[word]})\")\n        else:\n            compressed_text.append(word)\n    \n    return ' '.join(compressed_text)"
    },
    {
        "function_name": "pair_generator",
        "file_name": "pair_utils.py",
        "parameters": {
            "num_pairs": "int - The number of pairs to generate.",
            "max_num": "int - The maximum number in the pairs."
        },
        "objectives": [
            "Generate 'num_pairs' random pairs of numbers within the range [1, max_num].",
            "Ensure that the pairs do not contain duplicate numbers.",
            "Return a list of unique pairs."
        ],
        "import_lines": [
            "import random",
            "from typing import List"
        ],
        "function_def": "def pair_generator(num_pairs: int, max_num: int) -> List[List[int]]:\n    if num_pairs > max_num * (max_num - 1) // 2:\n        raise ValueError(\"num_pairs cannot be greater than the total possible pairs\")\n    \n    pairs = set()\n    while len(pairs) < num_pairs:\n        pair = tuple(sorted((random.randint(1, max_num), random.randint(1, max_num))))\n        if pair[0] != pair[1]:  # ensure the pair does not contain duplicate numbers\n            pairs.add(pair)\n    \n    return [list(pair) for pair in pairs]"
    },
    {
        "function_name": "html_extractor",
        "file_name": "html_extractor.py",
        "parameters": {
            "html": "str - The input HTML string.",
            "tags": "List[str] - A list of HTML tags to extract."
        },
        "objectives": [
            "Extract the contents of the specified HTML tags from the input string.",
            "Ensure that the extracted contents do not contain any HTML tags.",
            "Return a dictionary with the tag names as keys and the extracted contents as values."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import re"
        ],
        "function_def": "def html_extractor(html: str, tags: List[str]) -> Dict[str, List[str]]:\n    extracted_contents = {tag: [] for tag in tags}\n    \n    for tag in tags:\n        pattern = re.compile(f'<{tag}>(.*?)</{tag}>')\n        contents = pattern.findall(html)\n        extracted_contents[tag] = [re.sub('<.*?>', '', content) for content in contents]\n    \n    return extracted_contents"
    },
    {
        "function_name": "find_valid_integers",
        "file_name": "integer_finder.py",
        "parameters": {
            "pred": "callable (A predicate function that takes an integer as argument)",
            "limit": "int (The upper limit of the search space)"
        },
        "objectives": [
            "Create a function to find all integers in the range [0, limit) for which the predicate function returns True.",
            "Use a generator to yield these integers, which should make the function memory-efficient.",
            "The function should have a time complexity of O(n), where n is the limit."
        ],
        "import_lines": [],
        "function_def": "def find_valid_integers(pred, limit):\n    return (i for i in range(limit) if pred(i))"
    },
    {
        "function_name": "find_shortest_path",
        "file_name": "shortest_path.py",
        "parameters": {
            "adjacency_list": "Dict[int, List[int]] (An adjacency list representation of a graph)",
            "source": "int (The source node)",
            "target": "int (The target node)"
        },
        "objectives": [
            "Create a function to find the shortest path from the source to the target node in the graph.",
            "Use Dijkstra's algorithm to compute the shortest distance, considering edge weights.",
            "The function should return a pair of values: the shortest distance and the path taken."
        ],
        "import_lines": [
            "import sys",
            "import heapq",
            "from typing import Dict, List, Tuple, Optional"
        ],
        "function_def": "def find_shortest_path(adjacency_list: Dict[int, List[Tuple[int, int]]], source: int, target: int) -> Optional[Tuple[int, List[int]]]:\n    queue = [(0, source, [])]\n    seen = set()\n    while queue:\n        (dist, node, path) = heapq.heappop(queue)\n        if node not in seen:\n            seen.add(node)\n            path = path + [node]\n            if node == target:\n                return (dist, path)\n            for neighbor, neigh_dist in adjacency_list[node]:\n                if neighbor not in seen:\n                    heapq.heappush(queue, (dist + neigh_dist, neighbor, path))\n    return None"
    },
    {
        "function_name": "tfidf_ngrams",
        "file_name": "nlp.py",
        "parameters": {
            "text": "str - A string representing the text to tokenize.",
            "stop_words": "List[str] - A list of stop words to ignore.",
            "ngrams": "int - The size of n-grams to generate."
        },
        "objectives": [
            "Implement the TF-IDF (Term Frequency-Inverse Document Frequency) algorithm to calculate the importance of each n-gram in the text.",
            "Use a dictionary to store the frequency of each n-gram in the text.",
            "Ensure that stop words are ignored when generating n-grams and calculating TF-IDF scores."
        ],
        "import_lines": [
            "import re",
            "from collections import Counter",
            "from math import log"
        ],
        "function_def": "def tfidf_ngrams(text, stop_words, ngrams):\n    # Tokenize the text into words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    \n    # Remove stop words\n    words = [word for word in words if word not in stop_words]\n    \n    # Generate n-grams\n    ngrams = [' '.join(words[i:i+ngrams]) for i in range(len(words)-ngrams+1)]\n    \n    # Calculate TF-IDF scores\n    tfidf_scores = {}\n    for ngram in ngrams:\n        tf = ngrams.count(ngram) / len(ngrams)\n        idf = log(len(ngrams) / (1 + ngrams.count(ngram)))\n        tfidf_scores[ngram] = tf * idf\n    \n    return tfidf_scores"
    },
    {
        "function_name": "binarize_matrix",
        "file_name": "matrix_binarizer.py",
        "parameters": {
            "matrix": "List[List[float]] - A 2D list representing the input matrix.",
            "threshold": "float - The threshold value to use for binarization."
        },
        "objectives": [
            "Implement the binarization algorithm to convert the input matrix into a binary matrix.",
            "Use the threshold value to determine whether each element is binary (0 or 1).",
            "Ensure that all elements in the resulting binary matrix are either 0 or 1."
        ],
        "import_lines": [],
        "function_def": "def binarize_matrix(matrix, threshold):\n    # Binarize the matrix\n    binary_matrix = [[1 if element >= threshold else 0 for element in row] for row in matrix]\n    \n    return binary_matrix"
    },
    {
        "function_name": "needleman_wunsch",
        "file_name": "sequence_aligner.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences, where each sequence is a list of integers.",
            "gap_penalty": "int - The penalty value to use for gaps in the alignment."
        },
        "objectives": [
            "Implement the Needleman-Wunsch algorithm to align the input sequences.",
            "Use dynamic programming to build a scoring matrix and track the optimal alignment.",
            "Ensure that gaps in the alignment are penalized using the gap penalty value."
        ],
        "import_lines": [],
        "function_def": "def needleman_wunsch(sequences, gap_penalty):\n    # Initialize scoring matrix\n    scoring_matrix = [[0 for _ in range(len(sequences[1])+1)] for _ in range(len(sequences[0])+1)]\n    \n    # Initialize traceback matrix\n    traceback_matrix = [[None for _ in range(len(sequences[1])+1)] for _ in range(len(sequences[0])+1)]\n    \n    # Initialize first row and column of scoring matrix\n    for i in range(len(sequences[0])+1):\n        scoring_matrix[i][0] = gap_penalty * i\n    for j in range(len(sequences[1])+1):\n        scoring_matrix[0][j] = gap_penalty * j\n    \n    # Fill in scoring matrix\n    for i in range(1, len(sequences[0])+1):\n        for j in range(1, len(sequences[1])+1):\n            match = scoring_matrix[i-1][j-1] + (0 if sequences[0][i-1] == sequences[1][j-1] else -1)\n            delete = scoring_matrix[i-1][j] + gap_penalty\n            insert = scoring_matrix[i][j-1] + gap_penalty\n            scoring_matrix[i][j] = max(match, delete, insert)\n            if scoring_matrix[i][j] == match:\n                traceback_matrix[i][j] = \"match\"\n            elif scoring_matrix[i][j] == delete:\n                traceback_matrix[i][j] = \"delete\"\n            else:\n                traceback_matrix[i][j] = \"insert\"\n    \n    # Trace back optimal alignment\n    alignment = []\n    i, j = len(sequences[0]), len(sequences[1])\n    while i > 0 or j > 0:\n        if traceback_matrix[i][j] == \"match\":\n            alignment.append((sequences[0][i-1], sequences[1][j-1]))\n            i -= 1\n            j -= 1\n        elif traceback_matrix[i][j] == \"delete\":\n            alignment.append((sequences[0][i-1], \"-\"))\n            i -= 1\n        else:\n            alignment.append((\"-\", sequences[1][j-1]))\n            j -= 1\n    \n    return alignment[::-1]"
    },
    {
        "function_name": "dfs_search",
        "file_name": "graph_search.py",
        "parameters": {
            "graph": "Dict[str, List[str]] - A dictionary representing an adjacency list for a directed graph.",
            "start_node": "str - The node to start the search from.",
            "end_node": "str - The node to search for."
        },
        "objectives": [
            "Implement a depth-first search (DFS) algorithm to search for the end node in the graph.",
            "Keep track of the visited nodes and avoid revisiting them.",
            "If the end node is found, return a list of nodes representing the path from the start node to the end node."
        ],
        "import_lines": [
            "from typing import Dict, List"
        ],
        "function_def": "def dfs_search(graph: Dict[str, List[str]], start_node: str, end_node: str) -> List[str]:\n    visited = set()\n    stack = [(start_node, [start_node])]\n    \n    while stack:\n        node, path = stack.pop()\n        if node == end_node:\n            return path\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                stack.append((neighbor, path + [neighbor]))\n    \n    return []"
    },
    {
        "function_name": "sequence_clustering",
        "file_name": "sequence_analysis.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences of integers.",
            "window_size": "int - The size of the window to consider for pattern detection."
        },
        "objectives": [
            "Implement the K-Means clustering algorithm to group the sequences based on their similarity within the window size.",
            "Determine the optimal number of clusters based on the Silhouette Coefficient.",
            "Return a list of cluster labels for each sequence."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np",
            "from sklearn.cluster import KMeans",
            "from sklearn.metrics import silhouette_score"
        ],
        "function_def": "def sequence_clustering(sequences: List[List[int]], window_size: int) -> List[int]:\n    # Preprocessing: Windowing and flattening the sequences\n    windows = [sequence[i:i+window_size] for sequence in sequences for i in range(len(sequence) - window_size + 1)]\n    windows = [np.array(window).flatten() for window in windows]\n    \n    # K-Means clustering with optimal number of clusters determined by Silhouette Coefficient\n    silhouette_values = []\n    for n_clusters in range(2, 10):\n        kmeans = KMeans(n_clusters=n_clusters)\n        cluster_labels = kmeans.fit_predict(windows)\n        silhouette_avg = silhouette_score(windows, cluster_labels)\n        silhouette_values.append(silhouette_avg)\n    optimal_n_clusters = np.argmax(silhouette_values) + 2\n    \n    kmeans = KMeans(n_clusters=optimal_n_clusters)\n    cluster_labels = kmeans.fit_predict(windows)\n    return cluster_labels"
    },
    {
        "function_name": "gins_subgraph",
        "file_name": "graph_subgraph.py",
        "parameters": {
            "network": "Dict[str, List[str]] - A dictionary representing an adjacency list for an undirected graph.",
            "nodes": "List[str] - The list of nodes to include in the subgraph."
        },
        "objectives": [
            "Implement the Graph Induced by a Set of Nodes (GINS) algorithm.",
            "Find the induced subgraph of the network on the given set of nodes.",
            "Return the adjacency list of the induced subgraph."
        ],
        "import_lines": [
            "from typing import Dict, List"
        ],
        "function_def": "def gins_subgraph(network: Dict[str, List[str]], nodes: List[str]) -> Dict[str, List[str]]:\n    subgraph = {node: [] for node in nodes}\n    for node in nodes:\n        for neighbor in network[node]:\n            if neighbor in nodes:\n                subgraph[node].append(neighbor)\n    \n    return subgraph"
    },
    {
        "function_name": "calculate_max_sums",
        "file_name": "sequence_utils.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of integer sequences.",
            "window_size": "int - The size of the sliding window."
        },
        "objectives": [
            "Implement a sliding window approach to calculate the maximum sum for each window in the sequences.",
            "Use dynamic programming to efficiently calculate the maximum sum.",
            "Return a list of maximum sums for each sequence."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def calculate_max_sums(sequences: List[List[int]], window_size: int) -> List[List[int]]:\n    max_sums = []\n    for sequence in sequences:\n        prefix_sums = [0] * (len(sequence) + 1)\n        for i in range(len(sequence)):\n            prefix_sums[i + 1] = prefix_sums[i] + sequence[i]\n        \n        max_sum = float('-inf')\n        for i in range(len(sequence) - window_size + 1):\n            window_sum = prefix_sums[i + window_size] - prefix_sums[i]\n            max_sum = max(max_sum, window_sum)\n        \n        max_sums.append(max_sum)\n    \n    return max_sums"
    },
    {
        "function_name": "newton_product_evaluation",
        "file_name": "polynomial_evaluation.py",
        "parameters": {
            "roots": "List[int] - A list of roots of the polynomial.",
            "x": "int - The point to evaluate the polynomial at."
        },
        "objectives": [
            "Implement the Newton's product formula to evaluate the polynomial at the given point.",
            "Use the roots to construct the polynomial.",
            "Return the evaluated value."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def newton_product_evaluation(roots: List[int], x: int) -> int:\n    polynomial = 1\n    for root in roots:\n        polynomial *= (x - root)\n    \n    return polynomial"
    },
    {
        "function_name": "pathfinder",
        "file_name": "maze_navigator.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid representing a maze.",
            "start": "Tuple[int, int] - The starting position in the maze.",
            "end": "Tuple[int, int] - The ending position in the maze."
        },
        "objectives": [
            "Implement a pathfinding algorithm to find the shortest path from the start to the end in the maze.",
            "Ensure the pathfinding algorithm can handle obstacles in the maze represented by zeros.",
            "Return a list of coordinates representing the shortest path."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def pathfinder(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = [(start, [start])]\n    \n    while queue:\n        (x, y), path = queue.pop(0)\n        if (x, y) == end:\n            return path\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1 and (nx, ny) not in path:\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    \n    return None"
    },
    {
        "function_name": "count_sub_matrices",
        "file_name": "matrix_analyzer.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "target": "int (The target sum for the sub-matrix)",
            "min_size": "int (The minimum size of the sub-matrix)"
        },
        "objectives": [
            "Find all possible sub-matrices within the given matrix where the sum of elements in the sub-matrix equals the target sum.",
            "Ensure that each sub-matrix has at least the specified minimum size.",
            "Return the total count of all such valid sub-matrices."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def count_sub_matrices(matrix: List[List[int]], target: int, min_size: int) -> int:\n    count = 0\n    rows, cols = len(matrix), len(matrix[0])\n    \n    for row in range(rows):\n        for col in range(cols):\n            for size in range(min_size, min(rows - row, cols - col) + 1):\n                sub_matrix_sum = sum([sum(row[col:col+size]) for row in matrix[row:row+size]])\n                if sub_matrix_sum == target:\n                    count += 1\n                    \n    return count"
    },
    {
        "function_name": "longest_sequence",
        "file_name": "sequence_analyzer.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of sequences of integers)",
            "max_diff": "int (The maximum allowed difference between consecutive elements in the sequence)"
        },
        "objectives": [
            "Find the longest sequence where the difference between any two consecutive elements does not exceed the specified maximum difference.",
            "If multiple sequences have the same maximum length, return the one with the smallest sum.",
            "Return the longest sequence and its length."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def longest_sequence(sequences: List[List[int]], max_diff: int) -> Tuple[List[int], int]:\n    longest_seq = []\n    max_len = 0\n    \n    for seq in sequences:\n        seq_len = 1\n        for i in range(1, len(seq)):\n            if abs(seq[i] - seq[i-1]) <= max_diff:\n                seq_len += 1\n            else:\n                break\n        if seq_len > max_len or (seq_len == max_len and sum(seq) < sum(longest_seq)):\n            longest_seq = seq\n            max_len = seq_len\n            \n    return longest_seq, max_len"
    },
    {
        "function_name": "k_largest_elements",
        "file_name": "heap_algorithms.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The number of max-heap elements to find)"
        },
        "objectives": [
            "Find the k largest elements in the list using a min-heap data structure.",
            "Ensure that the heap size does not exceed k elements at any point.",
            "Return a list of the k largest elements."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def k_largest_elements(nums: List[int], k: int) -> List[int]:\n    min_heap = []\n    \n    for num in nums:\n        if len(min_heap) < k:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappushpop(min_heap, num)\n            \n    return sorted(min_heap, reverse=True)"
    },
    {
        "function_name": "find_containing_intervals",
        "file_name": "interval_finder.py",
        "parameters": {
            "intervals": "List[List[int]] (A list of intervals where each interval is a list of two integers)",
            "queries": "List[int] (A list of query points)"
        },
        "objectives": [
            "Find the interval that contains each query point.",
            "If multiple intervals contain the same query point, return the one with the smallest start value.",
            "Return a list of interval indices for each query point."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_containing_intervals(intervals: List[List[int]], queries: List[int]) -> List[int]:\n    interval_indices = []\n    \n    for query in queries:\n        containing_interval_idx = -1\n        min_start = float('inf')\n        for i, interval in enumerate(intervals):\n            if interval[0] <= query <= interval[1] and interval[0] < min_start:\n                containing_interval_idx = i\n                min_start = interval[0]\n        interval_indices.append(containing_interval_idx)\n        \n    return interval_indices"
    },
    {
        "function_name": "matrix_pair_sums",
        "file_name": "matrix_operations.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D list of integers.",
            "target_sum": "int - The target sum to be found in the matrix."
        },
        "objectives": [
            "Implement a function to find all unique pairs of elements in the matrix that sum up to the target sum.",
            "Ensure that the pairs are unique, i.e., (a, b) is the same as (b, a), and (a, a) is only counted once.",
            "Return a list of tuples, where each tuple contains a pair of elements that sum up to the target sum."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def matrix_pair_sums(matrix: List[List[int]], target_sum: int) -> List[Tuple[int, int]]:\n    seen = set()\n    pairs = set()\n    \n    for row in matrix:\n        for num in row:\n            complement = target_sum - num\n            if complement in seen:\n                pair = tuple(sorted((num, complement)))\n                pairs.add(pair)\n            seen.add(num)\n    \n    return list(pairs)"
    },
    {
        "function_name": "shortest_route",
        "file_name": "route_finding.py",
        "parameters": {
            "routes": "List[List[int]] - A list of routes, where each route is a list of node IDs.",
            "start_node": "int - The starting node for the route.",
            "end_node": "int - The ending node for the route."
        },
        "objectives": [
            "Implement a function to find the shortest route from the start node to the end node.",
            "Use a breadth-first search (BFS) algorithm to explore the graph.",
            "Return the shortest route as a list of node IDs, or an empty list if no route exists."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def shortest_route(routes: List[List[int]], start_node: int, end_node: int) -> List[int]:\n    graph = {}\n    for route in routes:\n        for i in range(len(route) - 1):\n            if route[i] not in graph:\n                graph[route[i]] = []\n            graph[route[i]].append(route[i + 1])\n    \n    queue = deque([[start_node]])\n    seen = set()\n    \n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node == end_node:\n            return path\n        if node not in seen:\n            seen.add(node)\n            if node in graph:\n                for neighbor in graph[node]:\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append(new_path)\n    \n    return []"
    },
    {
        "function_name": "meeting_scheduler",
        "file_name": "scheduler.py",
        "parameters": {
            "num_hours": "int",
            "numRooms": "int",
            "meetings": "List[List[int]] (A list of meeting intervals where each interval is a list of two integers representing the start and end time of the meeting)",
            "capacity": "int (The maximum capacity of each room)"
        },
        "objectives": [
            "Assign meetings to rooms such that the maximum number of meetings is accommodated.",
            "Ensure that no room exceeds its capacity at any time.",
            "Minimize the number of rooms used."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def meeting_scheduler(num_hours: int, numRooms: int, meetings: List[List[int]], capacity: int) -> List[List[int]]:\n    meetings.sort(key=lambda x: x[0])\n    rooms = [[] for _ in range(numRooms)]\n    for meeting in meetings:\n        assigned = False\n        for room in rooms:\n            if not room or room[-1][1] <= meeting[0]:\n                room.append(meeting)\n                assigned = True\n                break\n        if not assigned:\n            min_end_time = float('inf')\n            min_end_time_room = -1\n            for i, room in enumerate(rooms):\n                if room and room[-1][1] < min_end_time:\n                    min_end_time = room[-1][1]\n                    min_end_time_room = i\n            if min_end_time_room != -1:\n                rooms[min_end_time_room].append(meeting)\n    return rooms"
    },
    {
        "function_name": "knapsack_solver",
        "file_name": "knapsack_solver.py",
        "parameters": {},
        "objectives": [
            "Implement a function that solves the 0/1 knapsack problem with a given capacity.",
            "Maximize the total profit while not exceeding the capacity.",
            "Use dynamic programming to optimize the solution."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def knapsack_solver(items: List[str], capacity: int, profits: List[int]) -> List[str]:\n    n = len(profits)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if w < i:\n                dp[i][w] = dp[i - 1][w]\n            else:\n                dp[i][w] = max(dp[i - 1][w], profits[i - 1] + dp[i - 1][w - i])\n    result = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i - 1][w]:\n            result.append(items[i - 1])\n            w -= i\n    return result"
    },
    {
        "function_name": "simulate_game",
        "file_name": "game_simulator.py",
        "parameters": {
            "players": "List[Tuple[str, int, int]] (A list of tuples containing player name, health, and score)",
            "rounds": "int (The number of rounds to simulate)"
        },
        "objectives": [
            "Create a function to simulate rounds of a game where players take turns to either attack or heal.",
            "Each player can attack another player, reducing their health by a random amount between 10 and 20.",
            "Each player can also heal themselves, increasing their health by a random amount between 5 and 10.",
            "The function should return a list of tuples containing the final state of each player (name, health, score)."
        ],
        "import_lines": [
            "import random",
            "from typing import List, Tuple"
        ],
        "function_def": "def simulate_game(players: List[Tuple[str, int, int]], rounds: int) -> List[Tuple[str, int, int]]:\n    for _ in range(rounds):\n        for i, (name, health, score) in enumerate(players):\n            if health > 0:\n                action = random.choice([\"attack\", \"heal\"])\n                if action == \"attack\":\n                    target = random.choice([j for j, (_, h, _) in enumerate(players) if j != i and h > 0])\n                    players[target] = (players[target][0], players[target][1] - random.randint(10, 20), players[target][2])\n                else:\n                    players[i] = (name, health + random.randint(5, 10), score)\n                    \n    return players"
    },
    {
        "function_name": "k_means_clustering",
        "file_name": "clustering.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D grid of integers)",
            "k": "int (The number of clusters to form)"
        },
        "objectives": [
            "Create a function to cluster the grid into k clusters using the k-means algorithm.",
            "The grid represents a world where each cell has a certain resource value.",
            "Each cluster should have a centroid, and cells should be assigned to the cluster with the closest centroid.",
            "The function should return a 2D list where each cell is labeled with its cluster index."
        ],
        "import_lines": [
            "import random",
            "from typing import List"
        ],
        "function_def": "def k_means_clustering(grid: List[List[int]], k: int) -> List[List[int]]:\n    rows, cols = len(grid), len(grid[0])\n    centroids = [(random.randint(0, rows-1), random.randint(0, cols-1)) for _ in range(k)]\n    clusters = [[-1 for _ in range(cols)] for _ in range(rows)]\n    \n    while True:\n        for i in range(rows):\n            for j in range(cols):\n                min_distance = float(\"inf\")\n                closest_centroid = -1\n                for centroid_index, (x, y) in enumerate(centroids):\n                    distance = abs(i-x) + abs(j-y)\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_centroid = centroid_index\n                clusters[i][j] = closest_centroid\n        \n        new_centroids = [[0, 0] for _ in range(k)]\n        counts = [0] * k\n        for i in range(rows):\n            for j in range(cols):\n                cluster_index = clusters[i][j]\n                new_centroids[cluster_index][0] += i\n                new_centroids[cluster_index][1] += j\n                counts[cluster_index] += 1\n        \n        for i in range(k):\n            new_centroids[i][0] //= counts[i]\n            new_centroids[i][1] //= counts[i]\n        \n        if new_centroids == centroids:\n            break\n        \n        centroids = new_centroids\n    \n    return clusters"
    },
    {
        "function_name": "find_pattern",
        "file_name": "pattern_matching.py",
        "parameters": {
            "strings": "List[str] (A list of strings)",
            "pattern": "str (A pattern string)"
        },
        "objectives": [
            "Create a function to find all occurrences of a given pattern in a list of strings.",
            "The pattern can contain special characters '*' (matches any sequence of characters) and '?' (matches any single character).",
            "The function should return a list of tuples containing the string index and the start position of the pattern in the string."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def find_pattern(strings: List[str], pattern: str) -> List[Tuple[int, int]]:\n    result = []\n    for i, string in enumerate(strings):\n        dp = [[False] * (len(pattern) + 1) for _ in range(len(string) + 1)]\n        dp[0][0] = True\n        for j in range(1, len(pattern) + 1):\n            if pattern[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, len(string) + 1):\n            for j in range(1, len(pattern) + 1):\n                if pattern[j-1] in {string[i-1], '?'}:\n                    dp[i][j] = dp[i-1][j-1]\n                elif pattern[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n        \n        for i in range(1, len(string) + 1):\n            if dp[i][len(pattern)]:\n                result.append((i-1, i-len(pattern)))\n    \n    return result"
    },
    {
        "function_name": "aho_corasick_search",
        "file_name": "string_search.py",
        "parameters": {
            "text": "str (The input text)",
            "patterns": "List[str] (A list of patterns to search for)"
        },
        "objectives": [
            "Implement the Aho-Corasick string matching algorithm to find all occurrences of the patterns in the text.",
            "Build a trie of the patterns and use it to efficiently search the text.",
            "Return a list of tuples containing the pattern and its starting index in the text."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def aho_corasick_search(text: str, patterns: List[str]) -> List[tuple]:\n    trie = {}\n    for pattern in patterns:\n        node = trie\n        for char in pattern:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = pattern\n    \n    result = []\n    for i in range(len(text)):\n        node = trie\n        for j in range(i, len(text)):\n            if text[j] not in node:\n                break\n            node = node[text[j]]\n            if '$' in node:\n                result.append((node['$'], i))\n    \n    return result"
    },
    {
        "function_name": "calculate_polygon_area",
        "file_name": "geometry.py",
        "parameters": {
            "vertices": "List[List[float]] - A list of 2D coordinates representing the vertices of a polygon.",
            "n": "int - The number of sides of the polygon."
        },
        "objectives": [
            "Calculate the area of a polygon using the Shoelace formula.",
            "Separate the x and y coordinates of the vertices for easier computation.",
            "Check for edge cases such as a polygon with less than 3 vertices."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def calculate_polygon_area(vertices: List[List[float]], n: int) -> float:\n    if n < 3:\n        return 0  # A polygon must have at least 3 vertices\n    \n    x_coords = [v[0] for v in vertices]\n    y_coords = [v[1] for v in vertices]\n    \n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += x_coords[i] * y_coords[j]\n        area -= x_coords[j] * y_coords[i]\n    \n    return abs(area) / 2.0"
    },
    {
        "function_name": "calculate_eigen",
        "file_name": "linear_algebra.py",
        "parameters": {
            "matrix": "List[List[float]] - A 2D list of numbers representing a matrix.",
            "k": "int - The number of eigenvalues to compute."
        },
        "objectives": [
            "Calculate the first k eigenvectors and eigenvalues of a matrix using the Power Iteration method.",
            "Normalize the eigenvectors to have a unit length.",
            "Handle edge cases such as a non-square matrix or an empty matrix."
        ],
        "import_lines": [
            "import numpy as np",
            "from typing import List"
        ],
        "function_def": "def calculate_eigen(matrix: List[List[float]], k: int) -> List[List[float]]:\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return []  # Handle empty or non-square matrices\n    \n    matrix = np.array(matrix)\n    n = len(matrix)\n    eigenvectors = []\n    \n    for _ in range(k):\n        vector = np.random.rand(n)\n        vector /= np.linalg.norm(vector)\n        \n        for _ in range(100):  # Number of iterations\n            new_vector = np.dot(matrix, vector)\n            eigenvalue = np.dot(new_vector, vector)\n            new_vector /= np.linalg.norm(new_vector)\n            if np.allclose(vector, new_vector):\n                break\n            vector = new_vector\n        \n        eigenvectors.append(vector.tolist())\n    \n    return eigenvectors"
    },
    {
        "function_name": "max_overlap_interval",
        "file_name": "interval_constructor.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] - A list of intervals."
        },
        "objectives": [
            "Find the interval with the maximum overlap (i.e., the one that overlaps with the most other intervals).",
            "Handle edge cases such as an empty list or no overlap between intervals.",
            "Return the interval with the maximum overlap and the number of overlapping intervals."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def max_overlap_interval(intervals: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], int]:\n    if not intervals:\n        return None, 0\n    \n    intervals.sort(key=lambda x: x[0])\n    max_overlap = 0\n    max_overlap_interval = None\n    \n    for i, interval in enumerate(intervals):\n        overlaps = 0\n        for j in range(i + 1, len(intervals)):\n            if intervals[j][0] < interval[1]:\n                overlaps += 1\n            else:\n                break\n        if overlaps > max_overlap:\n            max_overlap = overlaps\n            max_overlap_interval = interval\n    \n    return max_overlap_interval, max_overlap"
    },
    {
        "function_name": "activity_scheduler",
        "file_name": "scheduler.py",
        "parameters": {
            "nums": "List[int] - A list of integers representing the cost of each activity.",
            "days": "int - The number of days to schedule the activities."
        },
        "objectives": [
            "Group consecutive activities together if they have the same cost.",
            "Find the minimum number of groups required to schedule all activities.",
            "Determine the maximum cost of each group.",
            "Return the maximum cost of each group and the corresponding activities."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from itertools import groupby"
        ],
        "function_def": "def activity_scheduler(nums: List[int], days: int) -> Dict[int, List[int]]:\n    groups = []\n    for key, group in groupby(nums):\n        groups.append(list(group))\n    \n    group_costs = {i: max(group) for i, group in enumerate(groups)}\n    \n    scheduled_groups = {}\n    for i, cost in group_costs.items():\n        scheduled_groups[cost] = groups[i]\n    \n    return dict(sorted(scheduled_groups.items(), reverse=True))"
    },
    {
        "function_name": "negative_cycle_detector",
        "file_name": "cycle_detector.py",
        "parameters": {
            "edges": "List[Tuple[int, int, int]] - A list of tuples representing the source, destination, and weight of each edge.",
            "vertices": "int - The number of vertices in the graph."
        },
        "objectives": [
            "Use Bellman-Ford algorithm to detect negative cycles in the graph.",
            "Return the shortest distances from all vertices to all other vertices.",
            "Identify the vertices that are part of a negative cycle."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def negative_cycle_detector(edges: List[Tuple[int, int, int]], vertices: int) -> Tuple[List[List[int]], List[int]]:\n    distances = [[float('inf')]*vertices for _ in range(vertices)]\n    \n    for _ in range(vertices-1):\n        for u, v, w in edges:\n            distances[u][v] = min(distances[u][v], distances[u][u] + w)\n    \n    negative_cycle_vertices = []\n    for u, v, w in edges:\n        if distances[u][v] > distances[u][u] + w:\n            distances[u][v] = distances[u][u] + w\n            negative_cycle_vertices.append(v)\n    \n    return distances, negative_cycle_vertices"
    },
    {
        "function_name": "radix_sort",
        "file_name": "radix_sort.py",
        "parameters": {
            "strings": "List[str] - A list of strings to be sorted."
        },
        "objectives": [
            "Use Radix Sort to sort the strings lexicographically.",
            "Determine the maximum length of the strings.",
            "Return the sorted list of strings."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def radix_sort(strings: List[str]) -> List[str]:\n    max_len = max(len(s) for s in strings)\n    strings = [s.ljust(max_len) for s in strings]\n    \n    for i in range(max_len-1, -1, -1):\n        buckets = [[] for _ in range(256)]\n        for s in strings:\n            buckets[ord(s[i])].append(s)\n        strings = [s for bucket in buckets for s in bucket]\n    \n    return [s.lstrip() for s in strings]"
    },
    {
        "function_name": "moving_average_filter",
        "file_name": "time_series_util.py",
        "parameters": {
            "series": "List[float] (Time series data)",
            "window_size": "int (Size of the sliding window)"
        },
        "objectives": [
            "Apply a moving average filter to the time series data using a sliding window approach.",
            "Calculate the moving average for each window while handling edge cases (e.g., the first and last windows).",
            "Return the filtered time series data."
        ],
        "import_lines": [],
        "function_def": "def moving_average_filter(series, window_size):\n    filtered_series = []\n    \n    for i in range(len(series) - window_size + 1):\n        window = series[i:i + window_size]\n        avg = sum(window) / window_size\n        filtered_series.append(avg)\n    \n    return filtered_series"
    },
    {
        "function_name": "newton_raphson_root_finder",
        "file_name": "root_finder.py",
        "parameters": {
            "expression": "str (A mathematical expression involving operators +, -, *, /)",
            "max_iterations": "int (The maximum number of iterations for the Newton-Raphson method)"
        },
        "objectives": [
            "Implement the Newton-Raphson method to find the roots of the given mathematical expression.",
            "Use a symbolic differentiation approach to compute the derivative of the expression.",
            "Return the approximate root of the expression along with the number of iterations performed."
        ],
        "import_lines": [
            "import sympy as sp"
        ],
        "function_def": "def newton_raphson_root_finder(expression, max_iterations):\n    x = sp.symbols('x')\n    f = sp.sympify(expression)\n    f_prime = sp.diff(f, x)\n    \n    x_value = 1.0\n    for i in range(max_iterations):\n        x_next = x_value - f.subs(x, x_value) / f_prime.subs(x, x_value)\n        if abs(x_next - x_value) < 1e-6:\n            break\n        x_value = x_next\n    \n    return x_value, i + 1"
    },
    {
        "function_name": "rle_compress",
        "file_name": "string_compressor.py",
        "parameters": {
            "text": "str (A string to be compressed)"
        },
        "objectives": [
            "Compress the input string using Run-Length Encoding (RLE).",
            "Replace each sequence of repeated characters with the character and its count.",
            "Return the compressed string."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def rle_compress(text: str) -> str:\n    if not text:\n        return \"\"\n    \n    compressed = []\n    count = 1\n    \n    for i in range(1, len(text)):\n        if text[i] == text[i - 1]:\n            count += 1\n        else:\n            compressed.append(text[i - 1] + str(count))\n            count = 1\n    \n    compressed.append(text[-1] + str(count))\n    \n    return \"\".join(compressed)"
    },
    {
        "function_name": "max_histogram_area",
        "file_name": "histogram_processor.py",
        "parameters": {
            "arr": "List[int] (A list of integers representing a histogram)"
        },
        "objectives": [
            "Find the maximum area of a rectangle that can be formed using the histogram bars.",
            "Ensure that the rectangle's width is equal to the number of bars used to form it.",
            "Return the maximum area."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_histogram_area(arr: List[int]) -> int:\n    stack = []\n    max_area = 0\n    \n    for i in range(len(arr)):\n        while stack and arr[stack[-1]] > arr[i]:\n            height = arr[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    \n    while stack:\n        height = arr[stack.pop()]\n        width = len(arr) if not stack else len(arr) - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    \n    return max_area"
    },
    {
        "function_name": "schedule_tasks",
        "file_name": "scheduler.py",
        "parameters": {
            "schedule": "List[List[int]] - A 2D list representing a schedule where each sublist contains a task's start time, end time, and duration.",
            "num_rooms": "int - The number of rooms available for tasks."
        },
        "objectives": [
            "Schedule tasks in the given schedule such that the number of tasks being executed at the same time is maximized.",
            "Ensure that no task is scheduled before its start time and after its end time, and all tasks are executed within their duration.",
            "Use dynamic programming to minimize the time complexity."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def schedule_tasks(schedule: List[List[int]], num_rooms: int) -> int:\n    schedule.sort(key=lambda x: x[0])\n    dp = [[0] * (num_rooms + 1) for _ in range(len(schedule) + 1)]\n    \n    for i in range(1, len(schedule) + 1):\n        for j in range(1, num_rooms + 1):\n            task_start, task_end, duration = schedule[i - 1]\n            if j >= 1 and dp[i - 1][j - 1] >= task_start and task_start + duration <= task_end:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[-1][-1]"
    },
    {
        "function_name": "word_segmentation",
        "file_name": "word_segmenter.py",
        "parameters": {
            "text": "str - The input text to process.",
            "dictionary": "List[str] - A list of valid words."
        },
        "objectives": [
            "Perform word segmentation on the given text by matching words in the dictionary.",
            "Ensure that the segmentation is optimal; i.e., the minimum number of words is used to cover the text.",
            "Return the segmented text."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def word_segmentation(text: str, dictionary: List[str]) -> str:\n    n = len(text)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and text[j:i] in dictionary:\n                dp[i] = True\n                break\n    \n    i = n\n    result = []\n    \n    while i > 0:\n        for j in range(i):\n            if dp[j] and text[j:i] in dictionary:\n                result.append(text[j:i])\n                i = j\n                break\n    \n    return ' '.join(result[::-1])"
    },
    {
        "function_name": "k_largest_numbers",
        "file_name": "priority_queue.py",
        "parameters": {
            "sequence": "List[int] - A list of integers representing a sequence of numbers.",
            "k": "int - The number of largest numbers to find in the sequence."
        },
        "objectives": [
            "Find the k largest numbers in the given sequence using a priority queue.",
            "Ensure that the priority queue always contains the k largest numbers seen so far.",
            "Return the k largest numbers found."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def k_largest_numbers(sequence: List[int], k: int) -> List[int]:\n    pq = []\n    \n    for num in sequence:\n        if len(pq) < k:\n            heapq.heappush(pq, num)\n        elif num > pq[0]:\n            heapq.heappop(pq)\n            heapq.heappush(pq, num)\n    \n    return sorted(pq, reverse=True)"
    },
    {
        "function_name": "subarray_products",
        "file_name": "subarray_calculator.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The size of the subarray)"
        },
        "objectives": [
            "Find all subarrays of size k in the given list of integers.",
            "For each subarray, calculate the product of its elements.",
            "Return a list of tuples, where each tuple contains the subarray and its product."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def subarray_products(nums: List[int], k: int) -> List[Tuple[List[int], int]]:\n    products = []\n    for i in range(len(nums) - k + 1):\n        product = 1\n        subarray = nums[i:i+k]\n        for num in subarray:\n            product *= num\n        products.append((subarray, product))\n    return products"
    },
    {
        "function_name": "nearest_neighbors",
        "file_name": "neighborhood_finder.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The number of nearest neighbors to find)"
        },
        "objectives": [
            "Find the k nearest neighbors to a given number in a list of integers.",
            "The distance between two numbers is calculated as their absolute difference.",
            "Return a list of tuples, where each tuple contains a nearest neighbor and its distance."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def nearest_neighbors(nums: List[int], k: int) -> List[Tuple[int, int]]:\n    distances = []\n    for num in nums:\n        distance = abs(num - nums[0])\n        distances.append((num, distance))\n    \n    distances.sort(key=lambda x: x[1])\n    return distances[:k]"
    },
    {
        "function_name": "canny_edge_detection",
        "file_name": "canny_edge.py",
        "parameters": {
            "image": "numpy.ndarray (A 2D image represented as a numpy array)",
            "threshold": "int (The threshold value for edge detection)"
        },
        "objectives": [
            "Implement the Canny edge detection algorithm to detect edges in the given image.",
            "Apply non-maximum suppression to thin the edges.",
            "Return the edge map."
        ],
        "import_lines": [
            "import numpy as np",
            "from scipy import signal"
        ],
        "function_def": "def canny_edge_detection(image: np.ndarray, threshold: int) -> np.ndarray:\n    sigma = 2\n    kernel_size = 5\n    \n    # Gaussian filter\n    gaussian_kernel = np.zeros((kernel_size, kernel_size))\n    for i in range(kernel_size):\n        for j in range(kernel_size):\n            x = i - kernel_size // 2\n            y = j - kernel_size // 2\n            gaussian_kernel[i, j] = np.exp(-(x ** 2 + y ** 2) / (2 * sigma ** 2))\n    gaussian_kernel /= gaussian_kernel.sum()\n    smoothed_image = signal.convolve2d(image, gaussian_kernel, mode='same')\n    \n    # Sobel operators\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    sobel_y = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]])\n    gradient_x = signal.convolve2d(smoothed_image, sobel_x, mode='same')\n    gradient_y = signal.convolve2d(smoothed_image, sobel_y, mode='same')\n    gradient_magnitude = np.sqrt(gradient_x ** 2 + gradient_y ** 2)\n    gradient_direction = np.arctan2(gradient_y, gradient_x)\n    \n    # Non-maximum suppression\n    edge_map = np.zeros(image.shape)\n    for i in range(1, image.shape[0] - 1):\n        for j in range(1, image.shape[1] - 1):\n            if gradient_magnitude[i, j] < threshold:\n                continue\n            direction = gradient_direction[i, j]\n            if (0 <= direction < np.pi / 4) or (7 * np.pi / 4 <= direction <= 2 * np.pi):\n                if gradient_magnitude[i, j] >= gradient_magnitude[i, j - 1] and gradient_magnitude[i, j] >= gradient_magnitude[i, j + 1]:\n                    edge_map[i, j] = 255\n            elif (np.pi / 4 <= direction < 3 * np.pi / 4) or (5 * np.pi / 4 <= direction < 7 * np.pi / 4):\n                if gradient_magnitude[i, j] >= gradient_magnitude[i + 1, j - 1] and gradient_magnitude[i, j] >= gradient_magnitude[i - 1, j + 1]:\n                    edge_map[i, j] = 255\n            elif (3 * np.pi / 4 <= direction < 5 * np.pi / 4):\n                if gradient_magnitude[i, j] >= gradient_magnitude[i + 1, j] and gradient_magnitude[i, j] >= gradient_magnitude[i - 1, j]:\n                    edge_map[i, j] = 255\n            else:\n                if gradient_magnitude[i, j] >= gradient_magnitude[i - 1, j - 1] and gradient_magnitude[i, j] >= gradient_magnitude[i + 1, j + 1]:\n                    edge_map[i, j] = 255\n    \n    return edge_map"
    },
    {
        "function_name": "weighted_kendall_tau",
        "file_name": "weighted_kendall_tau.py",
        "parameters": {
            "ranks": "List[int] (A list of ranks for a given set of items)",
            "weights": "List[float] (A list of weights for the items)"
        },
        "objectives": [
            "Calculate the weighted Kendall's tau correlation coefficient between the ranks and weights.",
            "Handle ties in the ranks and weights correctly.",
            "Return the correlation coefficient."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def weighted_kendall_tau(ranks: List[int], weights: List[float]) -> float:\n    n = len(ranks)\n    concordant_pairs = 0\n    discordant_pairs = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            rank_diff = ranks[i] - ranks[j]\n            weight_diff = weights[i] - weights[j]\n            \n            if rank_diff * weight_diff > 0:\n                concordant_pairs += 1\n            elif rank_diff * weight_diff < 0:\n                discordant_pairs += 1\n    \n    tau = (concordant_pairs - discordant_pairs) / (n * (n - 1) / 2)\n    return tau"
    },
    {
        "function_name": "kmer_frequencies",
        "file_name": "kmer_frequencies.py",
        "parameters": {
            "sequence": "str (A biological sequence such as DNA, RNA, or protein)",
            "k": "int (The length of the k-mers to consider)"
        },
        "objectives": [
            "Generate all unique k-mers from the given sequence.",
            "Calculate the frequency of each k-mer.",
            "Return a dictionary where the keys are the k-mers and the values are their frequencies."
        ],
        "import_lines": [
            "from typing import Dict"
        ],
        "function_def": "def kmer_frequencies(sequence: str, k: int) -> Dict[str, int]:\n    kmer_freq = {}\n    \n    for i in range(len(sequence) - k + 1):\n        kmer = sequence[i:i+k]\n        if kmer in kmer_freq:\n            kmer_freq[kmer] += 1\n        else:\n            kmer_freq[kmer] = 1\n    \n    return kmer_freq"
    },
    {
        "function_name": "is_sub_matrix_sum",
        "file_name": "sub_matrix_sum.py",
        "parameters": {
            "`matrix": "List[List[int]]` (A 2D list of integers representing a matrix)",
            "`target": "int` (The target sum to find)"
        },
        "objectives": [
            "Implement a function that checks if there exists a sub-matrix in the given matrix with a sum equal to the target sum.",
            "Ensure that the function correctly handles cases with zero or negative numbers in the matrix.",
            "Return a boolean indicating whether such a sub-matrix exists."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def is_sub_matrix_sum(matrix: List[List[int]], target: int) -> bool:\n    rows, cols = len(matrix), len(matrix[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] + matrix[i-1][j-1]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for end_col in range(j, cols + 1):\n                    sub_matrix_sum = prefix_sum[k][end_col] - prefix_sum[k][j-1] - prefix_sum[i-1][end_col] + prefix_sum[i-1][j-1]\n                    if sub_matrix_sum == target:\n                        return True\n    \n    return False"
    },
    {
        "function_name": "is_anagram_group",
        "file_name": "anagram_group.py",
        "parameters": {
            "`strings": "List[str]` (A list of strings to check for anagrams)",
            "`threshold": "int` (The minimum number of anagrams required)"
        },
        "objectives": [
            "Implement a function that checks if there exists a group of at least 'threshold' strings in the given list that are anagrams of each other.",
            "Ensure that the function correctly handles cases with duplicate strings or anagrams of different lengths.",
            "Return a boolean indicating whether such a group exists."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def is_anagram_group(strings: List[str], threshold: int) -> bool:\n    anagram_map = defaultdict(list)\n    \n    for string in strings:\n        sorted_string = \"\".join(sorted(string))\n        anagram_map[sorted_string].append(string)\n    \n    for anagrams in anagram_map.values():\n        if len(anagrams) >= threshold:\n            return True\n    \n    return False"
    },
    {
        "function_name": "simulate_water_pouring",
        "file_name": "water_pouring.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid of integers representing the height of each cell.",
            "water_height": "int - The water height that needs to be poured."
        },
        "objectives": [
            "Simulate pouring water on the grid from the top, considering gravity, until the water height reaches the specified water_height.",
            "Ensure that the water poured fills the grid in a way that minimizes the height difference between adjacent cells.",
            "Return the final state of the grid."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def simulate_water_pouring(grid: List[List[int]], water_height: int) -> List[List[int]]:\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    queue = []\n    \n    # Add all border cells to the queue\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 or j == 0 or i == rows - 1 or j == cols - 1:\n                queue.append((i, j, grid[i][j]))\n                visited[i][j] = True\n    \n    # Process cells in the queue\n    while queue:\n        x, y, height = queue.pop(0)\n        \n        # Try to pour water to the current cell\n        if height < water_height:\n            grid[x][y] = water_height\n        \n        # Spread water to neighboring cells\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            \n            # Check if neighbor is within grid and not visited\n            if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny]:\n                queue.append((nx, ny, min(grid[x][y], grid[nx][ny])))\n                visited[nx][ny] = True\n    \n    return grid"
    },
    {
        "function_name": "calculate_account_balances",
        "file_name": "account_balances.py",
        "parameters": {
            "transactions": "List[Tuple[int, int, str]] - A list of transactions where each transaction is a tuple containing the transaction id, account number, and transaction type (either 'debit' or 'credit')."
        },
        "objectives": [
            "Implement a function to calculate the total balance for each account based on the transactions.",
            "Ensure that the transaction type ('debit' or 'credit') correctly updates the account balance.",
            "Return a dictionary where the keys are the account numbers and the values are their respective balances."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict"
        ],
        "function_def": "def calculate_account_balances(transactions: List[Tuple[int, int, str]]) -> Dict[int, int]:\n    balances = {}\n    \n    for transaction_id, account_number, transaction_type in transactions:\n        amount = 1\n        \n        if transaction_type == 'debit':\n            amount = -amount\n        \n        balances[account_number] = balances.get(account_number, 0) + amount\n    \n    return balances"
    },
    {
        "function_name": "find_keyword_windows",
        "file_name": "text_analytics.py",
        "parameters": {
            "text": "str (The input text)",
            "keywords": "List[str] (A list of keywords to search for)",
            "max_distance": "int (The maximum allowed distance between keywords)"
        },
        "objectives": [
            "Find all occurrences of the keywords in the input text.",
            "Group the occurrences by the distance between keywords (windowing).",
            "Return a list of windows where the distance between keywords does not exceed the maximum allowed distance."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_keyword_windows(text: str, keywords: List[str], max_distance: int) -> list:\n    tokenized_text = text.split()\n    keyword_indices = [set() for _ in range(len(keywords))]\n    windows = []\n    \n    for i, token in enumerate(tokenized_text):\n        for j, keyword in enumerate(keywords):\n            if token.lower() == keyword.lower():\n                keyword_indices[j].add(i)\n    \n    for i in range(len(keywords) - 1):\n        for j in keyword_indices[i]:\n            for k in keyword_indices[i + 1]:\n                if abs(j - k) <= max_distance:\n                    window_start = min(j, k) - 1\n                    window_end = max(j, k) + 2\n                    windows.append(tokenized_text[window_start:window_end])\n    \n    return windows"
    },
    {
        "function_name": "find_connected_components_in_gene_network",
        "file_name": "bioinformatics.py",
        "parameters": {
            "genes": "List[str] (A list of gene names)",
            "interactions": "List[List[str]] (A list of gene interactions)"
        },
        "objectives": [
            "Construct a gene interaction network from the given interactions.",
            "Find the connected components in the network (clusters of interacting genes).",
            "Return a list of connected components."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def find_connected_components_in_gene_network(genes: List[str], interactions: List[List[str]]) -> list:\n    graph = defaultdict(list)\n    visited = set()\n    components = []\n    \n    for interaction in interactions:\n        graph[interaction[0]].append(interaction[1])\n        graph[interaction[1]].append(interaction[0])\n    \n    for gene in genes:\n        if gene not in visited:\n            component = []\n            queue = [gene]\n            visited.add(gene)\n            \n            while queue:\n                node = queue.pop(0)\n                component.append(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n                        visited.add(neighbor)\n            \n            components.append(component)\n    \n    return components"
    },
    {
        "function_name": "find_similar_vectors",
        "file_name": "vector_processing.py",
        "parameters": {
            "vectors": "List[List[float]] (A list of vectors)",
            "threshold": "float (The cosine similarity threshold)"
        },
        "objectives": [
            "Calculate the cosine similarity between each pair of vectors.",
            "Identify pairs of vectors with a cosine similarity above the threshold.",
            "Return a list of pairs of vectors that are similar."
        ],
        "import_lines": [
            "from typing import List",
            "from math import sqrt"
        ],
        "function_def": "def find_similar_vectors(vectors: List[List[float]], threshold: float) -> list:\n    similar_pairs = []\n    \n    for i in range(len(vectors)):\n        for j in range(i + 1, len(vectors)):\n            dot_product = sum(x * y for x, y in zip(vectors[i], vectors[j]))\n            magnitude_i = sqrt(sum(x ** 2 for x in vectors[i]))\n            magnitude_j = sqrt(sum(x ** 2 for x in vectors[j]))\n            cosine_similarity = dot_product / (magnitude_i * magnitude_j)\n            \n            if cosine_similarity >= threshold:\n                similar_pairs.append((vectors[i], vectors[j]))\n    \n    return similar_pairs"
    },
    {
        "function_name": "lcs",
        "file_name": "lcs.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of integer sequences)",
            "k": "int (The length of the subsequence)"
        },
        "objectives": [
            "Implement the Longest Common Subsequence (LCS) algorithm to find the LCS among all sequences.",
            "Use dynamic programming to build a 2D table of lengths of common subsequences.",
            "Return the LCS as a list of integers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def lcs(sequences: List[List[int]], k: int) -> List[int]:\n    if not sequences:\n        return []\n    \n    lengths = [[0] * (k + 1) for _ in range(len(sequences[0]) + 1)]\n    \n    for seq in sequences[1:]:\n        for i in range(1, len(sequences[0]) + 1):\n            for j in range(1, k + 1):\n                if sequences[0][i - 1] == seq[j - 1]:\n                    lengths[i][j] = lengths[i - 1][j - 1] + 1\n                else:\n                    lengths[i][j] = max(lengths[i - 1][j], lengths[i][j - 1])\n    \n    lcs = []\n    i, j = len(sequences[0]), k\n    while i > 0 and j > 0:\n        if sequences[0][i - 1] == sequences[1][j - 1]:\n            lcs.append(sequences[0][i - 1])\n            i -= 1\n            j -= 1\n        elif lengths[i - 1][j] > lengths[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return lcs[::-1]"
    },
    {
        "function_name": "histogram",
        "file_name": "histogram.py",
        "parameters": {
            "numbers": "List[float] (A list of floating point numbers)",
            "bins": "int (The number of bins for the histogram)"
        },
        "objectives": [
            "Implement the Histogram algorithm to bin the numbers into discrete ranges.",
            "Calculate the frequency of each bin.",
            "Return a dictionary with the bin ranges as keys and their frequencies as values."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def histogram(numbers: List[float], bins: int) -> Dict[str, int]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    bin_width = (max_num - min_num) / bins\n    \n    histogram_dict = {}\n    for i in range(bins):\n        bin_range = f'[{min_num + i * bin_width:.2f}, {min_num + (i + 1) * bin_width:.2f})'\n        histogram_dict[bin_range] = 0\n    \n    for num in numbers:\n        for i in range(bins):\n            if min_num + i * bin_width <= num < min_num + (i + 1) * bin_width:\n                histogram_dict[f'[{min_num + i * bin_width:.2f}, {min_num + (i + 1) * bin_width:.2f})'] += 1\n                break\n    \n    return histogram_dict"
    },
    {
        "function_name": "knn",
        "file_name": "knn.py",
        "parameters": {
            "points": "List[Tuple[float, float]] (A list of 2D points)",
            "k": "int (The number of nearest neighbors to find)"
        },
        "objectives": [
            "Implement the K-Nearest Neighbors (KNN) algorithm to find the k nearest neighbors to each point.",
            "Use a distance metric (e.g., Euclidean distance) to calculate the distance between points.",
            "Return a dictionary with the points as keys and their k nearest neighbors as values."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict",
            "import math"
        ],
        "function_def": "def knn(points: List[Tuple[float, float]], k: int) -> Dict[Tuple[float, float], List[Tuple[float, float]]]:\n    nearest_neighbors = {}\n    for point in points:\n        distances = []\n        for other_point in points:\n            if point == other_point:\n                continue\n            distance = math.sqrt((point[0] - other_point[0]) ** 2 + (point[1] - other_point[1]) ** 2)\n            distances.append((distance, other_point))\n        \n        distances.sort(key=lambda x: x[0])\n        nearest_neighbors[point] = [x[1] for x in distances[:k]]\n    \n    return nearest_neighbors"
    },
    {
        "function_name": "remove_punctuation",
        "file_name": "punctuation_remover.py",
        "parameters": {
            "text": "str (A string containing words and punctuation)"
        },
        "objectives": [
            "Implement a function that removes all punctuation from the given string.",
            "The function should return a list of words in the original order.",
            "Ensure that the function handles cases where the input string contains special characters or is empty."
        ],
        "import_lines": [
            "from typing import List",
            "import re"
        ],
        "function_def": "def remove_punctuation(text: str) -> List[str]:\n    return re.findall(r'\\b\\w+\\b', text)"
    },
    {
        "function_name": "task_scheduler",
        "file_name": "scheduler.py",
        "parameters": {
            "nums": "List[int] - A list of integers representing the cost of each task.",
            "dependencies": "Dict[int, List[int]] - A dictionary where each key represents a task and its corresponding value is a list of tasks that it depends on."
        },
        "objectives": [
            "Create a function to schedule tasks based on their dependencies and costs.",
            "Ensure that a task is only scheduled after all its dependencies have been scheduled.",
            "Determine the minimum total cost required to schedule all tasks.",
            "Return the minimum total cost and the order in which tasks should be scheduled."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from collections import defaultdict, deque"
        ],
        "function_def": "def task_scheduler(nums: List[int], dependencies: Dict[int, List[int]]) -> (int, List[int]):\n    graph = defaultdict(list)\n    in_degree = {i: 0 for i in range(len(nums))}\n    for i, deps in dependencies.items():\n        for dep in deps:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    queue = deque([i for i, degree in in_degree.items() if degree == 0])\n    order = []\n    total_cost = 0\n    \n    while queue:\n        task = queue.popleft()\n        total_cost += nums[task]\n        order.append(task)\n        for neighbor in graph[task]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(order) != len(nums):\n        raise ValueError(\"Circular dependency detected.\")\n    \n    return total_cost, order"
    },
    {
        "function_name": "calculate_gene_percentages",
        "file_name": "gene_analyzer.py",
        "parameters": {
            "genie_data": "Dict[str, List[int]] - A map of gene names to lists of their corresponding base pair counts.",
            "default_pairs": "int - A default base pair count to use for genes without data.",
            "min_pairs": "int - A minimum base pair count required for a gene to be considered significant.",
            "cutoff": "float - A percentage of total base pairs below which a gene is considered rare."
        },
        "objectives": [
            "Calculate the total base pairs across all genes in the genie_data dictionary.",
            "Use the total to calculate the percentage of base pairs accounted for by each gene and return a dictionary mapping genes to their percentages.",
            "Consider genes without data, assigning them the default base pair count, and exclude rare genes based on the given cutoff and min_pairs threshold.",
            "Ensure that genes with zero base pairs are still included in the output, with a percentage of 0."
        ],
        "import_lines": [
            "from typing import Dict, List"
        ],
        "function_def": "def calculate_gene_percentages(genie_data: Dict[str, List[int]], default_pairs: int, min_pairs: int, cutoff: float) -> Dict[str, float]:\n    total_pairs = sum(sum(pairs) for pairs in genie_data.values())\n    gene_percentages = {}\n    \n    for gene, pairs in genie_data.items():\n        if not pairs:\n            effective_pairs = default_pairs\n        else:\n            effective_pairs = sum(pairs)\n        \n        if effective_pairs < min_pairs:\n            continue\n        \n        percentage = (effective_pairs / total_pairs) * 100\n        \n        if percentage < cutoff:\n            continue\n        \n        gene_percentages[gene] = percentage\n    \n    for gene, pairs in genie_data.items():\n        if gene not in gene_percentages and (pairs or default_pairs >= min_pairs):\n            gene_percentages[gene] = 0\n    \n    return gene_percentages"
    },
    {
        "function_name": "calculate_average_winds",
        "file_name": "atmosphere_simulator.py",
        "parameters": {
            "aircraft_coords": "List[List[float]] - A 2D list of aircraft coordinates (latitude and longitude) on the planet's surface.",
            "wind_pattern": "Dict[tuple, List[float]] - A dictionary mapping grid cell coordinates (latitude and longitude) to lists of wind velocities in m/s.",
            "grid_size": "int - A grid size (latitude and longitude cells) for dividing the planet's surface."
        },
        "objectives": [
            "Calculate the number of grid cells covered by each aircraft based on its coordinates.",
            "Assign each aircraft to the grid cell that covers its coordinates, considering multiple assignments if an aircraft's coordinates span multiple cells.",
            "For each grid cell, calculate the weighted average wind velocity, where weights are the proportions of grid cells covered by each aircraft.",
            "Return a dictionary mapping grid cells to their corresponding weighted average wind velocities."
        ],
        "import_lines": [
            "from typing import List, Dict, Tuple"
        ],
        "function_def": "def calculate_average_winds(aircraft_coords: List[List[float]], wind_pattern: Dict[Tuple[float, float], List[float]], grid_size: int) -> Dict[Tuple[float, float], float]:\n    cell_assignments = {}\n    cell_winds = {}\n    \n    for i, (lat, lon) in enumerate(aircraft_coords):\n        cell_lat = int(lat * grid_size)\n        cell_lon = int(lon * grid_size)\n        cell_key = (cell_lat, cell_lon)\n        \n        if cell_key not in cell_assignments:\n            cell_assignments[cell_key] = []\n            cell_winds[cell_key] = [0, 0]\n        \n        cell_assignments[cell_key].append(i)\n    \n    for (cell_lat, cell_lon), aircraft_ids in cell_assignments.items():\n        winds = wind_pattern.get((cell_lat / grid_size, cell_lon / grid_size), [0, 0])\n        wind_velocity = (winds[0] ** 2 + winds[1] ** 2) ** 0.5\n        num_aircraft = len(aircraft_ids)\n        \n        cell_winds[(cell_lat, cell_lon)] = [wind_velocity / num_aircraft, num_aircraft]\n    \n    weighted_winds = {}\n    for (cell_lat, cell_lon), (wind_velocity, num_aircraft) in cell_winds.items():\n        weighted_winds[(cell_lat / grid_size, cell_lon / grid_size)] = wind_velocity * num_aircraft\n    \n    return weighted_winds"
    },
    {
        "function_name": "find_strong_connections",
        "file_name": "social_analyzer.py",
        "parameters": {
            "social_network": "Dict[int, List[int]] - A dictionary representing a social network, where each key maps to a list of friends.",
            "start_user": "int - An ID of a user to start traversing from.",
            "depth": "int - A maximum depth to explore in the social network.",
            "overlap": "int - A minimum overlap required between the set of users and their friends at each depth."
        },
        "objectives": [
            "Perform a breadth-first traversal of the social network to find strong connections between users.",
            "Identify sets of users at each depth with at least overlap friends in common and return these sets.",
            "Use a heuristic, such as the Jaccard similarity coefficient, to determine the similarity between sets of users."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import deque",
            "import math"
        ],
        "function_def": "def find_strong_connections(social_network: Dict[int, List[int]], start_user: int, depth: int, overlap: int) -> List[List[int]]:\n    strong_connections = []\n    queue = deque([(start_user, 0)])\n    seen_users = set()\n    \n    while queue:\n        user, current_depth = queue.popleft()\n        \n        if user in seen_users or current_depth > depth:\n            continue\n        \n        seen_users.add(user)\n        \n        friends = social_network.get(user, [])\n        queue.extend((friend, current_depth + 1) for friend in friends if friend not in seen_users)\n        \n        if current_depth > 0:\n            if current_depth == 1:\n                common_friends = set(friends)\n            else:\n                common_friends = set(social_network.get(user, []))\n                \n                for seen_user in seen_users:\n                    common_friends = common_friends.intersection(social_network.get(seen_user, []))\n            \n            if len(common_friends) >= overlap:\n                strong_connections.append(list(common_friends))\n    \n    return strong_connections"
    },
    {
        "function_name": "network_flow",
        "file_name": "network_flow.py",
        "parameters": {
            "`network`": "`Dict[str, List[str]]` - A dictionary representing a network of nodes and their neighbors.",
            "`source`": "`str` - The source node for the flow.",
            "`sink`": "`str` - The sink node for the flow.",
            "`capacity`": "`Dict[Tuple[str, str], int]` - A dictionary representing the capacity of each edge in the network."
        },
        "objectives": [
            "Implement the Ford-Fulkerson algorithm with the Edmonds-Karp implementation to find the maximum flow in the network.",
            "Ensure efficient augmentation path detection using Breadth-First Search (BFS) algorithm.",
            "Return the maximum flow value."
        ],
        "import_lines": [
            "from typing import Dict, List, Tuple",
            "from collections import deque"
        ],
        "function_def": "def network_flow(network: Dict[str, List[str]], source: str, sink: str, capacity: Dict[Tuple[str, str], int]) -> int:\n    flow = 0\n    parent = {}\n    max_flow = float('inf')\n    \n    while True:\n        queue = deque([source])\n        parent = {source: None}\n        \n        while queue and sink not in parent:\n            node = queue.popleft()\n            for neighbor in network.get(node, []):\n                residual_capacity = capacity.get((node, neighbor), 0) - flow\n                if residual_capacity > 0 and neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        if sink not in parent:\n            break\n        \n        path_flow = float('inf')\n        node = sink\n        while node is not source:\n            path_flow = min(path_flow, capacity.get((parent[node], node), 0) - flow)\n            node = parent[node]\n        \n        flow += path_flow\n        max_flow = min(max_flow, flow)\n        \n        node = sink\n        while node is not source:\n            capacity[(parent[node], node)] -= path_flow\n            capacity[(node, parent[node])] = capacity.get((node, parent[node]), 0) + path_flow\n            node = parent[node]\n    \n    return max_flow"
    },
    {
        "function_name": "trend_detection",
        "file_name": "trend_detection.py",
        "parameters": {
            "`time_series`": "`List[int]` - A time series of values.",
            "`window_size`": "`int` - The size of the window to consider for trend detection.",
            "`confidence`": "`float` - The confidence level for the trend detection."
        },
        "objectives": [
            "Implement the Mann-Kendall test to detect a trend in the time series.",
            "Use the Kendall tau statistic to measure the correlation between the time series and the time index.",
            "Return a boolean indicating whether a trend is detected."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np",
            "from scipy.stats import norm"
        ],
        "function_def": "def trend_detection(time_series: List[int], window_size: int, confidence: float) -> bool:\n    x = np.arange(len(time_series))\n    y = np.array(time_series)\n    \n    # Calculate the Kendall tau statistic\n    n = len(time_series)\n    s = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (x[i] - x[j]) * (y[i] - y[j]) > 0:\n                s += 1\n            elif (x[i] - x[j]) * (y[i] - y[j]) < 0:\n                s -= 1\n    \n    # Calculate the variance of the Kendall tau statistic\n    var_s = (n * (n - 1) * (2 * n + 5)) / 18\n    \n    # Calculate the standard normal statistic\n    z = (s - 1) / np.sqrt(var_s)\n    \n    # Calculate the p-value\n    p_value = 2 * (1 - norm.cdf(abs(z)))\n    \n    # Return whether a trend is detected\n    return p_value < (1 - confidence)"
    },
    {
        "function_name": "depth_first_search",
        "file_name": "tree_traversal.py",
        "parameters": {
            "tree": "List[List[int]] (A binary tree represented as an adjacency list)",
            "node": "int (The node to start the search from)"
        },
        "objectives": [
            "Implement a function to perform a depth-first search traversal of the binary tree.",
            "Use an iterative approach with a stack to traverse the tree.",
            "Return a list of nodes in the order they were visited."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def depth_first_search(tree: List[List[int]], node: int) -> List[int]:\n    visited = []\n    stack = [node]\n    \n    while stack:\n        current_node = stack.pop()\n        if current_node not in visited:\n            visited.append(current_node)\n            for child in reversed(tree[current_node]):\n                stack.append(child)\n    \n    return visited"
    },
    {
        "function_name": "k_max_values",
        "file_name": "heap.py",
        "parameters": {
            "values": "List[int] (A list of integers)",
            "k": "int (The number of maximum values to find)"
        },
        "objectives": [
            "Implement the Heap data structure to find the k maximum values in the list.",
            "Return the k maximum values."
        ],
        "import_lines": [
            "from typing import List",
            "import heapq"
        ],
        "function_def": "def k_max_values(values: List[int], k: int) -> List[int]:\n    max_heap = []\n    \n    for value in values:\n        if len(max_heap) < k:\n            heapq.heappush(max_heap, value)\n        elif value > max_heap[0]:\n            heapq.heappop(max_heap)\n            heapq.heappush(max_heap, value)\n    \n    return sorted(max_heap, reverse=True)"
    },
    {
        "function_name": "largest_submatrix",
        "file_name": "matrix_analysis.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "target": "int (The target sum)"
        },
        "objectives": [
            "Implement a function to find the largest sub-matrix with a sum less than or equal to the target sum.",
            "Use dynamic programming to build a prefix sum matrix.",
            "Return the size of the largest sub-matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def largest_submatrix(matrix: List[List[int]], target: int) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n    \n    max_size = 0\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i + 1, rows + 1):\n                for end_col in range(j + 1, cols + 1):\n                    submatrix_sum = prefix_sum[k][end_col] - prefix_sum[k][j] - prefix_sum[i][end_col] + prefix_sum[i][j]\n                    if submatrix_sum <= target:\n                        max_size = max(max_size, (k - i) * (end_col - j))\n    \n    return max_size"
    },
    {
        "function_name": "compress_text",
        "file_name": "lzw_compressor.py",
        "parameters": {
            "`text`": "`str` (The input text to be compressed)",
            "`dictionary_size`": "`int` (The size of the dictionary to use for compression)"
        },
        "objectives": [
            "Implement the LZW compression algorithm to compress the input text.",
            "Use a dictionary to store substrings and their corresponding codes.",
            "Return the compressed text as a list of codes."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def compress_text(text: str, dictionary_size: int) -> List[int]:\n    dictionary = {chr(i): i for i in range(dictionary_size)}\n    result = []\n    w = \"\"\n    \n    for c in text:\n        wc = w + c\n        if wc in dictionary:\n            w = wc\n        else:\n            result.append(dictionary[w])\n            dictionary[wc] = len(dictionary)\n            w = c\n    \n    if w:\n        result.append(dictionary[w])\n    \n    return result"
    },
    {
        "function_name": "dna_sequence_analyzer",
        "file_name": "dna_analyzer.py",
        "parameters": {
            "sequences": "List[str] (A list of DNA sequences)",
            "length": "int (The minimum length of the sequences to be considered)"
        },
        "objectives": [
            "Parse the input DNA sequences and filter out those that are shorter than the specified length.",
            "Count the occurrences of each unique DNA sequence and keep track of the longest sequence.",
            "Return a dictionary containing the count of each unique DNA sequence and the longest sequence found."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def dna_sequence_analyzer(sequences: List[str], length: int) -> Dict[str, Dict[str, int]]:\n    unique_sequences = {}\n    longest_sequence = \"\"\n    \n    for sequence in sequences:\n        if len(sequence) >= length:\n            if sequence in unique_sequences:\n                unique_sequences[sequence][\"count\"] += 1\n            else:\n                unique_sequences[sequence] = {\"count\": 1}\n            \n            if len(sequence) > len(longest_sequence):\n                longest_sequence = sequence\n                \n    return {\"sequences\": unique_sequences, \"longest_sequence\": longest_sequence}"
    },
    {
        "function_name": "markov_chain_simulator",
        "file_name": "markov_chain.py",
        "parameters": {
            "matrix": "List[List[float]] (A matrix representing a Markov chain)",
            "initial_state": "List[float] (The initial state probabilities)",
            "steps": "int (The number of steps to simulate)"
        },
        "objectives": [
            "Simulate a Markov chain using the given matrix and initial state probabilities.",
            "Calculate the state probabilities after the specified number of steps.",
            "Return the final state probabilities."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def markov_chain_simulator(matrix: List[List[float]], initial_state: List[float], steps: int) -> List[float]:\n    state_probabilities = initial_state\n    \n    for _ in range(steps):\n        state_probabilities = [sum([state_probabilities[j] * matrix[j][i] for j in range(len(state_probabilities))]) for i in range(len(state_probabilities))]\n    \n    return state_probabilities"
    },
    {
        "function_name": "max_subarray_sums",
        "file_name": "window_maxima.py",
        "parameters": {
            "sequence": "List[int] (A sequence of integers)",
            "window_size": "int (The size of the sliding window)"
        },
        "objectives": [
            "Implement a function to calculate the maximum sum of subarrays of size 'window_size' within the given sequence.",
            "Use the sliding window technique to optimize the calculation.",
            "Return a list of maximum subarray sums."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_subarray_sums(sequence: List[int], window_size: int) -> List[int]:\n    if not sequence or window_size <= 0:\n        return []\n    \n    max_sums = []\n    current_sum = sum(sequence[:window_size])\n    max_sums.append(current_sum)\n    \n    for i in range(window_size, len(sequence)):\n        current_sum = current_sum - sequence[i - window_size] + sequence[i]\n        max_sums.append(max(max_sums[-1], current_sum))\n    \n    return max_sums"
    },
    {
        "function_name": "min_coins",
        "file_name": "coin_changer.py",
        "parameters": {
            "coins": "List[int] - A list of coin denominations.",
            "amount": "int - The target amount to make change for."
        },
        "objectives": [
            "Implement a dynamic programming algorithm to calculate the minimum number of coins required to make change for the given amount.",
            "Handle cases where it is impossible to make change for the given amount.",
            "Return the minimum number of coins required, or -1 if it is impossible."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_coins(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1"
    },
    {
        "function_name": "max_height_after_demolition",
        "file_name": "building_demolition.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix representing the heights of a grid of buildings)",
            "k": "int (The number of buildings to be demolished)"
        },
        "objectives": [
            "Implement a function to find the maximum height that can be achieved by demolishing k buildings in the grid.",
            "The function should handle cases where k is zero or greater than or equal to the total number of buildings.",
            "Use a priority queue to efficiently select the buildings to be demolished."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def max_height_after_demolition(matrix: List[List[int]], k: int) -> int:\n    if not matrix or k >= len(matrix) * len(matrix[0]):\n        return 0\n    \n    pq = []\n    for row in matrix:\n        for height in row:\n            heapq.heappush(pq, height)\n    \n    for _ in range(k):\n        heapq.heappop(pq)\n    \n    return max(pq)"
    },
    {
        "function_name": "can_schedule_meetings",
        "file_name": "meeting_scheduling.py",
        "parameters": {
            "intervals": "List[List[int]] (A list of time intervals representing the start and end times of meetings)",
            "start": "int (The start time of the day)"
        },
        "objectives": [
            "Implement a function to determine whether a given set of meetings can be scheduled without conflicts.",
            "The function should handle cases where the start time is negative or greater than the end time of any meeting.",
            "Use a greedy algorithm to efficiently schedule the meetings."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def can_schedule_meetings(intervals: List[List[int]], start: int) -> bool:\n    if not intervals:\n        return False\n    \n    intervals.sort(key=lambda x: x[1])\n    last_end_time = start\n    \n    for interval in intervals:\n        if interval[0] < last_end_time:\n            return False\n        last_end_time = max(last_end_time, interval[1])\n    \n    return True"
    },
    {
        "function_name": "min_stone_size",
        "file_name": "stone_removal.py",
        "parameters": {
            "numbers": "List[int] (A list of integers representing the sizes of stones)",
            "k": "int (The number of stones to be removed)"
        },
        "objectives": [
            "Implement a function to find the minimum size of stones that can be achieved by removing k stones from the list.",
            "The function should handle cases where k is zero or greater than or equal to the total number of stones.",
            "Use a heap to efficiently select the stones to be removed."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def min_stone_size(numbers: List[int], k: int) -> int:\n    if not numbers or k >= len(numbers):\n        return 0\n    \n    pq = [-num for num in numbers]\n    heapq.heapify(pq)\n    \n    for _ in range(k):\n        heapq.heappop(pq)\n    \n    return -min(pq)"
    },
    {
        "function_name": "max_score_with_moves",
        "file_name": "puzzle_solver.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix representing the scores of a puzzle)",
            "k": "int (The number of moves allowed)"
        },
        "objectives": [
            "Implement a function to find the maximum score that can be achieved by moving k times in the puzzle.",
            "The function should handle cases where k is zero or greater than or equal to the total number of moves.",
            "Use dynamic programming to efficiently compute the maximum score."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_score_with_moves(matrix: List[List[int]], k: int) -> int:\n    if not matrix or k >= len(matrix) * len(matrix[0]):\n        return 0\n    \n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    \n    for _ in range(k):\n        temp = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols:\n                        temp[i][j] = max(temp[i][j], dp[ni][nj] + matrix[i][j])\n        dp = temp\n    \n    return max(dp[-1])"
    },
    {
        "function_name": "calculate_total_sent",
        "file_name": "transaction_calculator.py",
        "parameters": {
            "transactions": "List[Tuple[str, str, int]] - A list of transactions where each transaction is a tuple containing the sender, receiver, and amount.",
            "sender": "str - The sender's ID."
        },
        "objectives": [
            "Calculate the total amount sent by the given sender.",
            "Identify all the transactions where the sender is the given sender.",
            "Handle cases where the sender has no transactions by returning 0.",
            "Return the total amount sent by the sender."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def calculate_total_sent(transactions: List[Tuple[str, str, int]], sender: str) -> int:\n    total_sent = 0\n    for transaction in transactions:\n        if transaction[0] == sender:\n            total_sent += transaction[2]\n    return total_sent"
    },
    {
        "function_name": "schedule_jobs",
        "file_name": "job_scheduler.py",
        "parameters": {
            "`jobs`": "`List[Tuple[int, int]]` - A list of jobs, where each job is represented as a tuple of its processing time and deadline.",
            "`processors`": "`int` - The number of processors."
        },
        "objectives": [
            "Schedule the jobs on the processors to minimize the maximum lateness.",
            "Use the Earliest Deadline First (EDF) scheduling algorithm.",
            "Return the maximum lateness."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def schedule_jobs(jobs: List[Tuple[int, int]], processors: int) -> int:\n    jobs.sort(key=lambda job: job[1])\n    processors_load = [0] * processors\n    max_lateness = 0\n    \n    for job in jobs:\n        processing_time, deadline = job\n        min_load = min(processors_load)\n        processor = processors_load.index(min_load)\n        \n        if processors_load[processor] + processing_time <= deadline:\n            processors_load[processor] += processing_time\n        else:\n            processors_load[processor] += processing_time\n            max_lateness = max(max_lateness, processors_load[processor] - deadline)\n    \n    return max_lateness"
    },
    {
        "function_name": "transform_string_case",
        "file_name": "string_transformer.py",
        "parameters": {
            "string": "str (The input string to be transformed)",
            "transformations": "List[str] (A list of transformation operations, either \"upper\" or \"lower\")"
        },
        "objectives": [
            "Implement a function to transform the case of characters in the input string based on the given transformation operations.",
            "Ensure that the transformation operations are applied in the order they appear in the list.",
            "Handle edge cases where the input string is empty or the transformation list is empty.",
            "Return the transformed string."
        ],
        "import_lines": [],
        "function_def": "def transform_string_case(string, transformations):\n    if not string or not transformations:\n        return string\n    \n    result = list(string)\n    \n    for transformation in transformations:\n        if transformation == \"upper\":\n            result = [char.upper() for char in result]\n        elif transformation == \"lower\":\n            result = [char.lower() for char in result]\n    \n    return \"\".join(result)"
    },
    {
        "function_name": "product_subarrays",
        "file_name": "subarray_product.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The window size)"
        },
        "objectives": [
            "Find all subarrays of size k that have a product greater than the given threshold.",
            "Filter out the subarrays that contain duplicate numbers.",
            "Return a list of unique subarrays that meet the requirements."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def product_subarrays(nums: List[int], k: int) -> List[List[int]]:\n    threshold = sum(nums[k:])\n    result = []\n    for i in range(len(nums) - k + 1):\n        subarray = nums[i:i + k]\n        if len(set(subarray)) == k and subarray[0] != 0 and subarray[-1] != 0:\n            subarray_product = 1\n            for num in subarray:\n                subarray_product *= num\n            if subarray_product > threshold:\n                result.append(subarray)\n    return result"
    },
    {
        "function_name": "anagram_checker",
        "file_name": "anagram_finder.py",
        "parameters": {
            "string": "str (The input string)",
            "word_dict": "List[str] (A list of words to check for anagrams)"
        },
        "objectives": [
            "Check for every word in the word_dict if it is an anagram of any other word in the word_dict.",
            "Keep track of how many anagrams each word has and which anagrams it has.",
            "Return a dictionary with words as keys and their counts and actual words of anagrams as values."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from collections import defaultdict"
        ],
        "function_def": "def anagram_checker(string: str, word_dict: List[str]) -> Dict[str, Dict[str, int]]:\n    anagram_dict = defaultdict(dict)\n    for word in word_dict:\n        sorted_word = \"\".join(sorted(word))\n        anagram_dict[sorted_word][word] = 1\n    result = {}\n    for word in word_dict:\n        count = len(anagram_dict[\"\".join(sorted(word))])\n        if count > 1:\n            actual_anagrams = [(k, v) for k,v in anagram_dict[\"\".join(sorted(word))].items() if k != word]\n            result[word] = {'count': count-1, 'anagrams': actual_anagrams}\n    return result"
    },
    {
        "function_name": "assignment_solver",
        "file_name": "assignment_problem.py",
        "parameters": {
            "l1": "List[int]",
            "l2": "List[int]",
            "constraints": "List[Tuple[int, int, int]] - The list of constraints",
            "values": "List[int] - The values to assign to the constraints"
        },
        "objectives": [
            "Create a set of constraints using the given constraints.",
            "Use the Hungarian algorithm to find the maximum assignment in the set of constraints.",
            "Assign values to the assignment.",
            "Return a dictionary with the results."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict",
            "from scipy.optimize import linear_sum_assignment"
        ],
        "function_def": "def assignment_solver(l1: List[int], l2: List[int], constraints: List[Tuple[int, int, int]], values: List[int]) -> Dict[int, int]:\n    cost_matrix = [[-abs(val) if (row, col, -abs(val)) in constraints else 0 for val in values] for row in range(len(l1)) for col in range(len(l2))]\n    row_ind, col_ind = linear_sum_assignment(cost_matrix)\n    result = {}\n    for i in range(len(row_ind)):\n        if cost_matrix[row_ind[i]][col_ind[i]] != 0:\n            result[l1[row_ind[i] // len(l2)] * len(l2) + l2[col_ind[i] % len(l2)]] = values[min(col_ind[i], len(values) - 1)]\n    return result"
    },
    {
        "function_name": "assign_events",
        "file_name": "room_assigner.py",
        "parameters": {
            "intervals": "List[List[int]] - A 2D list of intervals where each interval contains a start and end time.",
            "capacities": "List[int] - The capacities of each room.",
            "num_rooms": "int - The number of rooms available for the events.",
            "events": "List[int] - The number of events."
        },
        "objectives": [
            "Assign events to rooms in the given intervals such that the number of events assigned to each room does not exceed its capacity.",
            "Ensure that no event is assigned to a room before its start time and after its end time.",
            "Use a greedy approach by sorting the events by their start time and assigning them to the room with the earliest available time that has not exceeded its capacity."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def assign_events(intervals: List[List[int]], capacities: List[int], num_rooms: int, events: List[int]) -> List[List[int]]:\n    intervals.sort(key=lambda x: x[0])  # Sort intervals by start time\n    room_assigned_events = [[] for _ in range(num_rooms)]  # Initialize room events\n    room_available_times = [0] * num_rooms  # Initialize room available times\n    \n    for start, end in intervals:\n        room_idx = -1\n        earliest_available_time = float('inf')\n        \n        for i, available_time in enumerate(room_available_times):\n            if available_time <= start and len(room_assigned_events[i]) < capacities[i] and available_time < earliest_available_time:\n                room_idx = i\n                earliest_available_time = available_time\n        \n        if room_idx != -1:\n            room_assigned_events[room_idx].append(events[0])\n            room_available_times[room_idx] = end\n            events.pop(0)\n    \n    return room_assigned_events"
    },
    {
        "function_name": "median_component",
        "file_name": "median_subgraph.py",
        "parameters": {
            "\u30b1.median_connected_graph](https": "//en.wikipedia.org/wiki/Median_connected_component)",
            "vertices": "int - The number of vertices in the graph."
        },
        "objectives": [
            "Implement the concept of a median connected component to classify the graph into two subgraphs.",
            "Use Breadth-First Search (BFS) to traverse the graph and find the median distance between all pairs of vertices.",
            "Construct the first subgraph as the original graph and remove its edges and vertices to form the second subgraph."
        ],
        "import_lines": [
            "from collections import deque",
            "from typing import List"
        ],
        "function_def": "def median_component(graph: List[List[int]], vertices: int) -> List[List[List[int]]]:\n    total_distance = 0\n    distance_matrix = [[float('inf')] * vertices for _ in range(vertices)]\n    \n    for i in range(vertices):\n        distance_matrix[i][i] = 0\n    \n    for u, v in graph:\n        distance_matrix[u][v] = distance_matrix[v][u] = 1\n    \n    for k in range(vertices):\n        for i in range(vertices):\n            for j in range(vertices):\n                distance_matrix[i][j] = min(distance_matrix[i][j], distance_matrix[i][k] + distance_matrix[k][j])\n                total_distance += distance_matrix[i][j]\n    \n    median_distance = total_distance // (vertices * (vertices - 1) // 2)\n    \n    visited = [False] * vertices\n    median_component = []\n    subgraph1 = []\n    subgraph2 = []\n    \n    for start in range(vertices):\n        if not visited[start]:\n            queue = deque([start])\n            visited[start] = True\n            subgraph = [start]\n            \n            while queue:\n                node = queue.popleft()\n                for neighbor, edge_length in enumerate(distance_matrix[node]):\n                    if edge_length == median_distance and not visited[neighbor]:\n                        queue.append(neighbor)\n                        visited[neighbor] = True\n                        subgraph.append(neighbor)\n            \n            median_component.append(subgraph)\n            if len(subgraph) > len(median_component[0]):\n                subgraph1 = median_component[0]\n                median_component[0] = subgraph\n            else:\n                subgraph2 = subgraph\n    \n    return [subgraph1, subgraph2]"
    },
    {
        "function_name": "max_weight_interval",
        "file_name": "weight_scheduling.py",
        "parameters": {
            "intervals": "List[List[int]] - A 2D list of intervals where each interval contains a start and end time.",
            "weights": "List[int] - The weights of each interval."
        },
        "objectives": [
            "Find the maximum weight interval scheduling problem where each interval has a weight and should be selected to maximize the total weight.",
            "Use dynamic programming to keep track of the maximum weight that can be obtained by scheduling the first i intervals."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_weight_interval(intervals: List[List[int]], weights: List[int]) -> int:\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    max_weights = [0] * len(intervals)\n    max_weights[0] = weights[0]\n    \n    for i in range(1, len(intervals)):\n        max_weight = weights[i]\n        for j in range(i):\n            if intervals[j][1] <= intervals[i][0]:\n                max_weight = max(max_weight, max_weights[j] + weights[i])\n        max_weights[i] = max(max_weight, max_weights[i - 1])\n    \n    return max_weights[-1]"
    },
    {
        "function_name": "longest_suffix_concat",
        "file_name": "suffix_concat.py",
        "parameters": {
            "strings": "List[str] - A list of strings to be concatenated.",
            "separators": "List[str] - A list of separators to be used between each string."
        },
        "objectives": [
            "Find the longest common suffix of the given strings.",
            "Concatenate the strings using the provided separators in a specific order (cyclically) to form a new string.",
            "Implement a loop to break the longest common suffix into multiple lines if its length exceeds a certain value (e.g., 10)."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_suffix_concat(strings: List[str], separators: List[str]) -> str:\n    if not strings:\n        return \"\"\n    \n    min_length = min(len(s) for s in strings)\n    longest_suffix = \"\"\n    \n    for i in range(1, min_length + 1):\n        suffix = strings[0][-i:]\n        if all(s.endswith(suffix) for s in strings):\n            longest_suffix = suffix\n        else:\n            break\n    \n    combined = \"\"\n    separator_index = 0\n    \n    for i, string in enumerate(strings):\n        combined += string + separators[separator_index]\n        separator_index = (separator_index + 1) % len(separators)\n    \n    combined = combined[:-1]  # Remove the last separator\n    \n    lines = []\n    line = \"\"\n    \n    for char in combined:\n        if len(line) + len(longest_suffix) > 10:\n            lines.append(line)\n            line = \"\"\n        line += char\n    \n    lines.append(line)\n    \n    return \"\\n\".join(lines)"
    },
    {
        "function_name": "find_longest_word",
        "file_name": "keyboard_words.py",
        "parameters": {
            "words": "List[str] - A list of words.",
            "max_length": "int - The maximum allowed length of a word."
        },
        "objectives": [
            "Implement a function to find the longest word in the list that can be formed using a single row of a standard keyboard layout.",
            "Ensure that the word can be typed using adjacent keys in a single row.",
            "Return the longest word that meets the conditions."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_longest_word(words: List[str], max_length: int) -> str:\n    keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']\n    max_word = ''\n    \n    for word in words:\n        word_lower = word.lower()\n        for row in keyboard_rows:\n            if all(char in row for char in word_lower):\n                if len(word) > len(max_word) and len(word) <= max_length:\n                    max_word = word\n    \n    return max_word"
    },
    {
        "function_name": "max_path_sum",
        "file_name": "max_path_sum.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid of integers."
        },
        "objectives": [
            "Find all paths in the grid from the top-left to the bottom-right that have a maximum sum.",
            "Ensure that each step can only be either down or right.",
            "Return the maximum sum as an integer."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_path_sum(grid: List[List[int]]) -> int:\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    for col in range(1, cols):\n        dp[0][col] = dp[0][col-1] + grid[0][col]\n    for row in range(1, rows):\n        dp[row][0] = dp[row-1][0] + grid[row][0]\n    \n    for row in range(1, rows):\n        for col in range(1, cols):\n            dp[row][col] = max(dp[row-1][col], dp[row][col-1]) + grid[row][col]\n    \n    return dp[rows-1][cols-1]"
    },
    {
        "function_name": "apriori_frequent_itemsets",
        "file_name": "apriori.py",
        "parameters": {
            "transactions": "List[List[int]] (List of transactions where each transaction is a list of item IDs)",
            "min_support": "float (Minimum support threshold for an itemset to be considered frequent)"
        },
        "objectives": [
            "Implement a function to find frequent itemsets using the Apriori algorithm.",
            "Use the Apriori algorithm to generate candidate itemsets and count their support.",
            "Prune candidate itemsets that do not meet the minimum support threshold.",
            "Return a list of frequent itemsets along with their support values."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict",
            "from itertools import chain, combinations"
        ],
        "function_def": "def apriori_frequent_itemsets(transactions: List[List[int]], min_support: float) -> List[tuple]:\n    itemsets = [frozenset([item]) for transaction in transactions for item in transaction]\n    frequent_itemsets = {}\n    \n    while itemsets:\n        candidate_itemsets = list(itemsets)\n        itemsets = []\n        support_counts = defaultdict(int)\n        \n        for transaction in transactions:\n            for itemset in candidate_itemsets:\n                if itemset.issubset(transaction):\n                    support_counts[itemset] += 1\n        \n        for itemset, support in support_counts.items():\n            support /= len(transactions)\n            if support >= min_support:\n                frequent_itemsets[itemset] = support\n                itemsets.extend([itemset.union([item]) for item in chain(*transactions) if item not in itemset])\n    \n    return list(frequent_itemsets.items())"
    },
    {
        "function_name": "ema_moving_average",
        "file_name": "ema.py",
        "parameters": {
            "time_series": "List[float] (Time series data)",
            "window_size": "int (Size of the window for the moving average calculation)"
        },
        "objectives": [
            "Implement a function to calculate the moving average of a time series using the Exponential Moving Average (EMA) method.",
            "Use the EMA formula to calculate the weighted average of the time series values.",
            "Apply the EMA calculation to each window of the time series.",
            "Return the EMA values for each window."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def ema_moving_average(time_series: List[float], window_size: int) -> List[float]:\n    ema_values = []\n    alpha = 2 / (window_size + 1)\n    \n    for i in range(window_size):\n        ema_values.append(sum(time_series[:i+1]) / (i+1))\n    \n    for i in range(window_size, len(time_series)):\n        ema_values.append(ema_values[-1] * (1 - alpha) + time_series[i] * alpha)\n    \n    return ema_values"
    },
    {
        "function_name": "prefix_tree",
        "file_name": "prefix_tree.py",
        "parameters": {
            "text": "str (The input text to generate a prefix tree)"
        },
        "objectives": [
            "Implement a trie data structure to store the input text.",
            "Handle edge cases where the input text is empty or contains duplicate words.",
            "Return the prefix tree as a dictionary."
        ],
        "import_lines": [
            "from typing import Dict"
        ],
        "function_def": "def prefix_tree(text: str) -> Dict[str, Dict[str, str]]:\n    prefix_tree_dict = {}\n    \n    words = text.split()\n    \n    for word in words:\n        node = prefix_tree_dict\n        \n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        \n        node['$'] = word\n    \n    return prefix_tree_dict"
    },
    {
        "function_name": "count_distinct_subgrids",
        "file_name": "grid_analyzer.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid of integers",
            "k": "int - The size of the sub-grid"
        },
        "objectives": [
            "Implement a function to find the number of sub-grids of size k x k that contain exactly k different numbers.",
            "Ensure that the function handles edge cases where k is larger than the grid size or where there are not enough distinct numbers in the grid.",
            "Optimize the function to handle large grids and large sub-grid sizes."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def count_distinct_subgrids(grid: List[List[int]], k: int) -> int:\n    if k > len(grid) or k > len(grid[0]):\n        return 0\n    \n    count = 0\n    for i in range(len(grid) - k + 1):\n        for j in range(len(grid[0]) - k + 1):\n            num_set = set()\n            for x in range(k):\n                for y in range(k):\n                    num_set.add(grid[i + x][j + y])\n            if len(num_set) == k:\n                count += 1\n    \n    return count"
    },
    {
        "function_name": "is_valid_parentheses",
        "file_name": "parentheses_validator.py",
        "parameters": {
            "s": "str - A string consisting of parentheses"
        },
        "objectives": [
            "Implement a function to validate whether the string is a valid sequence of parentheses.",
            "Ensure that the function handles edge cases where the string contains non-parentheses characters or where the string is empty.",
            "Optimize the function to handle large strings."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def is_valid_parentheses(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n        elif char not in ['(', ')']:\n            return False\n    \n    return not stack"
    },
    {
        "function_name": "reduce_rank_with_svd",
        "file_name": "matrix_rank_reducer.py",
        "parameters": {
            "matrix": "List[List[float]] - A 2D matrix of floats",
            "k": "int - The target rank"
        },
        "objectives": [
            "Implement a function to perform singular value decomposition (SVD) on the input matrix and reduce its rank to k.",
            "Ensure that the function handles edge cases where k is larger than the matrix rank or where the matrix is empty.",
            "Optimize the function to handle large matrices."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def reduce_rank_with_svd(matrix: np.ndarray, k: int) -> np.ndarray:\n    if k >= matrix.shape[1]:\n        return matrix\n    \n    U, s, Vh = np.linalg.svd(matrix)\n    Uk = U[:, :k]\n    sk = np.diag(s[:k])\n    Vk = Vh[:k, :]\n    \n    return Uk @ sk @ Vk"
    },
    {
        "function_name": "randomized_submatrix_selection",
        "file_name": "matrix_selector.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D list representing a matrix.",
            "rows": "int - The number of rows to select.",
            "cols": "int - The number of columns to select."
        },
        "objectives": [
            "Implement a randomized algorithm to select a subset of rows and columns from the matrix.",
            "Ensure that each selected row and column contains at least one non-zero element.",
            "Return the resulting submatrix."
        ],
        "import_lines": [
            "from typing import List",
            "import random"
        ],
        "function_def": "def randomized_submatrix_selection(matrix: List[List[int]], rows: int, cols: int) -> List[List[int]]:\n    non_zero_rows = [i for i, row in enumerate(matrix) if any(element != 0 for element in row)]\n    non_zero_cols = [j for j in range(len(matrix[0])) if any(matrix[i][j] != 0 for i in range(len(matrix)))]\n    \n    selected_rows = random.sample(non_zero_rows, rows)\n    selected_cols = random.sample(non_zero_cols, cols)\n    \n    submatrix = [[matrix[i][j] for j in selected_cols] for i in selected_rows]\n    \n    return submatrix"
    },
    {
        "function_name": "pca_linear_regression",
        "file_name": "pca_regressor.py",
        "parameters": {
            "df": "pandas.DataFrame - The input DataFrame to process.",
            "feature_columns": "List[str] - A list of feature columns to use for PCA.",
            "target_column": "str - The target column to predict."
        },
        "objectives": [
            "Apply principal component analysis (PCA) to the specified feature columns.",
            "Reduce the dimensionality of the feature space to the number of components that capture 95% of the variance.",
            "Train a linear regression model on the reduced feature space to predict the target column.",
            "Return the predicted values."
        ],
        "import_lines": [
            "from typing import List",
            "import pandas as pd",
            "from sklearn.decomposition import PCA",
            "from sklearn.linear_model import LinearRegression",
            "from sklearn.model_selection import train_test_split"
        ],
        "function_def": "def pca_linear_regression(df: pd.DataFrame, feature_columns: List[str], target_column: str) -> List[float]:\n    X = df[feature_columns]\n    y = df[target_column]\n    \n    pca = PCA(n_components=0.95)\n    X_pca = pca.fit_transform(X)\n    \n    X_train, X_test, y_train, y_test = train_test_split(X_pca, y, test_size=0.2, random_state=42)\n    \n    model = LinearRegression()\n    model.fit(X_train, y_train)\n    \n    predicted_values = model.predict(X_test)\n    \n    return predicted_values.tolist()"
    },
    {
        "function_name": "find_words_with_prefix",
        "file_name": "word_finder.py",
        "parameters": {
            "word_list": "List[str] (A list of words)",
            "prefix": "str (The prefix to search for in the words)",
            "min_length": "int (The minimum length of words to consider)",
            "max_length": "int (The maximum length of words to consider)"
        },
        "objectives": [
            "Find all words in the word list that start with the specified prefix and have a length within the specified range.",
            "Return a list of words that meet the criteria."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_words_with_prefix(word_list: List[str], prefix: str, min_length: int, max_length: int) -> List[str]:\n    return [word for word in word_list if word.startswith(prefix) and min_length <= len(word) <= max_length]"
    },
    {
        "function_name": "find_nodes_within_hops",
        "file_name": "network_traverser.py",
        "parameters": {
            "network": "List[List[int]] (An adjacency list representation of a network where each sublist contains the neighbors of a node)",
            "start_node": "int (The node to start the traversal from)",
            "max_hops": "int (The maximum number of hops to traverse)"
        },
        "objectives": [
            "Find all nodes within a specified number of hops from the start node in the network.",
            "The number of hops is measured in terms of the number of edges between nodes.",
            "Return a set of all nodes within the specified number of hops."
        ],
        "import_lines": [
            "from typing import List, Set",
            "from collections import deque"
        ],
        "function_def": "def find_nodes_within_hops(network: List[List[int]], start_node: int, max_hops: int) -> Set[int]:\n    visited = set()\n    queue = deque([(start_node, 0)])\n    \n    while queue:\n        node, current_hops = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            if current_hops < max_hops:\n                for neighbor in network[node]:\n                    queue.append((neighbor, current_hops + 1))\n    \n    return visited"
    },
    {
        "function_name": "eigenvalue_decomposition",
        "file_name": "eigenvalue_decomposition.py",
        "parameters": {
            "matrix": "List[List[float]] (A 2D list of floats representing the input matrix)"
        },
        "objectives": [
            "Perform a eigenvalue decomposition on the given matrix.",
            "Return the eigenvalues and eigenvectors as a list of tuples, where each tuple contains an eigenvalue and its corresponding eigenvector."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import numpy as np"
        ],
        "function_def": "def eigenvalue_decomposition(matrix: List[List[float]]) -> List[Tuple[float, List[float]]]:\n    numpy_matrix = np.array(matrix)\n    eigenvalues, eigenvectors = np.linalg.eig(numpy_matrix)\n    \n    result = []\n    for eigenvalue, eigenvector in zip(eigenvalues, eigenvectors.T):\n        result.append((eigenvalue, eigenvector.tolist()))\n    \n    return result"
    },
    {
        "function_name": "merge_sequences",
        "file_name": "merger.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences to merge",
            "k": "int - The maximum number of elements to return"
        },
        "objectives": [
            "Implement a heap-based approach to merge the sequences and return the k largest elements.",
            "Use a min heap to efficiently keep track of the k largest elements.",
            "Use a list to store the result and ensure that the elements are in the correct order."
        ],
        "import_lines": [
            "import heapq"
        ],
        "function_def": "def merge_sequences(sequences, k):\n    min_heap = []\n    for seq in sequences:\n        for num in seq:\n            if len(min_heap) < k:\n                heapq.heappush(min_heap, num)\n            else:\n                heapq.heappushpop(min_heap, num)\n    \n    result = []\n    while min_heap:\n        result.append(heapq.heappop(min_heap))\n    \n    return result[::-1]"
    },
    {
        "function_name": "min_window",
        "file_name": "sliding_window.py",
        "parameters": {
            "text": "str (A string to find the minimum window that contains all characters)",
            "pattern": "str (A string pattern to search for in the text)"
        },
        "objectives": [
            "Implement a sliding window algorithm to find the minimum window in the input text that contains all characters of the pattern.",
            "Handle edge cases where the text or pattern is empty, or where the pattern is longer than the text.",
            "Return the minimum window."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def min_window(text: str, pattern: str) -> str:\n    if not text or not pattern or len(pattern) > len(text):\n        return \"\"\n    \n    pattern_counts = defaultdict(int)\n    for char in pattern:\n        pattern_counts[char] += 1\n    \n    required_chars = len(pattern_counts)\n    \n    left = 0\n    min_length = float('inf')\n    min_window = \"\"\n    \n    for right, char in enumerate(text):\n        if char in pattern_counts:\n            pattern_counts[char] -= 1\n            if pattern_counts[char] == 0:\n                required_chars -= 1\n        \n        while required_chars == 0:\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_window = text[left:right + 1]\n            \n            if text[left] in pattern_counts:\n                pattern_counts[text[left]] += 1\n                if pattern_counts[text[left]] > 0:\n                    required_chars += 1\n            left += 1\n    \n    return min_window"
    },
    {
        "function_name": "calculate_median",
        "file_name": "calculate_median.py",
        "parameters": {
            "`numbers`": "`List[int]` (A list of numbers to process)",
            "`threshold`": "`int` (The threshold to use when calculating the median)"
        },
        "objectives": [
            "Implement a function to calculate the median of a list of numbers, handling cases where the list has an odd or even number of elements.",
            "Use a sorted list to efficiently calculate the median.",
            "Return the median of the list, or None if the list is empty."
        ],
        "import_lines": [
            "from typing import List, Optional"
        ],
        "function_def": "def calculate_median(numbers: List[int], threshold: int) -> Optional[int]:\n    if not numbers:\n        return None\n    \n    sorted_numbers = sorted(numbers)\n    n = len(sorted_numbers)\n    \n    if n % 2 == 0:\n        median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2\n    else:\n        median = sorted_numbers[n // 2]\n    \n    return median if median >= threshold else None"
    },
    {
        "function_name": "swap_diagonals",
        "file_name": "matrix_swapper.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list of integers representing a matrix)",
            "k": "int (The number of diagonal elements to swap)"
        },
        "objectives": [
            "Swap k diagonal elements of the matrix in a clockwise direction.",
            "The function should return the modified matrix.",
            "Ensure that the function handles cases where the input matrix is not a square matrix or k is greater than the number of diagonal elements."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def swap_diagonals(matrix: List[List[int]], k: int) -> List[List[int]]:\n    n = len(matrix)\n    if n != len(matrix[0]):\n        raise ValueError(\"Input matrix is not a square matrix\")\n    \n    diagonal1 = [matrix[i][i] for i in range(n)]\n    diagonal2 = [matrix[i][n-i-1] for i in range(n)]\n    diagonal = diagonal1 + diagonal2\n    \n    k = k % len(diagonal)\n    diagonal = diagonal[-k:] + diagonal[:-k]\n    \n    diagonal1 = diagonal[:n]\n    diagonal2 = diagonal[n:]\n    \n    for i in range(n):\n        matrix[i][i] = diagonal1[i]\n        matrix[i][n-i-1] = diagonal2[i]\n    \n    return matrix"
    },
    {
        "function_name": "schedule_tasks",
        "file_name": "task_scheduler.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] (A list of tuples representing time intervals)",
            "deadline": "int (The deadline for the tasks)"
        },
        "objectives": [
            "Schedule the tasks represented by the intervals in a way that maximizes the number of tasks completed before the deadline.",
            "The function should return a list of the scheduled tasks.",
            "Ensure that the function handles cases where the input intervals are empty or the deadline is 0."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def schedule_tasks(intervals: List[Tuple[int, int]], deadline: int) -> List[Tuple[int, int]]:\n    intervals.sort(key=lambda x: x[1])\n    scheduled_tasks = []\n    current_time = 0\n    \n    for start, end in intervals:\n        if current_time <= start and end <= deadline:\n            scheduled_tasks.append((start, end))\n            current_time = end\n    \n    return scheduled_tasks"
    },
    {
        "function_name": "shortest_path_to_boundary",
        "file_name": "grid_pathfinder.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D list of integers representing a grid)",
            "x": "int (The x-coordinate of the cell)",
            "y": "int (The y-coordinate of the cell)"
        },
        "objectives": [
            "Find the shortest path from the cell at (x, y) to any cell on the boundary of the grid.",
            "The function should return the length of the shortest path.",
            "Ensure that the function handles cases where the input grid is empty or the cell is already on the boundary."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def shortest_path_to_boundary(grid: List[List[int]], x: int, y: int) -> int:\n    n, m = len(grid), len(grid[0])\n    if x < 0 or x >= n or y < 0 or y >= m:\n        raise ValueError(\"Cell is out of bounds\")\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(x, y, 0)])\n    visited = {(x, y)}\n    \n    while queue:\n        current_x, current_y, distance = queue.popleft()\n        \n        if current_x == 0 or current_x == n-1 or current_y == 0 or current_y == m-1:\n            return distance\n        \n        for dx, dy in directions:\n            new_x, new_y = current_x + dx, current_y + dy\n            \n            if 0 <= new_x < n and 0 <= new_y < m and (new_x, new_y) not in visited:\n                queue.append((new_x, new_y, distance + 1))\n                visited.add((new_x, new_y))\n    \n    return -1"
    },
    {
        "function_name": "flip_bits",
        "file_name": "bit_flipper.py",
        "parameters": {
            "bits": "List[int] (A list of bits representing a binary number)"
        },
        "objectives": [
            "Flip the minimum number of bits to make the longest contiguous subsequence of 1s as long as possible.",
            "The function should return the modified list of bits.",
            "Ensure that the function handles cases where the input list is empty."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def flip_bits(bits: List[int]) -> List[int]:\n    n = len(bits)\n    max_length = 0\n    start = 0\n    \n    for i in range(n):\n        if bits[i] == 1:\n            current_length = 1\n            for j in range(i + 1, n):\n                if bits[j] == 1:\n                    current_length += 1\n                else:\n                    break\n            if current_length > max_length:\n                max_length = current_length\n                start = i\n    \n    for i in range(start, start + max_length):\n        bits[i] = 1\n    \n    return bits"
    },
    {
        "function_name": "find_subgrids",
        "file_name": "subgrid_generator.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid of integers.",
            "k": "int - The size of the sub-grid."
        },
        "objectives": [
            "Find all possible sub-grids of size kxk from the given 2D grid.",
            "Ensure that the sub-grids are not overlapping.",
            "Return a list of 2D lists, where each sublist is a sub-grid of size kxk."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_subgrids(grid: List[List[int]], k: int) -> List[List[List[int]]]:\n    subgrids = []\n    for i in range(len(grid) - k + 1):\n        for j in range(len(grid[0]) - k + 1):\n            subgrid = [row[j:j+k] for row in grid[i:i+k]]\n            subgrids.append(subgrid)\n    return subgrids"
    },
    {
        "function_name": "interval_point_coverage",
        "file_name": "interval_coverage.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] (A list of time intervals)",
            "points": "List[int] (A list of time points)"
        },
        "objectives": [
            "Implement the \"Interval Point Coverage\" problem, where we need to find the maximum number of points that can be covered by the given intervals.",
            "Sort the intervals by their end points and initialize the coverage count to 0.",
            "Iterate over the points and check if each point is covered by the current interval. If a point is covered, increment the coverage count."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def interval_point_coverage(intervals: List[Tuple[int, int]], points: List[int]) -> int:\n    if not intervals or not points:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    coverage_count = 0\n    current_interval = intervals[0]\n    \n    for point in points:\n        if current_interval[0] <= point <= current_interval[1]:\n            coverage_count += 1\n        elif point > current_interval[1]:\n            current_interval = next((interval for interval in intervals if interval[0] <= point), None)\n            if current_interval:\n                coverage_count += 1\n    \n    return coverage_count"
    },
    {
        "function_name": "complexity_metrics",
        "file_name": "complexity_analyzer.py",
        "parameters": {
            "classes": "List[str] - A list of class names.",
            "methods": "Dict[str, List[str]] - A dictionary where keys are class names and values are lists of method names.",
            "lines_of_code": "Dict[str, Dict[str, int]] - A dictionary where keys are class names, and values are dictionaries with method names as keys and lines of code as values."
        },
        "objectives": [
            "Calculate the cyclomatic complexity of each method.",
            "Calculate the Halstead complexity metrics (difficulty, effort, time, and bugs) for each method.",
            "Calculate the average complexity metrics for each class.",
            "Return a dictionary with class names as keys and dictionaries of complexity metrics as values."
        ],
        "import_lines": [
            "import math"
        ],
        "function_def": "def complexity_metrics(classes, methods, lines_of_code):\n    complexity_metrics = {}\n    for class_name in classes:\n        class_metrics = {}\n        for method_name in methods[class_name]:\n            lines = lines_of_code[class_name][method_name]\n            cyclomatic_complexity = lines / 5  # Simple heuristic for demonstration purposes\n            halstead_difficulty = (lines / 2) * math.log(lines, 2)\n            halstead_effort = halstead_difficulty * lines\n            halstead_time = halstead_effort / 60\n            halstead_bugs = math.pow(halstead_effort, 2/3)\n            class_metrics[method_name] = {\n                'cyclomatic_complexity': cyclomatic_complexity,\n                'halstead_difficulty': halstead_difficulty,\n                'halstead_effort': halstead_effort,\n                'halstead_time': halstead_time,\n                'halstead_bugs': halstead_bugs\n            }\n        average_cyclomatic_complexity = sum(metric['cyclomatic_complexity'] for metric in class_metrics.values()) / len(class_metrics)\n        average_halstead_difficulty = sum(metric['halstead_difficulty'] for metric in class_metrics.values()) / len(class_metrics)\n        average_halstead_effort = sum(metric['halstead_effort'] for metric in class_metrics.values()) / len(class_metrics)\n        average_halstead_time = sum(metric['halstead_time'] for metric in class_metrics.values()) / len(class_metrics)\n        average_halstead_bugs = sum(metric['halstead_bugs'] for metric in class_metrics.values()) / len(class_metrics)\n        class_metrics['average'] = {\n            'cyclomatic_complexity': average_cyclomatic_complexity,\n            'halstead_difficulty': average_halstead_difficulty,\n            'halstead_effort': average_halstead_effort,\n            'halstead_time': average_halstead_time,\n            'halstead_bugs': average_halstead_bugs\n        }\n        complexity_metrics[class_name] = class_metrics\n    return complexity_metrics"
    },
    {
        "function_name": "genetic_algorithm",
        "file_name": "genetic_optimizer.py",
        "parameters": {
            "population_size": "int - The size of the population.",
            "generations": "int - The number of generations to run the algorithm.",
            "dna_length": "int - The length of each DNA string.",
            "fitness_function": "function - A function that takes a DNA string and returns its fitness."
        },
        "objectives": [
            "Initialize a population of random DNA strings.",
            "Evaluate the fitness of each DNA string in the population.",
            "Select the fittest DNA strings to reproduce.",
            "Perform crossover and mutation on the selected DNA strings.",
            "Repeat the process for the specified number of generations.",
            "Return the fittest DNA string."
        ],
        "import_lines": [
            "import random"
        ],
        "function_def": "def genetic_algorithm(population_size, generations, dna_length, fitness_function):\n    population = [''.join(random.choice('01') for _ in range(dna_length)) for _ in range(population_size)]\n    for _ in range(generations):\n        fitnesses = [fitness_function(dna) for dna in population]\n        fittest_indices = sorted(range(population_size), key=lambda i: fitnesses[i], reverse=True)[:population_size//2]\n        selected_dnas = [population[i] for i in fittest_indices]\n        offspring = []\n        while len(offspring) < population_size:\n            parent1, parent2 = random.sample(selected_dnas, 2)\n            crossover_point = random.randint(1, dna_length-1)\n            child1 = parent1[:crossover_point] + parent2[crossover_point:]\n            child2 = parent2[:crossover_point] + parent1[crossover_point:]\n            offspring.extend([child1, child2])\n        for i in range(population_size):\n            if random.random() < 0.1:  # 10% mutation rate\n                mutation_point = random.randint(0, dna_length-1)\n                offspring[i] = offspring[i][:mutation_point] + str(1-int(offspring[i][mutation_point])) + offspring[i][mutation_point+1:]\n        population = offspring\n    return max(population, key=fitness_function)"
    },
    {
        "function_name": "summarize_text",
        "file_name": "text_summarizer.py",
        "parameters": {
            "text": "str - The text to summarize.",
            "num_sentences": "int - The number of sentences to include in the summary."
        },
        "objectives": [
            "Tokenize the text into sentences.",
            "Use a simple heuristic to score each sentence based on its relevance to the text.",
            "Select the top-scoring sentences to include in the summary.",
            "Return a string representing the summary."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def summarize_text(text, num_sentences):\n    sentences = text.split('. ')\n    sentence_scores = np.zeros(len(sentences))\n    for i, sentence in enumerate(sentences):\n        for word in sentence.split():\n            if word.lower() in ['the', 'and', 'a', 'an', 'is', 'are', 'for', 'it', 'this', 'that', 'these', 'those']:\n                sentence_scores[i] -= 1\n            else:\n                sentence_scores[i] += 1\n    top_sentences = np.argsort(sentence_scores)[-num_sentences:]\n    summary = '. '.join([sentences[i] for i in top_sentences])\n    return summary"
    },
    {
        "function_name": "calculate_salinity_indices",
        "file_name": "ocean_analyzer.py",
        "parameters": {
            "salts": "List[List[float]] (A list of lists containing salt concentrations)",
            "temperature": "float (The temperature in degrees Celsius)",
            "precipitation": "float (The precipitation in mm)"
        },
        "objectives": [
            "Calculate the salinity index for each sublist in 'salts' using the formula: salinity_index = (max(salts) - min(salts)) / (temperature + precipitation).",
            "Ensure the salinity index is within the valid range of [0, 1] by clipping it if necessary.",
            "Return a dictionary with the salinity indices for each sublist."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def calculate_salinity_indices(salts: List[List[float]], temperature: float, precipitation: float) -> Dict[str, float]:\n    salinity_indices = {}\n    \n    for i, salt_concentrations in enumerate(salts):\n        max_salt = max(salt_concentrations)\n        min_salt = min(salt_concentrations)\n        salinity_index = (max_salt - min_salt) / (temperature + precipitation)\n        salinity_index = max(0, min(1, salinity_index))  # Clip to valid range\n        salinity_indices[f\"salinity_index_{i}\"] = salinity_index\n    \n    return salinity_indices"
    },
    {
        "function_name": "filter_students_by_course_and_gpa",
        "file_name": "student_analyzer.py",
        "parameters": {
            "students": "List[Dict[str, str]] (A list of dictionaries containing student information)",
            "course_code": "str (The course code to filter students by)",
            "min_gpa": "float (The minimum GPA to filter students by)"
        },
        "objectives": [
            "Find students enrolled in the specified course with a GPA greater than or equal to the minimum GPA.",
            "Extract the student IDs, names, and GPAs from the filtered students.",
            "Return a list of tuples containing the student information."
        ],
        "import_lines": [
            "from typing import List, Dict, Tuple"
        ],
        "function_def": "def filter_students_by_course_and_gpa(students: List[Dict[str, str]], course_code: str, min_gpa: float) -> List[Tuple[int, str, float]]:\n    filtered_students = []\n    \n    for student in students:\n        if student[\"course_code\"] == course_code and float(student[\"gpa\"]) >= min_gpa:\n            student_id = int(student[\"student_id\"])\n            student_name = student[\"name\"]\n            gpa = float(student[\"gpa\"])\n            filtered_students.append((student_id, student_name, gpa))\n    \n    return filtered_students"
    },
    {
        "function_name": "stratified_random_sampling",
        "file_name": "sampling.py",
        "parameters": {
            "population": "List[int] (A list of integer values representing the population)",
            "sample_size": "int (The sample size to select)"
        },
        "objectives": [
            "Select a random sample of the specified size from the population.",
            "Ensure the sample is representative of the population by stratifying it based on the population quantiles.",
            "Return a list of sampled values."
        ],
        "import_lines": [
            "import numpy as np",
            "from typing import List"
        ],
        "function_def": "def stratified_random_sampling(population: List[int], sample_size: int) -> List[int]:\n    population_array = np.array(population)\n    quantiles = np.quantile(population_array, [0, 0.25, 0.5, 0.75, 1])\n    sample = []\n    \n    for i in range(4):\n        stratum = population_array[(population_array > quantiles[i]) & (population_array <= quantiles[i + 1])]\n        stratum_sample_size = int(sample_size * len(stratum) / len(population))\n        stratum_sample = np.random.choice(stratum, size=stratum_sample_size, replace=False)\n        sample.extend(stratum_sample)\n    \n    return sample"
    },
    {
        "function_name": "markov_clustering",
        "file_name": "graph_clustering.py",
        "parameters": {
            "graph": "Dict[List[int]] - An adjacency list representing a graph.",
            "k": "int - The number of clusters to find.",
            "max_iterations": "int - The maximum number of iterations for the algorithm."
        },
        "objectives": [
            "Implement the Markov Clustering Algorithm (MCL) to group nodes in the graph into clusters.",
            "Apply the inflation step to the transition matrix to amplify the differences between nodes.",
            "Repeat the expansion and inflation steps until convergence or the maximum number of iterations is reached.",
            "Return a list of cluster labels for each node."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def markov_clustering(graph, k, max_iterations):\n    nodes = list(graph.keys())\n    adjacency_matrix = np.zeros((len(nodes), len(nodes)))\n    for i, node in enumerate(nodes):\n        for neighbor in graph[node]:\n            adjacency_matrix[i, nodes.index(neighbor)] = 1\n    \n    transition_matrix = adjacency_matrix / adjacency_matrix.sum(axis=1, keepdims=True)\n    for _ in range(max_iterations):\n        # Expansion step\n        new_transition_matrix = np.dot(transition_matrix, transition_matrix)\n        \n        # Inflation step\n        new_transition_matrix = new_transition_matrix ** 2\n        \n        # Normalization step\n        new_transition_matrix = new_transition_matrix / new_transition_matrix.sum(axis=1, keepdims=True)\n        \n        if np.allclose(transition_matrix, new_transition_matrix):\n            break\n        \n        transition_matrix = new_transition_matrix\n    \n    cluster_labels = np.argmax(transition_matrix, axis=1)\n    return cluster_labels"
    },
    {
        "function_name": "paa_segmentation",
        "file_name": "time_series_segmentation.py",
        "parameters": {
            "data": "List[float] - A list of numeric values.",
            "window_size": "int - The size of the moving window.",
            "sensitivity": "float - The sensitivity of the algorithm to noise."
        },
        "objectives": [
            "Implement the Piecewise Aggregate Approximation (PAA) algorithm to segment the data into regions of similar values.",
            "Use the sliding window approach to generate candidate segments.",
            "Apply the sensitivity constraint to control the number of segments.",
            "Return a list of segment boundaries and their corresponding values."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def paa_segmentation(data, window_size, sensitivity):\n    segments = []\n    values = []\n    for i in range(0, len(data), window_size):\n        window = data[i:i+window_size]\n        mean = sum(window) / len(window)\n        values.append(mean)\n        segments.append(mean)\n        \n        # Segment the data based on the sensitivity constraint\n        if len(values) > 1 and abs(values[-1] - values[-2]) > sensitivity:\n            segments.append(values[-1])\n            values = [values[-1]]\n    \n    return segments, values"
    },
    {
        "function_name": "svd_reconstruction",
        "file_name": "matrix_decomposition.py",
        "parameters": {
            "matrix": "List[List[float]] - A matrix of floating-point numbers.",
            "k": "int - The number of singular values to retain."
        },
        "objectives": [
            "Implement the Singular Value Decomposition (SVD) algorithm to decompose the matrix into its singular values and singular vectors.",
            "Retain only the top-k singular values and singular vectors.",
            "Reconstruct the matrix from the retained singular values and singular vectors.",
            "Return the reconstructed matrix."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def svd_reconstruction(matrix, k):\n    # Perform SVD on the matrix\n    U, s, Vh = np.linalg.svd(matrix, full_matrices=False)\n    \n    # Retain only the top-k singular values and singular vectors\n    Uk = U[:, :k]\n    sk = s[:k]\n    Vkh = Vh[:k, :]\n    \n    # Reconstruct the matrix from the retained singular values and singular vectors\n    reconstructed_matrix = Uk @ np.diag(sk) @ Vkh\n    \n    return reconstructed_matrix"
    },
    {
        "function_name": "independent_cascade",
        "file_name": "network_diffusion.py",
        "parameters": {
            "network": "List[List[int]] - An adjacency list representing a network.",
            "seed_nodes": "List[int] - A list of seed nodes to start the diffusion process.",
            "influence_probability": "float - The probability of influence between nodes."
        },
        "objectives": [
            "Implement the Independent Cascade (IC) model to simulate the diffusion process in the network.",
            "Initialize the seed nodes as active.",
            "Propagate the influence to neighboring nodes based on the influence probability.",
            "Repeat the diffusion process until no new nodes are activated.",
            "Return the number of active nodes at each time step."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def independent_cascade(network, seed_nodes, influence_probability):\n    active_nodes = set(seed_nodes)\n    time_steps = [len(active_nodes)]\n    \n    while True:\n        new_active_nodes = set()\n        for node in active_nodes:\n            for neighbor in network[node]:\n                if neighbor not in active_nodes and np.random.rand() < influence_probability:\n                    new_active_nodes.add(neighbor)\n        active_nodes.update(new_active_nodes)\n        time_steps.append(len(active_nodes))\n        \n        if not new_active_nodes:\n            break\n    \n    return time_steps"
    },
    {
        "function_name": "insert_interval",
        "file_name": "interval_insertion.py",
        "parameters": {
            "intervals": "List[List[int]] (A list of intervals)",
            "new_interval": "List[int] (The new interval to be inserted)"
        },
        "objectives": [
            "Implement a function to insert a new interval into a list of non-overlapping intervals.",
            "Handle cases where the list is empty or where the new interval overlaps with existing intervals.",
            "Return the updated list of intervals."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def insert_interval(intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\n    if not intervals:\n        return [new_interval]\n    \n    result = []\n    i = 0\n    \n    while i < len(intervals) and intervals[i][1] < new_interval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    while i < len(intervals) and intervals[i][0] <= new_interval[1]:\n        new_interval[0] = min(new_interval[0], intervals[i][0])\n        new_interval[1] = max(new_interval[1], intervals[i][1])\n        i += 1\n    \n    result.append(new_interval)\n    \n    while i < len(intervals):\n        result.append(intervals[i])\n        i += 1\n    \n    return result"
    },
    {
        "function_name": "tokenize_and_filter",
        "file_name": "text_processor.py",
        "parameters": {
            "`text`": "`str`",
            "`delimiter`": "`str`",
            "`threshold`": "`int`"
        },
        "objectives": [
            "Tokenize the input text into words separated by the specified delimiter.",
            "Filter out words that appear less than the specified threshold.",
            "Return a tuple containing the filtered words and their frequencies."
        ],
        "import_lines": [
            "from typing import Tuple, Dict",
            "from collections import Counter"
        ],
        "function_def": "def tokenize_and_filter(text: str, delimiter: str, threshold: int) -> Tuple[list[str], Dict[str, int]]:\n    words = text.split(delimiter)\n    word_freq = Counter(words)\n    filtered_words = {word: freq for word, freq in word_freq.items() if freq >= threshold}\n    \n    return list(filtered_words.keys()), dict(filtered_words)"
    },
    {
        "function_name": "assign_threads_to_looms",
        "file_name": "loom_assignment.py",
        "parameters": {
            "`threads`": "`List[int]`",
            "`looms`": "`List[int]`",
            "`colors`": "`List[int]`"
        },
        "objectives": [
            "Model the problem of assigning threads to looms for weaving a fabric with a specified color pattern.",
            "Each loom can be assigned at most one thread, and each thread can be assigned to at most one loom.",
            "Maximize the total length of threads assigned to looms while ensuring that the color pattern is maintained.",
            "Return a tuple containing the maximum total length of threads and the assignment of threads to looms."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from scipy.optimize import linear_sum_assignment",
            "import numpy as np"
        ],
        "function_def": "def assign_threads_to_looms(threads: List[int], looms: List[int], colors: List[int]) -> Tuple[int, List[Tuple[int, int]]]:\n    cost_matrix = np.zeros((len(threads), len(looms)))\n    for i, thread in enumerate(threads):\n        for j, loom in enumerate(looms):\n            if colors[i] == colors[j]:\n                cost_matrix[i, j] = thread\n    \n    row_ind, col_ind = linear_sum_assignment(-cost_matrix)\n    max_total_length = np.sum(np.multiply(cost_matrix[row_ind, col_ind], -1))\n    assignment = list(zip(row_ind, col_ind))\n    \n    return int(max_total_length), assignment"
    },
    {
        "function_name": "find_largest_rectangle_in_drawing",
        "file_name": "rectangle_finder.py",
        "parameters": {
            "`drawing`": "`List[List[int]]`",
            "`max_size`": "`int`"
        },
        "objectives": [
            "Find the largest rectangle that can be drawn within the given drawing while maintaining the overall shape.",
            "Ensure that the rectangle is axis-aligned and does not exceed the specified maximum size.",
            "Return a tuple containing the coordinates of the top-left and bottom-right corners of the rectangle."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def find_largest_rectangle_in_drawing(drawing: List[List[int]], max_size: int) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    rows, cols = len(drawing), len(drawing[0])\n    histogram = drawing[0]\n    max_rectangle = (0, 0), (0, 0)\n    \n    for row in range(rows):\n        for col in range(cols):\n            if drawing[row][col] == 1:\n                histogram[col] += 1\n            else:\n                histogram[col] = 0\n        \n        stack = []\n        for col in range(cols + 1):\n            while stack and (col == cols or histogram[col] < histogram[stack[-1]]):\n                height = histogram[stack.pop()]\n                width = col - stack[-1] - 1 if stack else col\n                if height * width > max_rectangle[1][0] * (max_rectangle[1][1] - max_rectangle[0][1]) and width <= max_size:\n                    max_rectangle = ((col - width, row - height + 1), (col - 1, row))\n            stack.append(col)\n    \n    return max_rectangle"
    },
    {
        "function_name": "four_sum",
        "file_name": "combinatorics.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "target": "int (The target sum)"
        },
        "objectives": [
            "Find all unique quadruplets in the given list of integers that add up to the target sum.",
            "Ensure that the quadruplets are in non-decreasing order and contain no duplicates.",
            "Return the list of quadruplets."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def four_sum(nums: List[int], target: int) -> List[List[int]]:\n    nums.sort()\n    result = []\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        for j in range(i+1, len(nums)):\n            if j > i+1 and nums[j] == nums[j-1]:\n                continue\n            left, right = j+1, len(nums)-1\n            while left < right:\n                current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n    return result"
    },
    {
        "function_name": "longest_unique_substring",
        "file_name": "string_provider.py",
        "parameters": {
            "s": "str (The input string)"
        },
        "objectives": [
            "Find the longest substring without repeating characters in the given string.",
            "Use a sliding window approach to track the longest substring.",
            "Return the length of the longest substring."
        ],
        "import_lines": [
            "from typing import Set"
        ],
        "function_def": "def longest_unique_substring(s: str) -> int:\n    char_set = set()\n    left = 0\n    result = 0\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        result = max(result, right - left + 1)\n    return result"
    },
    {
        "function_name": "max_subgrid_sum",
        "file_name": "grid_optimizer.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D grid of integers)"
        },
        "objectives": [
            "Find the maximum sum of a subgrid within the given grid.",
            "The subgrid must be a square with equal number of rows and columns.",
            "Return the maximum sum of a subgrid."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_subgrid_sum(grid: List[List[int]]) -> int:\n    rows, cols = len(grid), len(grid[0])\n    max_sum = float('-inf')\n    for size in range(1, min(rows, cols) + 1):\n        for i in range(rows - size + 1):\n            for j in range(cols - size + 1):\n                subgrid_sum = sum(sum(row[j:j+size]) for row in grid[i:i+size])\n                max_sum = max(max_sum, subgrid_sum)\n    return max_sum"
    },
    {
        "function_name": "stock_buy_sell_optimizer",
        "file_name": "stock_price_optimizer.py",
        "parameters": {
            "prices": "List[int] (A list of stock prices)",
            "fee": "int (The transaction fee)"
        },
        "objectives": [
            "Find the maximum profit that can be achieved by buying and selling stocks.",
            "The transaction fee must be considered for each buy and sell operation.",
            "Return the maximum profit."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def stock_buy_sell_optimizer(prices: List[int], fee: int) -> int:\n    if not prices:\n        return 0\n    buy, sell = -prices[0], 0\n    for price in prices[1:]:\n        buy = max(buy, sell - price)\n        sell = max(sell, buy + price - fee)\n    return sell"
    },
    {
        "function_name": "min_cost",
        "file_name": "house_painter.py",
        "parameters": {
            "costs": "List[List[int]] - A 2D list representing the costs of painting houses with different colors.",
            "rules": "List[List[int]] - A list of rules specifying the allowed color combinations."
        },
        "objectives": [
            "Implement a function to determine the minimum cost of painting houses with different colors.",
            "Use dynamic programming to build up a solution from smaller subproblems.",
            "Return the minimum cost."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_cost(costs: List[List[int]], rules: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    \n    dp = [[0] * len(costs[0]) for _ in range(len(costs))]\n    dp[0] = costs[0]\n    \n    for i in range(1, len(costs)):\n        for j in range(len(costs[0])):\n            for k in range(len(costs[0])):\n                if rules[i-1][k] == 1:\n                    dp[i][j] = min(dp[i][j], dp[i-1][k] + costs[i][j])\n    \n    return min(dp[-1])"
    },
    {
        "function_name": "run_length_encoding",
        "file_name": "string_compression.py",
        "parameters": {
            "s": "str (The string to be compressed)"
        },
        "objectives": [
            "Implement a run-length encoding (RLE) algorithm to compress the input string.",
            "Ensure that the algorithm handles consecutive occurrences of the same character correctly.",
            "Return the compressed string."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def run_length_encoding(s):\n    if not s:\n        return \"\"\n    \n    compressed = []\n    count = 1\n    \n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            compressed.append(s[i - 1] + str(count))\n            count = 1\n    \n    compressed.append(s[-1] + str(count))\n    return \"\".join(compressed)"
    },
    {
        "function_name": "find_min_balance_accounts",
        "file_name": "account_balancer.py",
        "parameters": {
            "transactions": "List[List[int]] - A list of transactions, where each transaction is a list of integers representing the account IDs and the amount of money transferred between them."
        },
        "objectives": [
            "Find all accounts that have a minimum balance of zero after all transactions have been applied.",
            "An account's balance is the sum of all positive transactions minus the sum of all negative transactions.",
            "Return a list of account IDs that have a minimum balance of zero."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_min_balance_accounts(transactions: List[List[int]]) -> List[int]:\n    if not transactions or not transactions[0]:\n        return []\n    \n    account_balances = {}\n    \n    for transaction in transactions:\n        for i in range(0, len(transaction), 2):\n            account, amount = transaction[i], transaction[i + 1]\n            if account not in account_balances:\n                account_balances[account] = 0\n            account_balances[account] += amount\n            \n    return [account for account, balance in account_balances.items() if balance >= 0]"
    },
    {
        "function_name": "string_combinations",
        "file_name": "string_brute.py",
        "parameters": {
            "strings": "List[str] (A list of strings)",
            "target": "str (The target string)"
        },
        "objectives": [
            "Find all possible combinations of strings in the input list that can be concatenated to form the target string.",
            "Use dynamic programming to optimize the solution and handle cases where the target string is very long.",
            "Return a list of tuples, where each tuple contains the indices of the strings in the input list that can be concatenated to form the target string."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import itertools"
        ],
        "function_def": "def string_combinations(strings: List[str], target: str) -> List[Tuple[int, ...]]:\n    n = len(strings)\n    dp = [[] for _ in range(len(target) + 1)]\n    dp[0] = [()]\n    \n    for i in range(1, len(target) + 1):\n        for j in range(n):\n            if strings[j] == target[i - 1 - len(strings[j]) + 1:i + 1]:\n                for prev in dp[i - len(strings[j])]:\n                    dp[i].append(prev + (j,))\n    \n    return dp[-1]"
    },
    {
        "function_name": "max_sub_matrix_size",
        "file_name": "matrix_search.py",
        "parameters": {
            "nums": "List[List[int]] (A 2D list of integers representing a matrix)",
            "threshold": "int (The threshold value)"
        },
        "objectives": [
            "Find the maximum sub-matrix within the given matrix where the sum of elements in the sub-matrix is less than or equal to the threshold.",
            "Use a prefix sum array approach to optimize the solution.",
            "Return the maximum size of the sub-matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_sub_matrix_size(nums: List[List[int]], threshold: int) -> int:\n    rows, cols = len(nums), len(nums[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + nums[i - 1][j - 1]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for last_col in range(j, cols + 1):\n                    sub_matrix_sum = prefix_sum[k][last_col] - prefix_sum[k][j - 1] - prefix_sum[i - 1][last_col] + prefix_sum[i - 1][j - 1]\n                    if sub_matrix_sum <= threshold:\n                        max_size = max(max_size, (k - i + 1) * (last_col - j + 1))\n    \n    return max_size"
    },
    {
        "function_name": "list_intersection",
        "file_name": "set_operations.py",
        "parameters": {
            "A": "List[int] (A list of integers)",
            "B": "List[int] (A list of integers)"
        },
        "objectives": [
            "Find the intersection of two lists A and B.",
            "Return a list of elements that are common to both A and B.",
            "Ensure that the elements in the output list are in the same order as they appear in A."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def list_intersection(A: List[int], B: List[int]) -> List[int]:\n    set_B = set(B)\n    result = []\n    for a in A:\n        if a in set_B:\n            result.append(a)\n            set_B.remove(a)\n    \n    return result"
    },
    {
        "function_name": "find_unique_quadruplets",
        "file_name": "quadruplet_sum.py",
        "parameters": {
            "nums": "List[int]",
            "target": "int"
        },
        "objectives": [
            "Find all unique quadruplets in the list of numbers that sum up to the target value.",
            "Use a two-pointer technique to reduce the search space and improve efficiency.",
            "Ensure that the quadruplets are unique and the numbers in each quadruplet are distinct."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_unique_quadruplets(nums: List[int], target: int) -> List[List[int]]:\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left, right = j + 1, len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n    \n    return result"
    },
    {
        "function_name": "convert_to_zigzag",
        "file_name": "zigzag_converter.py",
        "parameters": {
            "s": "str",
            "rows": "int"
        },
        "objectives": [
            "Convert the input string into a zigzag pattern with the specified number of rows.",
            "Then, read off the characters in each row to form the result string.",
            "Ensure that the empty rows are handled correctly and the result string is coherent."
        ],
        "import_lines": [],
        "function_def": "def convert_to_zigzag(s: str, rows: int) -> str:\n    if rows == 1 or rows >= len(s):\n        return s\n    \n    rows_list = [''] * rows\n    index, step = 0, -1\n    \n    for char in s:\n        rows_list[index] += char\n        if index == 0:\n            step = 1\n        elif index == rows - 1:\n            step = -1\n        index += step\n    \n    return ''.join(rows_list)"
    },
    {
        "function_name": "transpose_and_reverse",
        "file_name": "matrix_transformer.py",
        "parameters": {
            "matrix": "List[List[int]]"
        },
        "objectives": [
            "Transpose the input matrix and then reverse each row to form the result matrix.",
            "Use a built-in function or a custom implementation to transpose the matrix.",
            "Ensure that the result matrix is correct and the rows are reversed correctly."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def transpose_and_reverse(matrix: List[List[int]]) -> List[List[int]]:\n    return [list(reversed(row)) for row in zip(*matrix)]"
    },
    {
        "function_name": "split_string",
        "file_name": "string_parser.py",
        "parameters": {
            "string": "str (A string containing letters and numbers)"
        },
        "objectives": [
            "Find all possible ways to split the string into numbers and letters.",
            "Ensure the function handles cases where the string starts or ends with a number.",
            "Return the splits as a list of tuples."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from itertools import groupby"
        ],
        "function_def": "def split_string(string: str) -> List[Tuple[str, str]]:\n    groups = []\n    for key, group in groupby(string, str.isdigit):\n        groups.append(''.join(group))\n    \n    splits = []\n    for i in range(len(groups)):\n        if groups[i].isdigit():\n            splits.append((groups[i], ''))\n        else:\n            splits.append((''.join(groups[:i]), groups[i]))\n            splits.append((groups[i], ''.join(groups[i+1:])))\n    \n    return splits"
    },
    {
        "function_name": "count_sequences_sum",
        "file_name": "sequence_analyzer.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of integer sequences)",
            "target_sum": "int (The target sum for the sequences)"
        },
        "objectives": [
            "Implement a function to find the number of sequences that sum up to the target sum.",
            "Use dynamic programming to efficiently count the sequences.",
            "Return the number of sequences."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def count_sequences_sum(sequences: List[List[int]], target_sum: int) -> int:\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    \n    for sequence in sequences:\n        for i in range(target_sum, -1, -1):\n            for num in sequence:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n    \n    return dp[target_sum]"
    },
    {
        "function_name": "perception_clustering",
        "file_name": "perceptionClustering.py",
        "parameters": {
            "perceptions": "List[List[float]] (A list of perceptions represented as 2D vectors)",
            "clusters": "int (The number of clusters to group perceptions into)"
        },
        "objectives": [
            "Implement a function to group perceptions into clusters using the K-Means algorithm.",
            "Ensure that the initial centroids are randomly selected from the perceptions.",
            "Use the Euclidean distance to measure the distance between perceptions and centroids.",
            "Return the cluster assignments and centroids."
        ],
        "import_lines": [
            "from typing import List",
            "import random",
            "import numpy as np"
        ],
        "function_def": "def perception_clustering(perceptions: List[List[float]], clusters: int) -> (List[int], List[List[float]]):\n    centroids = random.sample(perceptions, clusters)\n    cluster_assignments = [0] * len(perceptions)\n    \n    while True:\n        # Assign each perception to the closest centroid\n        for i, perception in enumerate(perceptions):\n            min_distance = float('inf')\n            for j, centroid in enumerate(centroids):\n                distance = np.linalg.norm(np.array(perception) - np.array(centroid))\n                if distance < min_distance:\n                    min_distance = distance\n                    cluster_assignments[i] = j\n        \n        # Update the centroids\n        new_centroids = []\n        for i in range(clusters):\n            cluster_perceptions = [perception for j, perception in enumerate(perceptions) if cluster_assignments[j] == i]\n            if cluster_perceptions:\n                centroid = np.mean(cluster_perceptions, axis=0).tolist()\n                new_centroids.append(centroid)\n        \n        # Check for convergence\n        if np.all(np.array(centroids) == np.array(new_centroids)):\n            break\n        \n        centroids = new_centroids\n    \n    return cluster_assignments, centroids"
    },
    {
        "function_name": "min_bit_flips",
        "file_name": "min_bit_flips.py",
        "parameters": {
            "`bitstrings": "List[str]` (A list of bitstrings)",
            "`target": "str` (The target bitstring)"
        },
        "objectives": [
            "Implement a function that calculates the minimum number of bit flips required to transform each bitstring into the target bitstring.",
            "Use the Hamming distance metric to calculate the number of bit flips.",
            "Return the minimum number of bit flips and the corresponding bitstring."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_bit_flips(bitstrings: List[str], target: str) -> (int, str):\n    min_flips = float('inf')\n    min_bitstring = ''\n    \n    for bitstring in bitstrings:\n        flips = sum(el1 != el2 for el1, el2 in zip(bitstring, target))\n        if flips < min_flips:\n            min_flips = flips\n            min_bitstring = bitstring\n    \n    return min_flips, min_bitstring"
    },
    {
        "function_name": "anomaly_detector",
        "file_name": "transaction_analyzer.py",
        "parameters": {
            "transactions": "List[Dict[str, int]] (A list of transactions where each transaction is a dictionary containing the 'sender', 'receiver', and 'amount')",
            "sender": "str (The sender's ID)",
            "threshold": "int (The minimum transaction amount to be considered)"
        },
        "objectives": [
            "Implement a function to detect transaction anomalies for a given sender.",
            "Calculate the average transaction amount for the sender and identify transactions that are at least 2 standard deviations away from the average.",
            "Return a list of anomaly transactions."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import numpy as np"
        ],
        "function_def": "def anomaly_detector(transactions: List[Dict[str, int]], sender: str, threshold: int) -> List[Dict[str, int]]:\n    sender_transactions = [transaction['amount'] for transaction in transactions if transaction['sender'] == sender]\n    avg = np.mean(sender_transactions)\n    std_dev = np.std(sender_transactions)\n    anomalies = [transaction for transaction in transactions if transaction['sender'] == sender and transaction['amount'] > avg + 2 * std_dev and transaction['amount'] > threshold]\n    return anomalies"
    },
    {
        "function_name": "spiral_cumulative_sum",
        "file_name": "spiral_traversal.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix)",
            "K": "int (The target sum)"
        },
        "objectives": [
            "Perform a spiral traversal of the matrix.",
            "For each element in the traversal order, calculate the cumulative sum.",
            "Return a list of indices of elements whose cumulative sum equals the target sum K."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def spiral_cumulative_sum(matrix: List[List[int]], K: int) -> List[Tuple[int, int]]:\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    cumulative_sum = 0\n    result = []\n    indices = []\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            cumulative_sum += matrix[top][i]\n            indices.append((top, i))\n            if cumulative_sum == K:\n                result.append(indices[-1])\n        \n        top += 1\n        \n        for i in range(top, bottom + 1):\n            cumulative_sum += matrix[i][right]\n            indices.append((i, right))\n            if cumulative_sum == K:\n                result.append(indices[-1])\n        \n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                cumulative_sum += matrix[bottom][i]\n                indices.append((bottom, i))\n                if cumulative_sum == K:\n                    result.append(indices[-1])\n            \n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                cumulative_sum += matrix[i][left]\n                indices.append((i, left))\n                if cumulative_sum == K:\n                    result.append(indices[-1])\n            \n            left += 1\n    \n    return result"
    },
    {
        "function_name": "substring_checksum",
        "file_name": "substring_checksum.py",
        "parameters": {
            "s": "str (The input string)",
            "k": "int (The target length)"
        },
        "objectives": [
            "Find all k-length substrings of the input string.",
            "Calculate the checksum of each substring using ASCII character values.",
            "Return a dictionary mapping each substring to its checksum."
        ],
        "import_lines": [
            "from typing import Dict"
        ],
        "function_def": "def substring_checksum(s: str, k: int) -> Dict[str, int]:\n    checksums = {}\n    \n    for i in range(len(s) - k + 1):\n        substring = s[i:i + k]\n        checksum = sum(ord(char) for char in substring)\n        checksums[substring] = checksum\n    \n    return checksums"
    },
    {
        "function_name": "maximum_sum_path",
        "file_name": "triangle_d_program.py",
        "parameters": {
            "triangle": "List[List[int]] (A 2D list representing the triangle)"
        },
        "objectives": [
            "Perform a bottom-up dynamic programming to calculate the maximum sum path from the top to the bottom of the triangle.",
            "Each step can move either left or right to the adjacent element.",
            "Return the maximum sum path."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def maximum_sum_path(triangle: List[List[int]]) -> List[int]:\n    rows = len(triangle)\n    dp = [[0] * len(row) for row in triangle]\n    dp[0][0] = triangle[0][0]\n    \n    for i in range(1, rows):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + triangle[i][j]\n            elif j == len(triangle[i]) - 1:\n                dp[i][j] = dp[i - 1][j - 1] + triangle[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]\n    \n    max_sum = max(dp[-1])\n    max_index = dp[-1].index(max_sum)\n    max_path = [max_sum]\n    for i in range(rows - 2, -1, -1):\n        if max_index == 0:\n            max_path.insert(0, dp[i][max_index])\n            max_index = max_index\n        elif max_index == len(triangle[i]) - 1:\n            max_path.insert(0, dp[i][max_index - 1])\n            max_index = max_index - 1\n        else:\n            if dp[i][max_index - 1] > dp[i][max_index]:\n                max_path.insert(0, dp[i][max_index - 1])\n                max_index = max_index - 1\n            else:\n                max_path.insert(0, dp[i][max_index])\n                max_index = max_index\n    \n    return max_path"
    },
    {
        "function_name": "maximum_overlap",
        "file_name": "event_overlap.py",
        "parameters": {
            "events": "List[Tuple[int, int]] (A list of events with start and end times)"
        },
        "objectives": [
            "Implement a sweep line algorithm to find the maximum number of overlapping events.",
            "Return the maximum overlap count."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def maximum_overlap(events: List[Tuple[int, int]]) -> int:\n    points = []\n    for start, end in events:\n        points.append((start, 1))\n        points.append((end, -1))\n    \n    points.sort()\n    max_overlap = 0\n    current_overlap = 0\n    \n    for _, delta in points:\n        current_overlap += delta\n        max_overlap = max(max_overlap, current_overlap)\n    \n    return max_overlap"
    },
    {
        "function_name": "moving_averages",
        "file_name": "moving_averages.py",
        "parameters": {
            "`sequence`": "`List[int]` (A list of integers representing a sequence of numbers)",
            "`window_size`": "`int` (The size of the window for the moving average)"
        },
        "objectives": [
            "Calculate the moving average of the sequence for each window of a given size.",
            "Return a list of the moving averages for each window.",
            "Handle cases where the window size is larger than the sequence or the sequence is empty."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def moving_averages(sequence: List[int], window_size: int) -> List[float]:\n    if window_size > len(sequence) or window_size <= 0:\n        return []\n    \n    averages = []\n    \n    for i in range(len(sequence) - window_size + 1):\n        window_sum = sum(sequence[i:i + window_size])\n        average = window_sum / window_size\n        averages.append(average)\n        \n    return averages"
    },
    {
        "function_name": "evaluate_expression",
        "file_name": "expression_evaluator.py",
        "parameters": {
            "expression": "str (A string representing a mathematical expression)"
        },
        "objectives": [
            "Implement the Shunting-yard algorithm to parse the mathematical expression and evaluate its value.",
            "Handle cases where the input expression is invalid or contains invalid characters.",
            "Return the evaluated value of the expression."
        ],
        "import_lines": [],
        "function_def": "def evaluate_expression(expression):\n    if not expression:\n        raise ValueError(\"Invalid input\")\n    \n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    output_queue = []\n    operator_stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            output_queue.append(int(char))\n        elif char in precedence:\n            while (operator_stack and \n                   operator_stack[-1] in precedence and \n                   precedence[operator_stack[-1]] >= precedence[char]):\n                output_queue.append(operator_stack.pop())\n            operator_stack.append(char)\n        elif char == '(':\n            operator_stack.append(char)\n        elif char == ')':\n            while operator_stack[-1] != '(':\n                output_queue.append(operator_stack.pop())\n            operator_stack.pop()\n    \n    while operator_stack:\n        output_queue.append(operator_stack.pop())\n    \n    evaluation_stack = []\n    for token in output_queue:\n        if token in precedence:\n            operand2 = evaluation_stack.pop()\n            operand1 = evaluation_stack.pop()\n            if token == '+':\n                evaluation_stack.append(operand1 + operand2)\n            elif token == '-':\n                evaluation_stack.append(operand1 - operand2)\n            elif token == '*':\n                evaluation_stack.append(operand1 * operand2)\n            elif token == '/':\n                evaluation_stack.append(operand1 / operand2)\n        else:\n            evaluation_stack.append(token)\n    \n    return evaluation_stack[0]"
    },
    {
        "function_name": "binarize_matrix",
        "file_name": "matrix_binarizer.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list representing a matrix)",
            "threshold": "int (The threshold value)"
        },
        "objectives": [
            "Develop a function that binarizes a given matrix based on a threshold value.",
            "The binarization process involves replacing all values greater than the threshold with 1 and all values less than or equal to the threshold with 0.",
            "The function should also return the number of values that were greater than the threshold."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def binarize_matrix(matrix: List[List[int]], threshold: int) -> (List[List[int]], int):\n    binarized_matrix = []\n    count = 0\n    \n    for row in matrix:\n        binarized_row = []\n        for value in row:\n            if value > threshold:\n                binarized_row.append(1)\n                count += 1\n            else:\n                binarized_row.append(0)\n        binarized_matrix.append(binarized_row)\n    \n    return binarized_matrix, count"
    },
    {
        "function_name": "assign_tasks_to_schedules",
        "file_name": "task_assigner.py",
        "parameters": {
            "schedules": "List[List[int]] (A list of schedules where each schedule is a list of time slots)",
            "tasks": "List[int] (A list of tasks with their respective durations)"
        },
        "objectives": [
            "Develop a function that assigns tasks to schedules based on the availability of time slots.",
            "Each schedule has a list of available time slots and each task has a duration that needs to be accommodated in one of the schedules.",
            "The function should return the updated schedules with the assigned tasks."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def assign_tasks_to_schedules(schedules: List[List[int]], tasks: List[int]) -> List[List[int]]:\n    updated_schedules = []\n    \n    for schedule in schedules:\n        updated_schedule = []\n        remaining_time = schedule[:]\n        \n        for task in tasks:\n            # Find the first available time slot that can accommodate the task\n            for i, time_slot in enumerate(remaining_time):\n                if time_slot >= task:\n                    updated_schedule.append(task)\n                    remaining_time[i] -= task\n                    break\n        \n        updated_schedules.append(updated_schedule)\n    \n    return updated_schedules"
    },
    {
        "function_name": "furthest_building",
        "file_name": "building_reacher.py",
        "parameters": {
            "heights": "List[int]",
            "bricks": "List[int]",
            "ladders": "int"
        },
        "objectives": [
            "Use a priority queue to store the maximum height that can be reached with the given bricks and ladders.",
            "Calculate the maximum number of steps that can be taken without using ladders, based on the brick heights.",
            "Reuse bricks that are not needed for the current step, ensuring that the total number of bricks used is minimized.",
            "Return the furthest building that can be reached."
        ],
        "import_lines": [
            "from typing import List",
            "import heapq"
        ],
        "function_def": "def furthest_building(heights: List[int], bricks: List[int], ladders: int) -> int:\n    heap = []\n    total_bricks_used = 0\n    \n    for i in range(len(heights) - 1):\n        brick_height = heights[i + 1] - heights[i]\n        if brick_height > 0:\n            heapq.heappush(heap, brick_height)\n            total_bricks_used += brick_height\n            \n            if len(heap) > ladders:\n                total_bricks_used -= heapq.heappop(heap)\n                if total_bricks_used > bricks:\n                    return i\n                \n    return len(heights) - 1"
    },
    {
        "function_name": "scheduler",
        "file_name": "scheduler.py",
        "parameters": {
            "tasks": "List[Tuple[int, int]] (A list of tuples containing the duration and deadline of each task)",
            "k": "int (The number of computers available)"
        },
        "objectives": [
            "Use a greedy algorithm to assign tasks to computers, ensuring that each task is completed before its deadline.",
            "Sort tasks by their deadlines, to ensure that the most urgent tasks are completed first.",
            "Assign each task to the computer that becomes available the earliest, to minimize the total processing time.",
            "Return the maximum utilization of any computer."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def scheduler(tasks: List[Tuple[int, int]], k: int) -> int:\n    tasks.sort(key=lambda x: x[1])\n    computers = [0] * k\n    \n    for duration, _ in tasks:\n        min_computer = computers.index(min(computers))\n        computers[min_computer] += duration\n        \n    return max(computers)"
    },
    {
        "function_name": "max_sum.subarray",
        "file_name": "sliding_window.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The size of the window)"
        },
        "objectives": [
            "Implement the sliding window technique to find the maximum sum of a subarray of size k.",
            "Update the window sum by subtracting the outgoing element and adding the incoming element, to avoid recalculating the sum from scratch.",
            "Return the maximum sum of a subarray of size k."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_sum_subarray(nums: List[int], k: int) -> int:\n    if k > len(nums):\n        return None\n    \n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    \n    for i in range(k, len(nums)):\n        window_sum = window_sum - nums[i - k] + nums[i]\n        max_sum = max(max_sum, window_sum)\n        \n    return max_sum"
    },
    {
        "function_name": "stone_game",
        "file_name": "stone_game.py",
        "parameters": {
            "stones": "List[int] (A list of integers representing the stone weights)"
        },
        "objectives": [
            "Implement a dynamic programming algorithm to find the maximum difference in stone weights that can be achieved by dividing the stones into two piles.",
            "Use a bitwise approach to generate all possible subsets of stones and calculate their total weight, to avoid redundant calculations.",
            "Return the maximum difference in stone weights."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def stone_game(stones: List[int]) -> int:\n    total_weight = sum(stones)\n    n = len(stones)\n    dp = [[False] * (total_weight // 2 + 1) for _ in range(n + 1)]\n    \n    dp[0][0] = True\n    \n    for i in range(1, n + 1):\n        weight = stones[i - 1]\n        for j in range(total_weight // 2, -1, -1):\n            if j < weight:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weight]\n                \n    max_diff = 0\n    for i in range(total_weight // 2, -1, -1):\n        if dp[n][i]:\n            max_diff = total_weight - 2 * i\n            break\n            \n    return max_diff"
    },
    {
        "function_name": "vowel_analyzer",
        "file_name": "text_inspector.py",
        "parameters": {
            "text": "str (A block of text for analysis)"
        },
        "objectives": [
            "Count the total number of vowels in the text, disregarding case sensitivity.",
            "Identify the sentences in the text that contain the most vowels.",
            "Return a tuple containing the total count of vowels and a list of sentences with the most vowels."
        ],
        "import_lines": [
            "from typing import Tuple"
        ],
        "function_def": "def vowel_analyzer(text: str) -> Tuple[int, list]:\n    sentences = text.split('.')\n    vowels = 'aeiouAEIOU'\n    total_vowels = 0\n    max_vowels = 0\n    sentences_with_max_vowels = []\n    \n    for sentence in sentences:\n        vowel_count = sum(1 for char in sentence if char in vowels)\n        total_vowels += vowel_count\n        if vowel_count > max_vowels:\n            max_vowels = vowel_count\n            sentences_with_max_vowels = [sentence.strip()]\n        elif vowel_count == max_vowels:\n            sentences_with_max_vowels.append(sentence.strip())\n    \n    return total_vowels, sentences_with_max_vowels"
    },
    {
        "function_name": "maze_generator",
        "file_name": "maze_creator.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D grid of integers)"
        },
        "objectives": [
            "Implement the Recursive Backtracking algorithm to generate a random maze within the given grid.",
            "Return a 2D list representing the generated maze."
        ],
        "import_lines": [
            "import random",
            "from typing import List"
        ],
        "function_def": "def maze_generator(grid: List[List[int]]) -> List[List[int]]:\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    maze = [[0 for _ in range(cols)] for _ in range(rows)]\n    stack = [(0, 0)]\n    \n    while stack:\n        row, col = stack[-1]\n        maze[row][col] = 1\n        directions_list = list(directions)\n        random.shuffle(directions_list)\n        for dr, dc in directions_list:\n            nr, nc = row + 2 * dr, col + 2 * dc\n            if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 0:\n                maze[nr - dr][nc - dc] = 1\n                stack.append((nr, nc))\n                break\n        else:\n            stack.pop()\n    \n    return maze"
    },
    {
        "function_name": "filtered_subsequences",
        "file_name": "subsequence_generator.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "k": "int (The length of the subsequence)",
            "threshold": "int (The threshold value)"
        },
        "objectives": [
            "Design a function to find all possible subsequences of length k from the given list of integers.",
            "Filter out subsequences whose product is less than the given threshold value.",
            "Return the list of filtered subsequences."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import itertools"
        ],
        "function_def": "def filtered_subsequences(nums: List[int], k: int, threshold: int) -> List[Tuple[int, ...]]:\n    subsequences = list(itertools.combinations(nums, k))\n    filtered_subsequences = [subsequence for subsequence in subsequences if all(num != 0 for num in subsequence) and abs(subsequence[0] * subsequence[1] * subsequence[2]) >= threshold]\n    return filtered_subsequences"
    },
    {
        "function_name": "nearest_points",
        "file_name": "point_locator.py",
        "parameters": {
            "points": "List[Tuple[int, int]] (A list of points on the 2D plane)",
            "k": "int (The number of nearest points to find)"
        },
        "objectives": [
            "Implement a function to find the k nearest points to the origin (0, 0) on the 2D plane.",
            "Use the Euclidean distance formula to calculate distances between points.",
            "Return the list of k nearest points."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import heapq"
        ],
        "function_def": "def nearest_points(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]:\n    if k > len(points):\n        return points\n    \n    distances = [(point[0]**2 + point[1]**2, point) for point in points]\n    k_nearest_points = heapq.nsmallest(k, distances)\n    return [point[1] for point in k_nearest_points]"
    },
    {
        "function_name": "triangle_classifier",
        "file_name": "triangle_classifier.py",
        "parameters": {
            "triangles": "List[List[int]] (A list of triangles where each triangle is represented by a list of three sides)"
        },
        "objectives": [
            "Design a function to classify each triangle as equilateral, isosceles, or scalene.",
            "Use the triangle inequality theorem to validate the input triangles.",
            "Return a dictionary with the classification of each triangle."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def triangle_classifier(triangles: List[List[int]]) -> Dict[str, int]:\n    classification = {\"equilateral\": 0, \"isosceles\": 0, \"scalene\": 0, \"invalid\": 0}\n    \n    for triangle in triangles:\n        triangle.sort()\n        if triangle[0] + triangle[1] <= triangle[2]:\n            classification[\"invalid\"] += 1\n            continue\n        if triangle[0] == triangle[1] == triangle[2]:\n            classification[\"equilateral\"] += 1\n        elif triangle[0] == triangle[1] or triangle[1] == triangle[2]:\n            classification[\"isosceles\"] += 1\n        else:\n            classification[\"scalene\"] += 1\n    \n    return classification"
    },
    {
        "function_name": "merge_intervals",
        "file_name": "interval_merger.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] (A list of tuples containing the start and end times of each interval)",
            "k": "int (The number of intervals to merge)"
        },
        "objectives": [
            "Use a greedy algorithm to select the k intervals with the largest end times.",
            "Merge these intervals by finding the earliest start time and the latest end time among them.",
            "If two or more intervals have the same end time, choose the one with the earliest start time.",
            "Return the merged interval."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def merge_intervals(intervals: List[Tuple[int, int]], k: int) -> Tuple[int, int]:\n    intervals.sort(key=lambda x: (-x[1], x[0]))  # sort by end time and then by start time\n    merged_intervals = intervals[:k]\n    start = min(interval[0] for interval in merged_intervals)\n    end = max(interval[1] for interval in merged_intervals)\n    return start, end"
    },
    {
        "function_name": "common_substrings",
        "file_name": "substring_frequencies.py",
        "parameters": {
            "sequence": "str (A string of characters)",
            "k": "int (The length of the substrings to consider)",
            "threshold": "float (The minimum frequency for a substring to be considered common)"
        },
        "objectives": [
            "Calculate the frequency of each substring of length `k` in the given sequence.",
            "Identify the common substrings that occur with a frequency above the specified `threshold`.",
            "Return a dictionary where the keys are the common substrings and the values are their frequencies."
        ],
        "import_lines": [
            "from typing import Dict",
            "from collections import defaultdict"
        ],
        "function_def": "def common_substrings(sequence: str, k: int, threshold: float) -> Dict[str, int]:\n    frequencies = defaultdict(int)\n    \n    for i in range(len(sequence) - k + 1):\n        substring = sequence[i:i+k]\n        frequencies[substring] += 1\n    \n    common_substrings = {substring: frequency for substring, frequency in frequencies.items() if frequency / len(sequence) >= threshold}\n    \n    return common_substrings"
    },
    {
        "function_name": "k_shortest_paths",
        "file_name": "graph_traverser.py",
        "parameters": {
            "graph": "Dict[int, List[int]] - An adjacency list representation of a graph.",
            "source": "int - The source node for the search.",
            "target": "int - The target node to find the shortest path to.",
            "k": "int - The number of shortest paths to find."
        },
        "objectives": [
            "Implement a function to find the k shortest paths from the source node to the target node in the graph.",
            "Ensure the function uses a priority queue to efficiently explore the graph.",
            "Return the k shortest paths, or fewer if there are not enough distinct paths."
        ],
        "import_lines": [
            "import heapq",
            "from typing import Dict, List"
        ],
        "function_def": "def k_shortest_paths(graph: Dict[int, List[int]], source: int, target: int, k: int) -> List[List[int]]:\n    queue = [(0, [source])]\n    paths = []\n    \n    while queue and len(paths) < k:\n        (path_cost, path) = heapq.heappop(queue)\n        \n        if path[-1] == target:\n            paths.append(path)\n        else:\n            for neighbor in graph[path[-1]]:\n                if neighbor not in path:\n                    heapq.heappush(queue, (path_cost + 1, path + [neighbor]))\n    \n    return paths"
    },
    {
        "function_name": "high_value_transactions",
        "file_name": "transaction_analyzer.py",
        "parameters": {
            "transactions": "List[Tuple[str, str, int]] - A list of transactions where each transaction is a tuple containing the sender, receiver, and amount.",
            "sender": "str - The sender's ID.",
            "threshold": "int - The minimum amount required for a transaction to be considered high-value."
        },
        "objectives": [
            "Implement a function to find all high-value transactions sent by a given sender.",
            "Ensure the function uses a set to efficiently keep track of the receivers.",
            "Return a dictionary mapping each receiver to the total amount sent."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict"
        ],
        "function_def": "def high_value_transactions(transactions: List[Tuple[str, str, int]], sender: str, threshold: int) -> Dict[str, int]:\n    receivers = set()\n    amounts = {}\n    \n    for transaction in transactions:\n        if transaction[0] == sender and transaction[2] >= threshold:\n            receiver = transaction[1]\n            receivers.add(receiver)\n            amounts[receiver] = amounts.get(receiver, 0) + transaction[2]\n    \n    return {receiver: amount for receiver, amount in amounts.items() if amount >= threshold}"
    },
    {
        "function_name": "min_rooms_required",
        "file_name": "room_scheduler.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] - A list of intervals where each interval is a tuple containing the start and end times.",
            "num_rooms": "int - The number of rooms available."
        },
        "objectives": [
            "Implement a function to find the minimum number of rooms required to accommodate all the meetings.",
            "Ensure the function uses a priority queue to efficiently schedule the meetings.",
            "Return the minimum number of rooms required."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List, Tuple"
        ],
        "function_def": "def min_rooms_required(intervals: List[Tuple[int, int]], num_rooms: int) -> int:\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[0])\n    rooms = []\n    \n    for start, end in intervals:\n        if rooms and rooms[0] <= start:\n            heapq.heappop(rooms)\n        heapq.heappush(rooms, end)\n    \n    return len(rooms)"
    },
    {
        "function_name": "bidirectional_search",
        "file_name": "bidirectional_search.py",
        "parameters": {
            "graph": "List[List[int]] (An adjacency matrix representation of a graph)",
            "start_node": "int (The node to start the search from)",
            "end_node": "int (The node to search for)"
        },
        "objectives": [
            "Implement a bidirectional search algorithm to find the shortest path between the start node and the end node in the graph.",
            "Use a breadth-first search approach from both the start node and the end node to reduce the search space.",
            "Handle cases where there is no path between the start node and the end node."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def bidirectional_search(graph: List[List[int]], start_node: int, end_node: int) -> List[int]:\n    num_nodes = len(graph)\n    start_queue = deque([start_node])\n    end_queue = deque([end_node])\n    start_visited = [False] * num_nodes\n    end_visited = [False] * num_nodes\n    start_parent = [None] * num_nodes\n    end_parent = [None] * num_nodes\n    \n    while start_queue or end_queue:\n        if start_queue:\n            current_node = start_queue.popleft()\n            start_visited[current_node] = True\n            for neighbor, edge in enumerate(graph[current_node]):\n                if edge == 1 and not start_visited[neighbor]:\n                    start_queue.append(neighbor)\n                    start_parent[neighbor] = current_node\n                    if end_visited[neighbor]:\n                        break\n        if end_queue:\n            current_node = end_queue.popleft()\n            end_visited[current_node] = True\n            for neighbor, edge in enumerate(graph[current_node]):\n                if edge == 1 and not end_visited[neighbor]:\n                    end_queue.append(neighbor)\n                    end_parent[neighbor] = current_node\n                    if start_visited[neighbor]:\n                        break\n        else:\n            continue\n        break\n    if current_node is None:\n        return []\n    \n    path = []\n    while current_node is not None:\n        path.append(current_node)\n        current_node = start_parent[current_node] if current_node != start_node else None\n    path.reverse()\n    \n    for i in range(1, len(path)):\n        current_node = end_parent[path[i]]\n        while current_node != path[i]:\n            path.insert(i, current_node)\n            current_node = end_parent[current_node]\n    \n    return path"
    },
    {
        "function_name": "collision_detection",
        "file_name": "collision_detector.py",
        "parameters": {
            "carts": "List[Tuple[int, int]] (A list of tuples representing the positions and velocities of carts)",
            "tracks": "List[Tuple[int, int]] (A list of tuples representing the positions and directions of tracks)"
        },
        "objectives": [
            "Implement a collision detection algorithm to detect collisions between carts and tracks.",
            "Handle cases where there are multiple collisions.",
            "Return a list of tuples representing the positions of collisions."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def collision_detection(carts: List[Tuple[int, int]], tracks: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    collisions = []\n    for cart in carts:\n        x, v = cart\n        for track in tracks:\n            tx, td = track\n            if x + v == tx and td == 1:\n                collisions.append((x + v, 0))\n    return collisions"
    },
    {
        "function_name": "point_in_polygon",
        "file_name": "point_in_polygon.py",
        "parameters": {
            "regions": "List[Tuple[int, int]] (A list of tuples representing the positions and radii of regions)",
            "points": "List[Tuple[int, int]] (A list of tuples representing the positions of points)"
        },
        "objectives": [
            "Implement a point-in-polygon algorithm to determine which points are inside each region.",
            "Handle cases where a point is on the boundary of a region.",
            "Return a dictionary where the keys are the regions and the values are lists of points inside each region."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict",
            "import math"
        ],
        "function_def": "def point_in_polygon(regions: List[Tuple[int, int]], points: List[Tuple[int, int]]) -> Dict[Tuple[int, int], List[Tuple[int, int]]]:\n    result = {}\n    for region in regions:\n        x, r = region\n        inside_points = []\n        for point in points:\n            px, py = point\n            distance = math.sqrt((px - x) ** 2 + py ** 2)\n            if distance <= r:\n                inside_points.append(point)\n        result[region] = inside_points\n    return result"
    },
    {
        "function_name": "min_water_needed",
        "file_name": "tree_irrigator.py",
        "parameters": {
            "trees": "List[List[int]] (A list of lists where each sublist represents the nodes in a tree level)",
            "target_height": "int (The target height of the trees)"
        },
        "objectives": [
            "Determine the minimum amount of water needed to irrigate the trees to reach the target height.",
            "Ensure that the function handles cases where the target height is less than the current height of any tree.",
            "Return the minimum amount of water needed."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def min_water_needed(trees: List[List[int]], target_height: int) -> int:\n    total_water = 0\n    queue = deque([(i, x) for i, level in enumerate(trees) for x in level])\n    visited = set((x for level in trees for x in level))\n    \n    while queue:\n        current_level, current_node = queue.popleft()\n        \n        if current_level >= target_height:\n            break\n        \n        for next_node in trees[current_level + 1]:\n            if next_node not in visited and abs(next_node - current_node) <= 1:\n                queue.append((current_level + 1, next_node))\n                visited.add(next_node)\n                total_water += 1\n    \n    return total_water"
    },
    {
        "function_name": "customer_spend",
        "file_name": "order_calculator.py",
        "parameters": {
            "orders": "List[Tuple[str, List[str], float, float]] (A list of orders where each order is represented as a tuple of customer, items, price, and tax rate)"
        },
        "objectives": [
            "Calculate the total price of each order including taxes.",
            "Group the orders by customer and calculate the total amount spent by each customer.",
            "Return a dictionary where the keys are the customers and the values are their total spend."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict",
            "from collections import defaultdict"
        ],
        "function_def": "def customer_spend(orders: List[Tuple[str, List[str], float, float]]) -> Dict[str, float]:\n    customer_spending = defaultdict(float)\n    \n    for customer, items, price, tax_rate in orders:\n        total_price = price * (1 + tax_rate)\n        customer_spending[customer] += total_price\n    \n    return dict(customer_spending)"
    },
    {
        "function_name": "find_max_in_windows",
        "file_name": "window_max.py",
        "parameters": {
            "sequence": "List[int] - A sequence of integers.",
            "k": "int - The length of the sliding window."
        },
        "objectives": [
            "Find the maximum element in each sliding window of the input sequence.",
            "Use a deque to efficiently keep track of the maximum element in the current window.",
            "Return a list of maximum elements."
        ],
        "import_lines": [
            "from collections import deque",
            "from typing import List"
        ],
        "function_def": "def find_max_in_windows(sequence, k):\n    max_elements = []\n    dq = deque()\n    \n    for i in range(len(sequence)):\n        while dq and sequence[dq[-1]] < sequence[i]:\n            dq.pop()\n        dq.append(i)\n        \n        if i - k + 1 >= 0:\n            max_elements.append(sequence[dq[0]])\n            if dq[0] == i - k + 1:\n                dq.popleft()\n    \n    return max_elements"
    },
    {
        "function_name": "schedule_jobs",
        "file_name": "greedy.py",
        "parameters": {
            "`schedule`": "List[int] - A list of job schedules",
            "`k`": "int - The number of jobs to schedule"
        },
        "objectives": [
            "Implement a greedy approach to schedule the jobs to minimize the maximum completion time.",
            "Use a priority queue to keep track of the available processors.",
            "Handle cases where k is larger than the number of available processors."
        ],
        "import_lines": [
            "import heapq"
        ],
        "function_def": "def schedule_jobs(schedule, k):\n    # Create a priority queue to store available processors\n    available_processors = []\n    \n    # Create a list to store the scheduled jobs\n    scheduled_jobs = []\n    \n    for job in schedule:\n        # If there are available processors, schedule the job on the processor with the earliest end time\n        if available_processors:\n            processor_end_time = heapq.heappop(available_processors)\n            scheduled_jobs.append((processor_end_time[1], job))\n            heapq.heappush(available_processors, (processor_end_time[0] + job, processor_end_time[1]))\n        else:\n            # If there are no available processors, schedule the job on a new processor\n            scheduled_jobs.append((0, job))\n            heapq.heappush(available_processors, (job, len(scheduled_jobs) - 1))\n    \n    # Return the scheduled jobs\n    return scheduled_jobs"
    },
    {
        "function_name": "erode_bitmap",
        "file_name": "morphology.py",
        "parameters": {
            "`bitmap`": "List[List[int]] - A 2D bitmap",
            "`threshold`": "int - The threshold value for erosion"
        },
        "objectives": [
            "Implement a mathematical morphology-based approach to perform erosion on the bitmap.",
            "Use a structuring element to define the erosion operation.",
            "Handle cases where the bitmap is empty or the threshold value is invalid."
        ],
        "import_lines": [],
        "function_def": "def erode_bitmap(bitmap, threshold):\n    # Define the structuring element\n    structuring_element = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    \n    # Create a new bitmap to store the eroded result\n    eroded_bitmap = [[0 for _ in range(len(bitmap[0]))] for _ in range(len(bitmap))]\n    \n    # Iterate over pixels in the bitmap\n    for i in range(len(bitmap)):\n        for j in range(len(bitmap[0])):\n            # If the pixel is above the threshold, perform erosion\n            if bitmap[i][j] > threshold:\n                # Create a temporary bitmap to store the eroded pixel values\n                temp_bitmap = [[0 for _ in range(len(bitmap[0]))] for _ in range(len(bitmap))]\n                \n                # Iterate over pixels in the structuring element\n                for k in range(len(structuring_element)):\n                    for l in range(len(structuring_element[0])):\n                        # If the pixel is within the bounds of the bitmap, perform erosion\n                        if 0 <= i + k - 1 < len(bitmap) and 0 <= j + l - 1 < len(bitmap[0]):\n                            temp_bitmap[i + k - 1][j + l - 1] = min(temp_bitmap[i + k - 1][j + l - 1], bitmap[i][j])\n                \n                # Update the eroded pixel value\n                eroded_bitmap[i][j] = max(temp_bitmap[i][j], threshold)\n    \n    # Return the eroded bitmap\n    return eroded_bitmap"
    },
    {
        "function_name": "point_interval_mapper",
        "file_name": "interval_mapper.py",
        "parameters": {
            "intervals": "List[List[int]] (A list of intervals where each interval is a list of two integers)",
            "points": "List[int] (A list of points to check)"
        },
        "objectives": [
            "Determine which points lie within which intervals.",
            "Use a binary search approach to find the interval that each point belongs to.",
            "Return a dictionary mapping each point to its corresponding interval."
        ],
        "import_lines": [
            "from bisect import bisect_left"
        ],
        "function_def": "def point_interval_mapper(intervals, points):\n    intervals.sort(key=lambda x: x[0])\n    start_points = [interval[0] for interval in intervals]\n    end_points = [interval[1] for interval in intervals]\n    mapping = {}\n    \n    for point in points:\n        index = bisect_left(start_points, point)\n        if 0 <= index < len(intervals) and end_points[index] >= point:\n            mapping[point] = intervals[index]\n        else:\n            mapping[point] = None\n    \n    return mapping"
    },
    {
        "function_name": "depth_limited_dfs",
        "file_name": "graph_traversal.py",
        "parameters": {
            "graph": "Dict[str, Dict[str, int]] (A graph represented as an adjacency list)",
            "start_node": "str (The node to start the traversal from)",
            "max_depth": "int (The maximum depth to traverse)"
        },
        "objectives": [
            "Implement a depth-limited DFS traversal on the given graph.",
            "Keep track of the nodes visited at each depth level.",
            "Return a dictionary where the keys are the depth levels and the values are lists of visited nodes."
        ],
        "import_lines": [
            "from typing import Dict, List"
        ],
        "function_def": "def depth_limited_dfs(graph: Dict[str, Dict[str, int]], start_node: str, max_depth: int) -> Dict[int, List[str]]:\n    visited = {}\n    stack = [(start_node, 0)]\n    while stack:\n        node, depth = stack.pop()\n        if node not in visited:\n            visited.setdefault(depth, []).append(node)\n            if depth < max_depth:\n                for neighbor in graph.get(node, {}).keys():\n                    stack.append((neighbor, depth + 1))\n    return visited"
    },
    {
        "function_name": "calculate_statistics",
        "file_name": "statistical_analyzer.py",
        "parameters": {
            "numbers": "List[float] (A list of numbers)",
            "precision": "int (The number of decimal places to round to)",
            "stats": "List[str] (A list of statistical measures to calculate)"
        },
        "objectives": [
            "Calculate the specified statistical measures (mean, median, mode, standard deviation) for the given list of numbers.",
            "Round the results to the specified precision.",
            "Return a dictionary where the keys are the statistical measures and the values are the calculated results."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import statistics",
            "import math"
        ],
        "function_def": "def calculate_statistics(numbers: List[float], precision: int, stats: List[str]) -> Dict[str, float]:\n    results = {}\n    for stat in stats:\n        if stat == \"mean\":\n            results[\"mean\"] = round(statistics.mean(numbers), precision)\n        elif stat == \"median\":\n            results[\"median\"] = round(statistics.median(numbers), precision)\n        elif stat == \"mode\":\n            results[\"mode\"] = round(statistics.mode(numbers), precision)\n        elif stat == \"standard_deviation\":\n            results[\"standard_deviation\"] = round(math.sqrt(sum((x - statistics.mean(numbers)) ** 2 for x in numbers) / len(numbers)), precision)\n    return results"
    },
    {
        "function_name": "find_eigenvector",
        "file_name": "linear_algebra.py",
        "parameters": {
            "matrix": "List[List[float]] (A 2D list representing a matrix)",
            "eigenvalue": "float (The eigenvalue to find the corresponding eigenvector for)"
        },
        "objectives": [
            "Find the eigenvector corresponding to the given eigenvalue for the specified matrix.",
            "Return the eigenvector as a list."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def find_eigenvector(matrix: List[List[float]], eigenvalue: float) -> List[float]:\n    A = np.array(matrix)\n    eigenvalues, eigenvectors = np.linalg.eig(A)\n    for i, e in enumerate(eigenvalues):\n        if np.isclose(e, eigenvalue):\n            return eigenvectors[:, i].tolist()\n    return None"
    },
    {
        "function_name": "gaussian_elimination_solver",
        "file_name": "gaussian_elimination_solver.py",
        "parameters": {
            "matrix": "List[List[float]] - A matrix representing a linear system of equations",
            "vector": "List[float] - The right-hand side vector of the linear system"
        },
        "objectives": [
            "Implement Gaussian elimination with partial pivoting to solve the linear system of equations.",
            "Handle cases where the matrix is singular (non-invertible).",
            "Return the solution vector."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def gaussian_elimination_solver(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    matrix = np.array(matrix, dtype=float)\n    vector = np.array(vector, dtype=float)\n    \n    n = len(matrix)\n    \n    for i in range(n):\n        # Partial pivoting\n        max_el = abs(matrix[i][i])\n        max_row = i\n        for k in range(i+1, n):\n            if abs(matrix[k][i]) > max_el:\n                max_el = abs(matrix[k][i])\n                max_row = k\n        \n        # Swap maximum row with current row\n        matrix[[i, max_row]] = matrix[[max_row, i]]\n        vector[[i, max_row]] = vector[[max_row, i]]\n        \n        # Make all rows below this one 0 in current column\n        for k in range(i+1, n):\n            c = -matrix[k][i]/matrix[i][i]\n            for j in range(i, n):\n                if i == j:\n                    matrix[k][j] = 0\n                else:\n                    matrix[k][j] += c * matrix[i][j]\n            vector[k] += c * vector[i]\n    \n    # Solve equation Ax=b for an upper triangular matrix A\n    solution = [0 for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        solution[i] = vector[i]/matrix[i][i]\n        for k in range(i-1, -1, -1):\n            vector[k] -= matrix[k][i] * solution[i]\n    \n    return solution"
    },
    {
        "function_name": "anagram_substrings",
        "file_name": "anagram_substrings.py",
        "parameters": {
            "s": "str (The input string)",
            "n": "int (The length of the substring)"
        },
        "objectives": [
            "Find all substrings of length n that are anagrams of each other.",
            "Use a sliding window approach to handle long strings efficiently.",
            "Return a list of anagram substrings."
        ],
        "import_lines": [
            "from collections import defaultdict",
            "from typing import List"
        ],
        "function_def": "def anagram_substrings(s: str, n: int) -> List[str]:\n    anagrams = defaultdict(list)\n    for i in range(len(s) - n + 1):\n        sorted_str = \"\".join(sorted(s[i:i + n]))\n        anagrams[sorted_str].append(s[i:i + n])\n        \n    result = []\n    for value in anagrams.values():\n        if len(value) > 1:\n            result.extend(value)\n            \n    return result"
    },
    {
        "function_name": "similar_vertices",
        "file_name": "graph_similarity.py",
        "parameters": {
            "graph": "List[List[int]] - An adjacency matrix representing a graph.",
            "start_vertex": "int - The starting vertex for the graph traversal.",
            "k": "int - The number of vertices to visit."
        },
        "objectives": [
            "Implement a function to find the k most similar vertices to the start vertex in a graph based on their adjacency.",
            "Calculate the similarity score between the start vertex and each other vertex in the graph.",
            "Return the k vertices with the highest similarity scores."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def similar_vertices(graph: List[List[int]], start_vertex: int, k: int) -> List[int]:\n    n = len(graph)\n    similarity_scores = [0] * n\n    similarity_scores[start_vertex] = float('inf')  # Start vertex is not similar to itself\n    \n    for vertex in range(n):\n        if vertex != start_vertex:\n            similarity_scores[vertex] = sum(graph[start_vertex][v] & graph[vertex][v] for v in range(n))\n    \n    top_k_vertices = sorted(range(n), key=lambda x: similarity_scores[x], reverse=True)[:k]\n    \n    return top_k_vertices"
    },
    {
        "function_name": "pattern_matcher",
        "file_name": "string_matcher.py",
        "parameters": {
            "strings": "List[str] (A list of strings)",
            "pattern": "str (The pattern to match)"
        },
        "objectives": [
            "Implement a function to find all strings in a given list that match a specified pattern.",
            "Use regular expressions to match the pattern.",
            "Return a list of strings that match the pattern."
        ],
        "import_lines": [
            "import re",
            "from typing import List"
        ],
        "function_def": "def pattern_matcher(strings: List[str], pattern: str) -> List[str]:\n    return [string for string in strings if re.fullmatch(pattern, string)]"
    },
    {
        "function_name": "max_submatrix_sum",
        "file_name": "matrix_operations.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D list representing a matrix.",
            "k": "int - The size of the sub-matrix."
        },
        "objectives": [
            "Implement a function to find the maximum sum of a k x k sub-matrix within the given matrix.",
            "The function should be able to handle cases where the matrix is empty or k is larger than the matrix size.",
            "If k is larger than the matrix size, the function should return a message indicating that."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_submatrix_sum(matrix: List[List[int]], k: int) -> int:\n    if not matrix or k > len(matrix) or k > len(matrix[0]):\n        return \"k is larger than the matrix size\"\n    \n    max_sum = float('-inf')\n    for i in range(len(matrix) - k + 1):\n        for j in range(len(matrix[0]) - k + 1):\n            submatrix_sum = sum(matrix[x][y] for x in range(i, i + k) for y in range(j, j + k))\n            max_sum = max(max_sum, submatrix_sum)\n    \n    return max_sum"
    },
    {
        "function_name": "most_frequent_motif",
        "file_name": "dna_analysis.py",
        "parameters": {
            "sequences": "List[str] - A list of DNA sequences.",
            "k": "int - The length of the motif."
        },
        "objectives": [
            "Implement a function to find the most frequent k-mer (motif) in the given DNA sequences.",
            "The function should be able to handle cases where the sequences are empty or k is larger than the sequence length.",
            "If k is larger than the sequence length, the function should return a message indicating that."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def most_frequent_motif(sequences: List[str], k: int) -> str:\n    if not sequences or k > len(sequences[0]):\n        return \"k is larger than the sequence length\"\n    \n    motif_count = defaultdict(int)\n    for sequence in sequences:\n        for i in range(len(sequence) - k + 1):\n            motif = sequence[i:i + k]\n            motif_count[motif] += 1\n    \n    return max(motif_count, key=motif_count.get)"
    },
    {
        "function_name": "median_of_subarrays",
        "file_name": "median_calculator.py",
        "parameters": {
            "numbers": "List[int] - A list of integers.",
            "k": "int - The size of the sub-array."
        },
        "objectives": [
            "Implement a function to find the median of all k-sized sub-arrays within the given list of numbers.",
            "The function should be able to handle cases where the list is empty or k is larger than the list size.",
            "If k is larger than the list size, the function should return a message indicating that."
        ],
        "import_lines": [
            "from typing import List",
            "import statistics"
        ],
        "function_def": "def median_of_subarrays(numbers: List[int], k: int) -> list:\n    if not numbers or k > len(numbers):\n        return \"k is larger than the list size\"\n    \n    medians = []\n    for i in range(len(numbers) - k + 1):\n        subarray = numbers[i:i + k]\n        medians.append(statistics.median(subarray))\n    \n    return medians"
    },
    {
        "function_name": "edf_scheduling",
        "file_name": "scheduling_algorithms.py",
        "parameters": {
            "schedule": "List[List[int]] (A 2D list of job schedules)",
            "processors": "int (The number of processors)"
        },
        "objectives": [
            "Implement a job scheduling algorithm to schedule the jobs on the processors.",
            "Use the EDF (Earliest Deadline First) scheduling algorithm to minimize the number of missed deadlines.",
            "Return a list of scheduled jobs, one for each processor."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def edf_scheduling(schedule: List[List[int]], processors: int) -> List[List[List[int]]]:\n    scheduled_jobs = [[] for _ in range(processors)]\n    current_time = 0\n    \n    while schedule:\n        schedule.sort(key=lambda x: x[1])\n        for i in range(processors):\n            if schedule:\n                job = schedule.pop(0)\n                if job[1] < current_time:\n                    return []\n                scheduled_jobs[i].append(job)\n                current_time += job[0]\n    \n    return scheduled_jobs"
    },
    {
        "function_name": "apply_box_blur",
        "file_name": "image_processing.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list representing an image)"
        },
        "objectives": [
            "Apply a box blur effect to the image.",
            "Calculate the average pixel value for each 3x3 sub-matrix.",
            "Replace each pixel with the average value of its surrounding pixels."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def apply_box_blur(matrix: List[List[int]]) -> List[List[int]]:\n    blurred_matrix = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            total = 0\n            count = 0\n            for x in range(max(0, i-1), min(len(matrix), i+2)):\n                for y in range(max(0, j-1), min(len(matrix[0]), j+2)):\n                    total += matrix[x][y]\n                    count += 1\n            blurred_matrix[i][j] = total // count\n    \n    return blurred_matrix"
    },
    {
        "function_name": "find_busiest_airport",
        "file_name": "route_analysis.py",
        "parameters": {
            "routes": "List[Tuple[str, str]] (A list of tuples representing flight routes where each tuple contains the departure and arrival airports)"
        },
        "objectives": [
            "Create an adjacency list to represent the graph of flight routes.",
            "Find the airport with the most connections.",
            "Return the airport with the most connections and its connections."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from collections import defaultdict"
        ],
        "function_def": "def find_busiest_airport(routes: List[Tuple[str, str]]) -> Tuple[str, List[str]]:\n    graph = defaultdict(list)\n    for departure, arrival in routes:\n        graph[departure].append(arrival)\n        graph[arrival].append(departure)\n    \n    busiest_airport = max(graph, key=lambda x: len(graph[x]))\n    return busiest_airport, graph[busiest_airport]"
    },
    {
        "function_name": "word_wrap",
        "file_name": "word_wrapper.py",
        "parameters": {
            "text": "str (The input text)",
            "width": "int (The target width)"
        },
        "objectives": [
            "Perform word wrapping on the input text to fit within the target width.",
            "Determine the optimal line breaks to minimize the number of lines.",
            "Return a list of lines, where each line is a string."
        ],
        "import_lines": [],
        "function_def": "def word_wrap(text: str, width: int) -> list:\n    words = text.split()\n    n = len(words)\n    dp = [float('inf')] * (n + 1)\n    result = [''] * n\n    \n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        line_length = 0\n        for j in range(i, 0, -1):\n            line_length += len(words[j - 1]) + 1\n            if line_length > width:\n                break\n            if dp[j - 1] + (width - line_length) ** 2 < dp[i]:\n                dp[i] = dp[j - 1] + (width - line_length) ** 2\n                result[i - 1] = ' '.join(words[j - 1:i])\n    \n    lines = []\n    i = n\n    while i > 0:\n        lines.append(result[i - 1])\n        i -= len(result[i - 1].split())\n    \n    return lines[::-1]"
    },
    {
        "function_name": "bfs_shortest_distance",
        "file_name": "bfs_shortest_distance_finder.py",
        "parameters": {
            "graph": "Dict[str, list] (The input graph as an adjacency list)",
            "start": "str (The start node)"
        },
        "objectives": [
            "Perform a breadth-first search (BFS) on the input graph starting from the given node.",
            "Determine the shortest distance from the start node to all other nodes.",
            "Return a dictionary mapping each node to its shortest distance from the start node."
        ],
        "import_lines": [
            "from collections import deque"
        ],
        "function_def": "def bfs_shortest_distance(graph: dict, start: str) -> dict:\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if distances[neighbor] > distances[node] + 1:\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n    \n    return distances"
    },
    {
        "function_name": "transpose_matrix",
        "file_name": "matrix_ops.py",
        "parameters": {
            "`mat`": "`List[List[int]]` (A 2D matrix to process)",
            "`k`": "`int` (The number of rows to transpose)"
        },
        "objectives": [
            "Implement a function to transpose a 2D matrix, up to a given number of rows.",
            "Use a list comprehension to efficiently transpose the matrix.",
            "Return the transposed matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def transpose_matrix(mat: List[List[int]], k: int) -> List[List[int]]:\n    return [[row[i] for row in mat[:k]] for i in range(len(mat[0]))]"
    },
    {
        "function_name": "cluster_points",
        "file_name": "clustering.py",
        "parameters": {
            "`points`": "`List[Tuple[int, int]]` (A list of 2D points to process)",
            "`threshold`": "`int` (A distance threshold to use when clustering points)"
        },
        "objectives": [
            "Implement a function to cluster 2D points into groups based on their proximity to each other.",
            "Use a DBSCAN algorithm to efficiently cluster the points.",
            "Return a list of clusters, where each cluster is a list of points."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from sklearn.cluster import DBSCAN"
        ],
        "function_def": "def cluster_points(points: List[Tuple[int, int]], threshold: int) -> List[List[Tuple[int, int]]]:\n    clustering = DBSCAN(eps=threshold, min_samples=2).fit(points)\n    labels = clustering.labels_\n    clusters = [[] for _ in range(max(labels) + 1)]\n    for i, label in enumerate(labels):\n        clusters[label].append(points[i])\n    return clusters"
    },
    {
        "function_name": "generate_association_rules",
        "file_name": "association_rule_generator.py",
        "parameters": {
            "transactions": "List[List[str]] (A list of transactions where each transaction is a list of items)",
            "min_confidence": "float (The minimum confidence threshold for the rules)"
        },
        "objectives": [
            "Implement the Apriori algorithm to generate association rules from the given transactions.",
            "Ensure that the rules are generated based on the minimum confidence threshold.",
            "Handle edge cases where the minimum confidence threshold is 0."
        ],
        "import_lines": [
            "from itertools import combinations"
        ],
        "function_def": "def generate_association_rules(transactions, min_confidence):\n    item_counts = {}\n    for transaction in transactions:\n        for item in transaction:\n            if item not in item_counts:\n                item_counts[item] = 0\n            item_counts[item] += 1\n    \n    frequent_items = [item for item, count in item_counts.items() if count / len(transactions) >= 0.1]\n    \n    association_rules = []\n    for k in range(2, len(frequent_items) + 1):\n        candidate_itemsets = list(combinations(frequent_items, k))\n        for candidate_itemset in candidate_itemsets:\n            itemset_counts = {}\n            for transaction in transactions:\n                if set(candidate_itemset).issubset(set(transaction)):\n                    itemset_counts[candidate_itemset] = itemset_counts.get(candidate_itemset, 0) + 1\n            \n            for itemset, count in itemset_counts.items():\n                confidence = count / len(transactions)\n                if confidence >= min_confidence:\n                    antennas = list(combinations(itemset, 1))\n                    for antenna in antennas:\n                        consequence = tuple(set(itemset) - set(antenna))\n                        association_rules.append((antenna, consequence, confidence))\n    \n    return association_rules"
    },
    {
        "function_name": "max_subarray_sum",
        "file_name": "array_max_sum.py",
        "parameters": {
            "arr": "List[int] (A list of integers)",
            "k": "int (The size of the subarray)"
        },
        "objectives": [
            "Implement a function to find the maximum sum of a subarray of size k.",
            "Use a sliding window approach to efficiently find the maximum sum.",
            "Return the maximum sum."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_subarray_sum(arr: List[int], k: int) -> int:\n    if len(arr) < k:\n        return -1\n    \n    max_sum = current_sum = sum(arr[:k])\n    \n    for i in range(k, len(arr)):\n        current_sum = current_sum - arr[i - k] + arr[i]\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
    },
    {
        "function_name": "decision_tree_regressor",
        "file_name": "regressor.py",
        "parameters": {
            "df": "pandas.DataFrame (The input DataFrame to process)",
            "feature_column": "str (The feature column to use for regression)",
            "target_column": "str (The target column to predict)"
        },
        "objectives": [
            "Implement a function to train a decision tree regressor on the specified feature column.",
            "Use the Scikit-learn library to train the model.",
            "Return the predicted values."
        ],
        "import_lines": [
            "from typing import List",
            "import pandas as pd",
            "from sklearn.tree import DecisionTreeRegressor"
        ],
        "function_def": "def decision_tree_regressor(df: pd.DataFrame, feature_column: str, target_column: str) -> List[float]:\n    X = df[feature_column].values.reshape(-1, 1)\n    y = df[target_column].values\n    \n    model = DecisionTreeRegressor()\n    model.fit(X, y)\n    \n    predicted_values = model.predict(X)\n    \n    return predicted_values.tolist()"
    },
    {
        "function_name": "match_pattern",
        "file_name": "pattern_match.py",
        "parameters": {
            "words": "List[str] (A list of words)",
            "pattern": "str (The pattern to match)"
        },
        "objectives": [
            "Use a frequency-based approach to match words against the given pattern.",
            "For each word, calculate the frequency of each character.",
            "Compare the word's frequency with the pattern's frequency.",
            "Return a list of words that match the pattern."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import Counter"
        ],
        "function_def": "def match_pattern(words: List[str], pattern: str) -> List[str]:\n    pattern_freq = Counter(pattern)\n    result = []\n    \n    for word in words:\n        word_freq = Counter(word)\n        \n        match = True\n        \n        for char in pattern_freq:\n            if char not in word_freq or word_freq[char] != pattern_freq[char]:\n                match = False\n                break\n        \n        if match:\n            result.append(word)\n    \n    return result"
    },
    {
        "function_name": "word_connections",
        "file_name": "word_graph.py",
        "parameters": {
            "`words": "List[str]` (A list of words)",
            "`root": "str` (The root word)"
        },
        "objectives": [
            "Create a graph data structure to represent the relationships between the words.",
            "Define a relationship between two words if they differ by only one character.",
            "Find all words that are connected to the root word in the graph.",
            "Ensure that the algorithm can handle large lists of words efficiently."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def word_connections(words: List[str], root: str) -> List[str]:\n    word_set = set(words)\n    graph = {word: [] for word in words}\n    \n    for word in words:\n        for i in range(len(word)):\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                if char == word[i]:\n                    continue\n                new_word = word[:i] + char + word[i+1:]\n                if new_word in word_set:\n                    graph[word].append(new_word)\n    \n    visited = set()\n    queue = deque([root])\n    visited.add(root)\n    \n    result = [root]\n    \n    while queue:\n        current_word = queue.popleft()\n        for neighbor in graph[current_word]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                result.append(neighbor)\n    \n    return result"
    },
    {
        "function_name": "threshold_frequency",
        "file_name": "frequency_count.py",
        "parameters": {
            "`numbers": "List[int]` (A list of numbers)",
            "`threshold": "int` (The threshold frequency)"
        },
        "objectives": [
            "Find all numbers that appear more than `threshold` times in the list.",
            "Implement a solution using a hash map to count the frequency of each number efficiently.",
            "Ensure that the algorithm handles lists with many duplicate numbers."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import Counter"
        ],
        "function_def": "def threshold_frequency(numbers: List[int], threshold: int) -> List[int]:\n    frequency = Counter(numbers)\n    return [num for num, count in frequency.items() if count > threshold]"
    },
    {
        "function_name": "topological_sorter",
        "file_name": "graph_sorter.py",
        "parameters": {
            "graph": "Dict[str, List[str]] (A graph represented as a dictionary where each key is a node and its corresponding value is a list of its neighbors)",
            "start_node": "str (The node to start the search from)"
        },
        "objectives": [
            "Perform a topological sort on the graph.",
            "Ensure that the function correctly handles cycles in the graph by detecting them and returning an error message.",
            "Return the sorted list of nodes."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import defaultdict, deque"
        ],
        "function_def": "def topological_sorter(graph: Dict[str, List[str]], start_node: str) -> List[str]:\n    in_degree = defaultdict(int)\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n    \n    queue = deque([node for node in graph if in_degree[node] == 0])\n    sorted_nodes = []\n    \n    while queue:\n        node = queue.popleft()\n        sorted_nodes.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(sorted_nodes) != len(graph):\n        return [\"Error: Cycle detected in the graph\"]\n    \n    return sorted_nodes"
    },
    {
        "function_name": "longest_common_subsequence",
        "file_name": "matrix_lcs.py",
        "parameters": {
            "matrix": "List[List[int]] - A 2D matrix of integers."
        },
        "objectives": [
            "Find the longest common subsequence of elements in the matrix.",
            "Use dynamic programming to build a 2D table that stores the lengths of common subsequences.",
            "Return the longest common subsequence."
        ],
        "import_lines": [],
        "function_def": "def longest_common_subsequence(matrix: list) -> list:\n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    lcs = []\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] in matrix[:i - 1]:\n                k = matrix[:i - 1].index(matrix[i - 1][j - 1])\n                dp[i][j] = dp[k][j - 1] + 1\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    i, j = rows, cols\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i - 1][j]:\n            lcs.append(matrix[i - 1][j - 1])\n            i = matrix[:i - 1].index(matrix[i - 1][j - 1])\n            j -= 1\n        else:\n            i -= 1\n    \n    return lcs[::-1]"
    },
    {
        "function_name": "most_frequent_words",
        "file_name": "word_frequency.py",
        "parameters": {
            "text": "str - A string from which to extract the most frequent words.",
            "num_words": "int - The number of most frequent words to extract."
        },
        "objectives": [
            "Extract the most frequent words from the text.",
            "Ignore punctuation, words with numbers, and words shorter than three characters.",
            "Use a heap data structure to find the top k frequent words efficiently.",
            "Return the list of the most frequent words."
        ],
        "import_lines": [
            "from collections import Counter",
            "from typing import List",
            "import heapq",
            "import re"
        ],
        "function_def": "def most_frequent_words(text: str, num_words: int) -> List[str]:\n    words = re.findall(r'\\b[a-zA-Z]{3,}\\b', text.lower())\n    word_freq = Counter(words)\n    return heapq.nlargest(num_words, word_freq, key=word_freq.get)"
    },
    {
        "function_name": "pattern_search",
        "file_name": "pattern_finder.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "pattern": "List[int] (A pattern to search for in the matrix)"
        },
        "objectives": [
            "Search for the given pattern in the matrix.",
            "The pattern can be located horizontally, vertically, or diagonally in the matrix.",
            "Return the number of occurrences of the pattern in the matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def pattern_search(matrix: List[List[int]], pattern: List[int]) -> int:\n    count = 0\n    rows, cols = len(matrix), len(matrix[0])\n    pattern_length = len(pattern)\n    \n    # Check horizontal occurrences\n    for row in range(rows):\n        for col in range(cols - pattern_length + 1):\n            match = True\n            for i in range(pattern_length):\n                if matrix[row][col + i] != pattern[i]:\n                    match = False\n                    break\n            if match:\n                count += 1\n    \n    # Check vertical occurrences\n    for row in range(rows - pattern_length + 1):\n        for col in range(cols):\n            match = True\n            for i in range(pattern_length):\n                if matrix[row + i][col] != pattern[i]:\n                    match = False\n                    break\n            if match:\n                count += 1\n    \n    # Check diagonal occurrences (top-left to bottom-right)\n    for row in range(rows - pattern_length + 1):\n        for col in range(cols - pattern_length + 1):\n            match = True\n            for i in range(pattern_length):\n                if matrix[row + i][col + i] != pattern[i]:\n                    match = False\n                    break\n            if match:\n                count += 1\n    \n    # Check diagonal occurrences (bottom-left to top-right)\n    for row in range(pattern_length - 1, rows):\n        for col in range(cols - pattern_length + 1):\n            match = True\n            for i in range(pattern_length):\n                if matrix[row - i][col + i] != pattern[i]:\n                    match = False\n                    break\n            if match:\n                count += 1\n    \n    return count"
    },
    {
        "function_name": "filter_tuples",
        "file_name": "tuple_filter.py",
        "parameters": {
            "tuples": "List[Tuple[int]] (A list of tuples, each containing a single integer)",
            "threshold": "int (A threshold value)"
        },
        "objectives": [
            "Filter the list of tuples to include only those where the integer value is greater than the threshold.",
            "Handle cases where the threshold is negative by returning all tuples.",
            "Return the filtered list of tuples."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def filter_tuples(tuples: List[Tuple[int]], threshold: int) -> List[Tuple[int]]:\n    if threshold < 0:\n        return tuples\n    \n    return [tup for tup in tuples if tup[0] > threshold]"
    },
    {
        "function_name": "merged_intervals_with_target_time",
        "file_name": "interval_manager.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] (A list of tuples representing intervals of time)",
            "target_time": "int (The target time to find in the intervals)"
        },
        "objectives": [
            "Merge the overlapping intervals.",
            "Identify the intervals that contain the target time.",
            "Return the merged intervals that contain the target time."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def merged_intervals_with_target_time(intervals: List[Tuple[int, int]], target_time: int) -> List[Tuple[int, int]]:\n    intervals.sort(key=lambda x: x[0])\n    merged_intervals = [intervals[0]]\n    \n    for interval in intervals[1:]:\n        if merged_intervals[-1][1] >= interval[0]:\n            merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1]))\n        else:\n            merged_intervals.append(interval)\n    \n    target_intervals = [(start, end) for start, end in merged_intervals if start <= target_time <= end]\n    \n    return target_intervals"
    },
    {
        "function_name": "signal_peaks",
        "file_name": "signal_processor.py",
        "parameters": {
            "data": "List[int] (A list of integers representing a signal)",
            "threshold": "int (The threshold value for the signal)"
        },
        "objectives": [
            "Identify the peaks in the signal where the value exceeds the threshold.",
            "Return the indices of the peaks and their corresponding values."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def signal_peaks(data: List[int], threshold: int) -> List[Tuple[int, int]]:\n    peaks = []\n    \n    for i in range(1, len(data) - 1):\n        if data[i] > threshold and data[i] > data[i-1] and data[i] > data[i+1]:\n            peaks.append((i, data[i]))\n    \n    return peaks"
    },
    {
        "function_name": "pattern_counts",
        "file_name": "pattern_frequencies.py",
        "parameters": {
            "sequence": "str (A string representing a biological sequence)",
            "patterns": "List[str] (A list of strings representing patterns to find in the sequence)"
        },
        "objectives": [
            "Find all occurrences of the patterns in the sequence.",
            "Return a dictionary where the keys are the patterns and the values are their corresponding counts."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def pattern_counts(sequence: str, patterns: List[str]) -> Dict[str, int]:\n    pattern_freq = {}\n    \n    for pattern in patterns:\n        count = sequence.count(pattern)\n        pattern_freq[pattern] = count\n    \n    return pattern_freq"
    },
    {
        "function_name": "keyword_sentence_finder",
        "file_name": "sentence_analyzer.py",
        "parameters": {
            "sentences": "List[str] (A list of sentences to analyze)",
            "keywords": "List[str] (A list of keywords to search for in the sentences)"
        },
        "objectives": [
            "Implement a function to find the sentences that contain at least one keyword from the given list.",
            "Use a set data structure to efficiently store and search for keywords.",
            "Return a list of sentences that contain at least one keyword."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def keyword_sentence_finder(sentences: List[str], keywords: List[str]) -> List[str]:\n    keyword_set = set(keywords)\n    matching_sentences = []\n    \n    for sentence in sentences:\n        words = sentence.split()\n        if any(word in keyword_set for word in words):\n            matching_sentences.append(sentence)\n    \n    return matching_sentences"
    },
    {
        "function_name": "num_ways_to_split_string",
        "file_name": "dynamic_programming.py",
        "parameters": {
            "n": "int",
            "k": "int"
        },
        "objectives": [
            "Implement a function to find the number of ways to split a string of length n into k non-empty substrings.",
            "Ensure that the solution has a time complexity of O(n*k) using dynamic programming.",
            "Return the number of ways."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def num_ways_to_split_string(n: int, k: int) -> int:\n    if n < k:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for m in range(1, i + 1):\n                dp[i][j] += dp[i - m][j - 1]\n    \n    return dp[n][k]"
    },
    {
        "function_name": "triangle_point_containment",
        "file_name": "triangle_containment.py",
        "parameters": {
            "triangles": "List[List[List[int]]] (A list of triangles where each triangle is a list of three vertices, and each vertex is a list of two integers representing the x and y coordinates)",
            "points": "List[List[int]] (A list of points where each point is a list of two integers representing the x and y coordinates)"
        },
        "objectives": [
            "Check if each point lies within any of the triangles in the input list.",
            "For each point, return the indices of the triangles that contain the point.",
            "Handle edge cases where the point lies on the edge of a triangle or outside of all triangles."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def triangle_point_containment(triangles: List[List[List[int]]], points: List[List[int]]) -> List[List[int]]:\n    result = []\n    \n    for point in points:\n        containing_triangles = []\n        \n        for i, triangle in enumerate(triangles):\n            v0, v1, v2 = triangle\n            vx, vy = point\n            \n            # Compute barycentric coordinates\n            v0_x, v0_y = v0\n            v1_x, v1_y = v1\n            v2_x, v2_y = v2\n            \n            denominator = (v0_y - v2_y) * (v1_x - v2_x) + (v2_x - v0_x) * (v1_y - v2_y)\n            \n            if denominator == 0:\n                continue\n            \n            t = ((vx - v2_x) * (v1_y - v2_y) - (vy - v2_y) * (v1_x - v2_x)) / denominator\n            u = -((vx - v2_x) * (v0_y - v2_y) - (vy - v2_y) * (v0_x - v2_x)) / denominator\n            \n            if 0 <= t and 0 <= u and t + u <= 1:\n                containing_triangles.append(i)\n        \n        result.append(containing_triangles)\n    \n    return result"
    },
    {
        "function_name": "knapsack",
        "file_name": "knapsack.py",
        "parameters": {
            "items": "List[List[int]] (A list of items where each item is a list of two integers representing the weight and value of the item)",
            "capacity": "int (The maximum capacity of the knapsack)"
        },
        "objectives": [
            "Solve the 0/1 knapsack problem to find the optimal subset of items to include in the knapsack.",
            "The objective function should maximize the total value of the items in the knapsack.",
            "Return the indices of the selected items."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def knapsack(items: List[List[int]], capacity: int) -> List[int]:\n    n = len(items)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        weight, value = items[i - 1]\n        \n        for j in range(1, capacity + 1):\n            if weight > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight] + value)\n    \n    selected_items = []\n    i, j = n, capacity\n    \n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i - 1][j]:\n            selected_items.append(i - 1)\n            j -= items[i - 1][0]\n        i -= 1\n    \n    return selected_items"
    },
    {
        "function_name": "keyword_search",
        "file_name": "text_analysis.py",
        "parameters": {
            "sentences": "List[str] (A list of sentences)",
            "keyword": "str (The keyword to search for)"
        },
        "objectives": [
            "Implement a function to search for a keyword in a list of sentences.",
            "Use regular expressions to ensure that the keyword is searched for in a case-insensitive manner.",
            "Return a list of sentences that contain the keyword."
        ],
        "import_lines": [
            "from typing import List",
            "import re"
        ],
        "function_def": "def keyword_search(sentences: List[str], keyword: str) -> List[str]:\n    searched_sentences = [sentence for sentence in sentences if re.search(keyword, sentence, re.IGNORECASE)]\n    \n    return searched_sentences"
    },
    {
        "function_name": "exponential_smoothing_forecast",
        "file_name": "time_series_forecasting.py",
        "parameters": {
            "time_series_data": "List[float] (A list of time series data)",
            "window_size": "int (The size of the window for the moving average)"
        },
        "objectives": [
            "Implement the Exponential Smoothing (ES) algorithm to forecast future values in the time series data.",
            "Use the moving average of the last window_size data points as the initial seed for the ES algorithm.",
            "Return a list of forecasted values for the next 5 time steps."
        ],
        "import_lines": [],
        "function_def": "def exponential_smoothing_forecast(time_series_data, window_size):\n    alpha = 0.2  # Default smoothing factor\n    initial_seed = sum(time_series_data[-window_size:]) / window_size\n    \n    forecasted_values = [initial_seed]\n    for _ in range(5):\n        next_value = alpha * (forecasted_values[-1] + (1 - alpha) * (initial_seed))\n        forecasted_values.append(next_value)\n    \n    return forecasted_values[1:]  # Return forecasted values starting from the next time step"
    },
    {
        "function_name": "non_negative_matrix_factorization",
        "file_name": "matrix_factorization.py",
        "parameters": {
            "matrix": "List[List[float]] (A matrix of floating-point numbers)",
            "num_factors": "int (The number of latent factors)"
        },
        "objectives": [
            "Implement the Non-negative Matrix Factorization (NMF) algorithm to decompose the matrix into its latent factors.",
            "Use the alternating least squares (ALS) method to optimize the factorization.",
            "Return a tuple containing the factorized matrices."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def non_negative_matrix_factorization(matrix, num_factors):\n    num_rows, num_cols = len(matrix), len(matrix[0])\n    W = np.random.rand(num_rows, num_factors)\n    H = np.random.rand(num_factors, num_cols)\n    \n    for _ in range(100):  # Default number of iterations\n        W = W * (matrix @ H.T) / (W @ H @ H.T)\n        H = H * (W.T @ matrix) / (W.T @ W @ H)\n    \n    return W, H"
    },
    {
        "function_name": "kth_largest_median",
        "file_name": "median_calculator.py",
        "parameters": {
            "numbers": "List[int] (A list of integers)",
            "k": "int (The number of top median values to consider)",
            "p": "int (The power value for the median calculation)"
        },
        "objectives": [
            "Calculate the median values of all possible subsets of k integers from the given list.",
            "Raise the median values to the power p.",
            "Return the k-th largest median value and its corresponding subset."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from itertools import combinations",
            "import statistics"
        ],
        "function_def": "def kth_largest_median(numbers: List[int], k: int, p: int) -> Tuple[float, Tuple[int, ...]]:\n    medians = []\n    for subset in combinations(numbers, k):\n        medians.append(pow(statistics.median(subset), p))\n    sorted_medians = sorted(enumerate(medians), key=lambda x: x[1], reverse=True)\n    return sorted_medians[0][1], numbers[sorted_medians[0][0]*k:(sorted_medians[0][0]+1)*k]"
    },
    {
        "function_name": "contiguous_subsequences_with_product",
        "file_name": "subsequence_generator.py",
        "parameters": {
            "num_list": "List[int] (A list of integers)",
            "sub_length": "int (The length of the subsequence)"
        },
        "objectives": [
            "Find all contiguous subsequences of the given list with the specified length.",
            "For each subsequence, calculate the product of its elements.",
            "Return a list of tuples containing the subsequences and their corresponding products."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def contiguous_subsequences_with_product(num_list: List[int], sub_length: int) -> List[Tuple[List[int], int]]:\n    subsequences = []\n    for i in range(len(num_list) - sub_length + 1):\n        subsequence = num_list[i:i + sub_length]\n        product = 1\n        for num in subsequence:\n            product *= num\n        subsequences.append((subsequence, product))\n    return subsequences"
    },
    {
        "function_name": "prefixed_suffixed_substring_lengths",
        "file_name": "string_matcher.py",
        "parameters": {
            "strings": "List[str] (A list of strings)",
            "prefix": "str (The prefix to search for)",
            "suffix": "str (The suffix to search for)"
        },
        "objectives": [
            "Find all strings that start with the given prefix and end with the given suffix.",
            "For each string, calculate the length of the substring between the prefix and suffix.",
            "Return a list of tuples containing the matching strings and their corresponding substring lengths."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def prefixed_suffixed_substring_lengths(strings: List[str], prefix: str, suffix: str) -> List[Tuple[str, int]]:\n    matching_strings = []\n    for string in strings:\n        if string.startswith(prefix) and string.endswith(suffix):\n            prefix_index = len(prefix)\n            suffix_index = len(string) - len(suffix)\n            substring_length = suffix_index - prefix_index\n            matching_strings.append((string, substring_length))\n    return matching_strings"
    },
    {
        "function_name": "bipartite_graph_checker",
        "file_name": "graph_analyzer.py",
        "parameters": {
            "graph": "Dict[int, List[int]] (An adjacency list representation of a graph)",
            "edges": "List[Tuple[int, int]] (A list of edges in the graph)",
            "vertices": "List[int] (A list of vertices in the graph)"
        },
        "objectives": [
            "Check if the graph is bipartite.",
            "If the graph is bipartite, return a list of vertices colored with 0 and 1 such that no two adjacent vertices have the same color.",
            "If the graph is not bipartite, return an error message.",
            "Use a breadth-first search (BFS) algorithm to traverse the graph."
        ],
        "import_lines": [
            "from collections import deque",
            "from typing import Dict, List, Tuple, Union"
        ],
        "function_def": "def bipartite_graph_checker(graph: Dict[int, List[int]], edges: List[Tuple[int, int]], vertices: List[int]) -> Union[List[int], str]:\n    colors = {}\n    \n    for vertex in vertices:\n        if vertex not in colors:\n            queue = deque([vertex])\n            colors[vertex] = 0\n            \n            while queue:\n                current_vertex = queue.popleft()\n                \n                for neighbor in graph.get(current_vertex, []):\n                    if neighbor not in colors:\n                        colors[neighbor] = 1 - colors[current_vertex]\n                        queue.append(neighbor)\n                    elif colors[neighbor] == colors[current_vertex]:\n                        return \"Error: Graph is not bipartite\"\n    \n    return list(colors.values())"
    },
    {
        "function_name": "matrix_threshold",
        "file_name": "matrix_operations.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list of integers)",
            "threshold": "int (A threshold value)"
        },
        "objectives": [
            "Apply a threshold to the matrix, replacing all values above the threshold with 1 and all values below the threshold with 0.",
            "Use a matrix comprehension to create the thresholded matrix.",
            "Return the thresholded matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def matrix_threshold(matrix: List[List[int]], threshold: int) -> List[List[int]]:\n    return [[1 if value > threshold else 0 for value in row] for row in matrix]"
    },
    {
        "function_name": "modified_bfs",
        "file_name": "bfs_solver.py",
        "parameters": {
            "graph": "Dict[str, List[str]] - A graph represented as an adjacency list.",
            "source": "str - The source node.",
            "target": "str - The target node."
        },
        "objectives": [
            "Implement a modified Breadth-First Search (BFS) algorithm to find the shortest path between the source and target nodes in an unweighted graph.",
            "Allow for multiple shortest paths to be found by returning all possible paths.",
            "Handle cases where there are no paths between the source and target nodes."
        ],
        "import_lines": [
            "from collections import deque"
        ],
        "function_def": "def modified_bfs(graph, source, target):\n    queue = deque([(source, [source])])\n    visited = set(source)\n    shortest_paths = []\n    \n    while queue:\n        node, path = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if neighbor == target:\n                    shortest_paths.append(path + [neighbor])\n                else:\n                    queue.append((neighbor, path + [neighbor]))\n                    visited.add(neighbor)\n    \n    return shortest_paths"
    },
    {
        "function_name": "find_first_peak",
        "file_name": "peak_finder.py",
        "parameters": {
            "sequence": "List[int] - A sequence in which we want to find the first peak element."
        },
        "objectives": [
            "Find the first peak element in the given sequence (a peak element is an element which is not smaller than any of its neighbors).",
            "If no peak element is found, return -1.",
            "Ensure that the function uses binary search approach."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_first_peak(sequence: List[int]) -> int:\n    low, high = 0, len(sequence) - 1\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        \n        if sequence[mid] > sequence[mid + 1]:\n            high = mid\n        else:\n            low = mid + 1\n    \n    if low == 0 and sequence[low] > sequence[1]:\n        return sequence[low]\n    elif low == len(sequence) - 1 and sequence[low] > sequence[low - 1]:\n        return sequence[low]\n    elif sequence[low] > sequence[low - 1] and sequence[low] > sequence[low + 1]:\n        return sequence[low]\n    \n    return -1"
    },
    {
        "function_name": "numbers_selector",
        "file_name": "number_selector.py",
        "parameters": {
            "numbers": "List[int] - A list of integers.",
            "targets": "List[int] - A list of target numbers."
        },
        "objectives": [
            "Implement a solution that efficiently recommends which numbers to add, subtract, multiply, or divide one by one, starting from the first number in the 'numbers' list, to get closest to the target number as possible.",
            "Ensure the result contains the initial number, the operation performed on each number, and the final achieved number.",
            "Return a dictionary containing the steps."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def numbers_selector(numbers: List[int], targets: List[int]) -> dict:\n    operations = ['+', '-', '*', '/']\n    results = {}\n    \n    for target in targets:\n        min_diff = float('inf')\n        best_sequence = []\n        \n        def compute_result(achievements, operations, idx, current_number):\n            nonlocal min_diff, best_sequence\n            \n            if idx == len(numbers):\n                if abs(target - current_number) < min_diff:\n                    min_diff = abs(target - current_number)\n                    best_sequence = achievements[:]\n                return\n            \n            for operation in operations:\n                if operation == '+' and numbers[idx] < current_number:\n                    continue\n                elif operation == '*' and numbers[idx] < current_number:\n                    continue\n                elif operation == '-' and numbers[idx] > current_number:\n                    continue\n                elif operation == '/' and numbers[idx] == 0:\n                    continue\n                \n                if operation == '+':\n                    new_number = current_number + numbers[idx]\n                elif operation == '-':\n                    new_number = current_number - numbers[idx]\n                elif operation == '*':\n                    new_number = current_number * numbers[idx]\n                else:\n                    new_number = current_number / numbers[idx]\n                \n                achievements.append((numbers[idx], operation))\n                compute_result(achievements, operations, idx + 1, new_number)\n                achievements.pop()\n        \n        compute_result([(numbers[0], '')], operations, 1, numbers[0])\n        \n        results[target] = (numbers[0], best_sequence, min_diff + target)\n    \n    return results"
    },
    {
        "function_name": "interval_queries",
        "file_name": "interval_queries.py",
        "parameters": {
            "intervals": "List[List[int]]",
            "queries": "List[int]"
        },
        "objectives": [
            "Implement a function that solves the interval query problem, where given a list of intervals and queries, find the number of intervals that contain each query point.",
            "Use a combination of sorting and binary search to achieve efficient query processing.",
            "Return a list of counts, where each count corresponds to the number of intervals that contain the respective query point."
        ],
        "import_lines": [
            "from typing import List",
            "import bisect"
        ],
        "function_def": "def interval_queries(intervals: List[List[int]], queries: List[int]) -> List[int]:\n    sorted_intervals = sorted(intervals)\n    query_results = [0] * len(queries)\n    for i, query in enumerate(queries):\n        start_idx = bisect.bisect_left([interval[0] for interval in sorted_intervals], query)\n        end_idx = bisect.bisect_right([interval[0] for interval in sorted_intervals], query)\n        for j in range(start_idx, end_idx):\n            if query <= sorted_intervals[j][1]:\n                query_results[i] += 1\n    return query_results"
    },
    {
        "function_name": "matrix_pairs",
        "file_name": "matrix_pairs.py",
        "parameters": {
            "`matrix`": "List[List[int]] (A 2D list of integers representing a matrix)",
            "`target`": "int (The target sum to find in the matrix)"
        },
        "objectives": [
            "Find all unique pairs of numbers in the matrix that add up to the target sum.",
            "Ensure that the pairs are distinct, meaning that each pair should not have the same numbers in a different order (e.g., [a, b] is the same as [b, a]).",
            "Return a list of these unique pairs, each represented as a list of two numbers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def matrix_pairs(matrix: List[List[int]], target: int) -> List[List[int]]:\n    pairs = set()\n    num_set = set()\n    for row in matrix:\n        for num in row:\n            complement = target - num\n            if complement in num_set:\n                pair = tuple(sorted([num, complement]))\n                pairs.add(pair)\n            num_set.add(num)\n    return [list(pair) for pair in pairs]"
    },
    {
        "function_name": "change_making",
        "file_name": "change_making.py",
        "parameters": {
            "coins": "List[int] (A list of coin denominations)",
            "amount": "int (The target amount)"
        },
        "objectives": [
            "Implement a dynamic programming approach to solve the Change-Making Problem for multiple coin denominations.",
            "Calculate the minimum number of coins required for the given amount.",
            "Return the count of minimum coins if possible; otherwise, return -1."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def change_making(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1"
    },
    {
        "function_name": "a_star_graph_search",
        "file_name": "graph_search.py",
        "parameters": {
            "graph": "Dict[str, List[str]] (A graph represented as an adjacency list)",
            "start_node": "str (The node to start the graph traversal from)",
            "target_node": "str (The target node to find)",
            "max_depth": "int (The maximum depth to search to)"
        },
        "objectives": [
            "Implement the A* graph search algorithm to find the shortest path to the target node.",
            "Use a heuristic function to guide the search towards the target node.",
            "Handle edge cases where the target node is not reachable or the maximum depth is exceeded."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "import heapq"
        ],
        "function_def": "def a_star_graph_search(graph: Dict[str, List[str]], start_node: str, target_node: str, max_depth: int) -> List[str]:\n    queue = [(0, start_node, [])]\n    visited = set()\n    while queue:\n        (cost, node, path) = heapq.heappop(queue)\n        if node not in visited:\n            visited.add(node)\n            path = path + [node]\n            if node == target_node:\n                return path\n            if len(path) >= max_depth:\n                continue\n            for neighbor in graph[node]:\n                heapq.heappush(queue, (cost + 1, neighbor, path))\n    return None"
    },
    {
        "function_name": "kernighan_lin_partitioning",
        "file_name": "graph_partitioning.py",
        "parameters": {
            "adjacency_matrix": "np.ndarray (An adjacency matrix representing the graph)",
            "num_partitions": "int (The number of partitions to divide the graph into)"
        },
        "objectives": [
            "Implement the Kernighan-Lin graph partitioning algorithm to divide the graph into k partitions.",
            "Use a combination of swapping vertices between partitions and using a greedy metaheuristic to improve the partitioning.",
            "Handle edge cases where the number of partitions is invalid."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def kernighan_lin_partitioning(adjacency_matrix: np.ndarray, num_partitions: int) -> np.ndarray:\n    num_vertices, _ = adjacency_matrix.shape\n    partition = np.random.randint(0, num_partitions, num_vertices)\n    cut_size = np.sum(adjacency_matrix[partition == 0, :] @ (partition == 1))\n    for _ in range(100):\n        swap_vertices = np.random.choice(num_vertices, size=2, replace=False)\n        old_cut = np.sum(adjacency_matrix[partition == 0, :] @ (partition == 1))\n        partition[swap_vertices] = (partition[swap_vertices] + 1) % num_partitions\n        new_cut = np.sum(adjacency_matrix[partition == 0, :] @ (partition == 1))\n        if new_cut > old_cut:\n            partition[swap_vertices] = (partition[swap_vertices] - 1) % num_partitions\n    return partition"
    },
    {
        "function_name": "matrix_rank_calculator",
        "file_name": "matrix_rank_calculator.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list representing a rectangular matrix)",
            "demarcation_line": "List[int] (A list of row indices defining the demarcation line)"
        },
        "objectives": [
            "Separate the given matrix into two parts at the demarcation line: upper and lower.",
            "For each part, calculate the rank of its sub-matrix by counting the number of linearly independent rows.",
            "Return the ranks of the upper and lower sub-matrices."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def matrix_rank_calculator(matrix: List[List[int]], demarcation_line: List[int]) -> tuple:\n    upper_matrix = matrix[:demarcation_line[0]]\n    lower_matrix = matrix[demarcation_line[0]:]\n    \n    upper_rank = np.linalg.matrix_rank(upper_matrix)\n    lower_rank = np.linalg.matrix_rank(lower_matrix)\n    \n    return upper_rank, lower_rank"
    },
    {
        "function_name": "calculate_shortest_trajectory",
        "file_name": "trajectory_calculator.py",
        "parameters": {
            "trajectory": "List[Tuple[float, float]] - A list of (x, y) coordinates representing a trajectory.",
            "speed_limit": "float - The maximum speed allowed.",
            "acceleration_limit": "float - The maximum acceleration allowed."
        },
        "objectives": [
            "Calculate the shortest possible trajectory that an object can take while following the given speed and acceleration limits.",
            "Ensure that the object does not exceed the speed limit at any point.",
            "Ensure that the object does not exceed the acceleration limit at any point.",
            "Return a list of (x, y) coordinates representing the shortest possible trajectory."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import math"
        ],
        "function_def": "def calculate_shortest_trajectory(trajectory: List[Tuple[float, float]], speed_limit: float, acceleration_limit: float) -> List[Tuple[float, float]]:\n    n = len(trajectory)\n    dp = [[None for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = 0\n            else:\n                dist = math.sqrt((trajectory[j][0] - trajectory[i][0])**2 + (trajectory[j][1] - trajectory[i][1])**2)\n                time = dist / speed_limit\n                acc = acceleration_limit\n                a = 0.5 * acc * time**2\n                if a > dist:\n                    dp[i][j] = float('inf')\n                else:\n                    dp[i][j] = time\n    \n    shortest_trajectory = []\n    i, j = 0, n - 1\n    while i < j:\n        if dp[i][j] == float('inf'):\n            shortest_trajectory.append(trajectory[i])\n            i += 1\n        else:\n            shortest_trajectory.append(trajectory[j])\n            j -= 1\n    \n    return shortest_trajectory"
    },
    {
        "function_name": "divide_graph_into_communities",
        "file_name": "graph_divider.py",
        "parameters": {
            "graph": "Dict[int, List[int]] - A dictionary representing an undirected graph, where each key maps to a list of its neighbors.",
            "communities": "int - The number of communities to divide the graph into."
        },
        "objectives": [
            "Divide the graph into communities such that the edges between communities are minimized.",
            "Use a greedy algorithm to assign each node to a community based on the number of its neighbors already in that community.",
            "Ensure that each community has approximately the same number of nodes.",
            "Return a dictionary mapping each node to its assigned community."
        ],
        "import_lines": [
            "from typing import Dict, List"
        ],
        "function_def": "def divide_graph_into_communities(graph: Dict[int, List[int]], communities: int) -> Dict[int, int]:\n    node_community = {}\n    community_sizes = [0] * communities\n    \n    for node in graph:\n        max_neighbors = 0\n        community = 0\n        for neighbor in graph[node]:\n            if neighbor in node_community:\n                if community_sizes[node_community[neighbor]] > max_neighbors:\n                    max_neighbors = community_sizes[node_community[neighbor]]\n                    community = node_community[neighbor]\n        if community == 0:\n            community = 0\n            for i in range(1, communities):\n                if community_sizes[i] < community_sizes[community]:\n                    community = i\n        node_community[node] = community\n        community_sizes[community] += 1\n    \n    return node_community"
    },
    {
        "function_name": "align_sequences",
        "file_name": "sequence_aligner.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences of integers.",
            "gap_penalty": "int - The penalty for each gap in the alignment."
        },
        "objectives": [
            "Align the sequences using the Needleman-Wunsch algorithm.",
            "Calculate the optimal score for the alignment, taking into account the gap penalty.",
            "Return the aligned sequences."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def align_sequences(sequences: List[List[int]], gap_penalty: int) -> List[List[int]]:\n    m, n = len(sequences[0]), len(sequences[1])\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = gap_penalty * i\n    for j in range(n + 1):\n        dp[0][j] = gap_penalty * j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = dp[i - 1][j - 1] + (sequences[0][i - 1] == sequences[1][j - 1])\n            delete = dp[i - 1][j] + gap_penalty\n            insert = dp[i][j - 1] + gap_penalty\n            dp[i][j] = max(match, delete, insert)\n    \n    aligned_sequences = [[], []]\n    i, j = m, n\n    while i > 0 or j > 0:\n        if i > 0 and j > 0 and dp[i][j] == dp[i - 1][j - 1] + (sequences[0][i - 1] == sequences[1][j - 1]):\n            aligned_sequences[0].append(sequences[0][i - 1])\n            aligned_sequences[1].append(sequences[1][j - 1])\n            i -= 1\n            j -= 1\n        elif i > 0 and dp[i][j] == dp[i - 1][j] + gap_penalty:\n            aligned_sequences[0].append(sequences[0][i - 1])\n            aligned_sequences[1].append(-1)\n            i -= 1\n        else:\n            aligned_sequences[0].append(-1)\n            aligned_sequences[1].append(sequences[1][j - 1])\n            j -= 1\n    \n    return [aligned_sequences[0][::-1], aligned_sequences[1][::-1]]"
    },
    {
        "function_name": "knapsack_items",
        "file_name": "dynamic_programming.py",
        "parameters": {
            "items": "List[int] - A list of items with their weights.",
            "capacity": "int - The maximum weight capacity of the knapsack."
        },
        "objectives": [
            "Implement a dynamic programming solution to the 0/1 knapsack problem.",
            "Find the maximum value that can be achieved by selecting items without exceeding the capacity.",
            "Return a list of selected items that achieve the maximum value."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def knapsack_items(items: List[int], capacity: int) -> List[int]:\n    n = len(items)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if items[i - 1] > w:\n                dp[i][w] = dp[i - 1][w]\n            else:\n                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - items[i - 1]] + items[i - 1])\n    \n    selected_items = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i - 1][w]:\n            selected_items.append(items[i - 1])\n            w -= items[i - 1]\n    \n    return selected_items"
    },
    {
        "function_name": "motif_finder",
        "file_name": "bioinformatics.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of lists containing DNA sequences",
            "motifs": "List[List[int]] - A list of lists containing motif sequences",
            "min_occurrences": "int - The minimum number of occurrences required"
        },
        "objectives": [
            "Identify all motif sequences that occur at least 'min_occurrences' times in the DNA sequences.",
            "For each identified motif, calculate its frequency of occurrence in the DNA sequences.",
            "Filter out motifs that have a frequency of occurrence greater than 0.5.",
            "Return a dictionary with the identified motifs and their frequencies."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def motif_finder(sequences: List[List[int]], motifs: List[List[int]], min_occurrences: int) -> Dict[str, float]:\n    result = {}\n    \n    for motif in motifs:\n        occurrences = 0\n        for sequence in sequences:\n            for i in range(len(sequence) - len(motif) + 1):\n                if sequence[i:i+len(motif)] == motif:\n                    occurrences += 1\n                    break\n        frequency = occurrences / len(sequences)\n        if frequency > 0 and frequency <= 0.5:\n            result[str(motif)] = frequency\n    \n    return result"
    },
    {
        "function_name": "transaction_clusterer",
        "file_name": "transaction_analyzer.py",
        "parameters": {
            "data": "List[List[float]] - A list of lists containing transaction data",
            "k": "int - The number of clusters to form",
            "threshold": "float - The maximum distance between points in a cluster"
        },
        "objectives": [
            "Perform DBSCAN clustering on the transaction data to identify clusters.",
            "Filter out clusters that have fewer than k points.",
            "For each remaining cluster, calculate the average distance between points in the cluster.",
            "Return a dictionary with the cluster indices and the average distance between points in each cluster."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from sklearn.cluster import DBSCAN",
            "import numpy as np"
        ],
        "function_def": "def transaction_clusterer(data: List[List[float]], k: int, threshold: float) -> Dict[int, float]:\n    db = DBSCAN(eps=threshold, min_samples=k).fit(data)\n    labels = db.labels_\n    \n    result = {}\n    for i in set(labels):\n        if i != -1:\n            cluster_points = [data[j] for j in range(len(data)) if labels[j] == i]\n            avg_distance = np.mean([np.linalg.norm(np.array(cluster_points[j]) - np.array(cluster_points[j-1])) for j in range(1, len(cluster_points))])\n            result[i] = avg_distance\n    \n    return result"
    },
    {
        "function_name": "classify_points_with_minkowski_distance",
        "file_name": "minkowski_distance_calculator.py",
        "parameters": {
            "points": "List[Tuple[float, float]] (A list of 2D points)",
            "radius": "float (The radius of the circle)"
        },
        "objectives": [
            "Implement a function to calculate the Minkowski distance between each pair of points and a given circle.",
            "Identify points that are within the circle, outside the circle, or on the circle.",
            "Return a dictionary classifying each point into one of the three categories."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict",
            "import math"
        ],
        "function_def": "def classify_points_with_minkowski_distance(points: List[Tuple[float, float]], radius: float) -> Dict[Tuple[float, float], str]:\n    classification = {}\n    \n    for point in points:\n        distance = (abs(point[0]) ** 2 + abs(point[1]) ** 2) ** 0.5\n        if distance < radius:\n            classification[point] = \"within\"\n        elif distance > radius:\n            classification[point] = \"outside\"\n        else:\n            classification[point] = \"on\"\n    \n    return classification"
    },
    {
        "function_name": "find_overlapping_subsequences",
        "file_name": "subsequence_calculator.py",
        "parameters": {
            "sequences": "List[str] (A list of symbol sequences, where each sequence consists of 'X', 'Y', or 'Z')",
            "min_length": "int (The minimum length of the sequence)"
        },
        "objectives": [
            "Implement a function to find all overlapping subsequences of a given length in each sequence.",
            "Count the frequency of each subsequence.",
            "Return a dictionary mapping each subsequence to its frequency."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def find_overlapping_subsequences(sequences: List[str], min_length: int) -> Dict[str, int]:\n    subsequences = {}\n    \n    for sequence in sequences:\n        for i in range(len(sequence) - min_length + 1):\n            subsequence = sequence[i:i + min_length]\n            subsequences[subsequence] = subsequences.get(subsequence, 0) + 1\n    \n    return subsequences"
    },
    {
        "function_name": "calculate_bucket_standard_deviations",
        "file_name": "bucketing_utils.py",
        "parameters": {
            "numbers": "List[float] (A list of floating-point numbers)",
            "precision": "int (The number of decimal places to consider)"
        },
        "objectives": [
            "Round each number to the given precision.",
            "Group numbers into buckets based on their rounded values.",
            "Calculate the standard deviation of each bucket and return a dictionary mapping each bucket to its standard deviation."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import math"
        ],
        "function_def": "def calculate_bucket_standard_deviations(numbers: List[float], precision: int) -> Dict[float, float]:\n    buckets = {}\n    \n    for num in numbers:\n        rounded_num = round(num, precision)\n        if rounded_num not in buckets:\n            buckets[rounded_num] = []\n        buckets[rounded_num].append(num)\n    \n    standard_deviations = {}\n    \n    for bucket, values in buckets.items():\n        mean = sum(values) / len(values)\n        variance = sum((x - mean) ** 2 for x in values) / len(values)\n        standard_deviations[bucket] = math.sqrt(variance)\n    \n    return standard_deviations"
    },
    {
        "function_name": "find_association_rules",
        "file_name": "association_rule_mining.py",
        "parameters": {
            "transactions": "List[dict] - A list of transactions, where each transaction is a dictionary containing the 'user_id', 'item_id', and 'rating'.",
            "min_support": "int - A minimum number of transactions required for an item to be considered frequent.",
            "confidence": "float - A minimum confidence required for an association rule to be considered valid."
        },
        "objectives": [
            "Identify all frequent items that appear at least min_support times in the transactions.",
            "For each frequent item, find all association rules that have a confidence greater than or equal to the given confidence.",
            "Return a dictionary mapping each frequent item to a list of valid association rules."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from collections import defaultdict"
        ],
        "function_def": "def find_association_rules(transactions: List[Dict], min_support: int, confidence: float) -> Dict:\n    item_counts = defaultdict(int)\n    \n    for transaction in transactions:\n        for item_id in transaction['item_id']:\n            item_counts[item_id] += 1\n    \n    frequent_items = {item: count for item, count in item_counts.items() if count >= min_support}\n    \n    association_rules = {}\n    \n    for item in frequent_items:\n        rules = []\n        \n        for transaction in transactions:\n            if item in transaction['item_id']:\n                for other_item in transaction['item_id']:\n                    if other_item != item:\n                        support = sum(1 for t in transactions if item in t['item_id'] and other_item in t['item_id'])\n                        confidence_rule = support / frequent_items[item]\n                        \n                        if confidence_rule >= confidence:\n                            rules.append((other_item, confidence_rule))\n        \n        association_rules[item] = rules\n    \n    return association_rules"
    },
    {
        "function_name": "image_convolution",
        "file_name": "image_processing.py",
        "parameters": {
            "data": "List[List[int]] - A 2D list representing a binary image.",
            "kernel_size": "int - The size of the kernel for the convolution operation."
        },
        "objectives": [
            "Normalize the input image to have values between 0 and 255.",
            "Perform a convolution operation on the normalized image using a kernel of the specified size.",
            "Apply a max pooling operation to the convolved image."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def image_convolution(data: List[List[int]], kernel_size: int) -> List[List[int]]:\n    # Normalize the input image\n    normalized_data = np.array(data) / max(max(row) for row in data) * 255\n    \n    # Define the kernel\n    kernel = np.ones((kernel_size, kernel_size)) / kernel_size ** 2\n    \n    # Perform convolution operation\n    convolved_data = np.zeros(normalized_data.shape)\n    for i in range(normalized_data.shape[0] - kernel_size + 1):\n        for j in range(normalized_data.shape[1] - kernel_size + 1):\n            convolved_data[i, j] = np.sum(normalized_data[i:i+kernel_size, j:j+kernel_size] * kernel)\n    \n    # Apply max pooling operation\n    pooled_data = np.zeros((convolved_data.shape[0] // 2, convolved_data.shape[1] // 2))\n    for i in range(pooled_data.shape[0]):\n        for j in range(pooled_data.shape[1]):\n            pooled_data[i, j] = np.max(convolved_data[i*2:i*2+2, j*2:j*2+2])\n    \n    return pooled_data.tolist()"
    },
    {
        "function_name": "dna_gc_content",
        "file_name": "dna_analysis.py",
        "parameters": {
            "sequences": "List[str] - A list of DNA sequences.",
            "min_length": "int - The minimum length of the sequences to be considered.",
            "max_length": "int - The maximum length of the sequences to be considered."
        },
        "objectives": [
            "Filter the input sequences to only include those within the specified length range.",
            "Calculate the GC content of each filtered sequence.",
            "Return a dictionary mapping each sequence to its GC content."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def dna_gc_content(sequences: List[str], min_length: int, max_length: int) -> dict:\n    # Filter sequences by length\n    filtered_sequences = [sequence for sequence in sequences if min_length <= len(sequence) <= max_length]\n    \n    # Calculate GC content of each sequence\n    gc_contents = {}\n    for sequence in filtered_sequences:\n        gc_count = sequence.count('G') + sequence.count('C')\n        gc_contents[sequence] = gc_count / len(sequence)\n    \n    return gc_contents"
    },
    {
        "function_name": "longest_common_subsequence",
        "file_name": "sequence_alignment.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of integer sequences)",
            "k": "int (The length of the common subsequence)"
        },
        "objectives": [
            "Implement a dynamic programming algorithm to find the longest common subsequence among all sequences.",
            "Ensure that the function handles edge cases where k is larger than the sequence lengths.",
            "Optimize the function to handle large sequences and large k values."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_common_subsequence(sequences: List[List[int]], k: int) -> List[int]:\n    if not sequences:\n        return []\n    \n    dp = [[[] for _ in range(k + 1)] for _ in range(len(sequences))]\n    \n    for i in range(len(sequences)):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = []\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1]\n            else:\n                max_len = 0\n                best_seq = []\n                for m in range(len(sequences[i])):\n                    for n in range(len(sequences[i - 1])):\n                        if sequences[i][m] == sequences[i - 1][n]:\n                            if len(dp[i - 1][j - 1]) + 1 > max_len:\n                                max_len = len(dp[i - 1][j - 1]) + 1\n                                best_seq = dp[i - 1][j - 1] + [sequences[i][m]]\n                dp[i][j] = best_seq\n    \n    return dp[-1][-1]"
    },
    {
        "function_name": "parse_sentence",
        "file_name": "sentence_parser.py",
        "parameters": {
            "text": "str (A string containing words and punctuation)",
            "grammar_rules": "Dict[str, List[str]] (A dictionary of grammar rules where each key is a part of speech and each value is a list of words that correspond to that part of speech)"
        },
        "objectives": [
            "Tokenize the input text into individual words.",
            "Tag each word with its corresponding part of speech using the provided grammar rules.",
            "Perform a dependency parse on the tagged words to identify the grammatical structure of the sentence."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "import re",
            "from collections import defaultdict"
        ],
        "function_def": "def parse_sentence(text: str, grammar_rules: Dict[str, List[str]]) -> Dict[str, object]:\n    words = re.findall(r'\\b\\w+\\b', text)\n    tagged_words = []\n    \n    for word in words:\n        tag = None\n        for key, value in grammar_rules.items():\n            if word in value:\n                tag = key\n                break\n        tagged_words.append((word, tag))\n    \n    dependencies = defaultdict(list)\n    for i, (word, tag) in enumerate(tagged_words):\n        if tag == \"VB\" and i > 0:\n            dependencies[tagged_words[i-1][1]].append(tag)\n    \n    return {\"tagged_words\": tagged_words, \"dependencies\": dict(dependencies)}"
    },
    {
        "function_name": "apply_filter",
        "file_name": "image_filter.py",
        "parameters": {
            "image_data": "List[List[List[int]]] (A 3D list representing a color image)",
            "filter_type": "str (The type of filter to apply, either \"blur\" or \"sharpen\")"
        },
        "objectives": [
            "Convert the input image to grayscale.",
            "Apply the specified filter to the grayscale image.",
            "Return the filtered image."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def apply_filter(image_data: List[List[List[int]]], filter_type: str) -> List[List[List[int]]]:\n    # Convert to grayscale\n    grayscale_data = np.array(image_data)[:, :, 0] * 0.2989 + np.array(image_data)[:, :, 1] * 0.5870 + np.array(image_data)[:, :, 2] * 0.1140\n    \n    # Apply filter\n    if filter_type == \"blur\":\n        filter_kernel = np.ones((3, 3)) / 9\n    elif filter_type == \"sharpen\":\n        filter_kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n    else:\n        raise ValueError(\"Invalid filter type\")\n    \n    filtered_data = np.zeros(grayscale_data.shape)\n    for i in range(grayscale_data.shape[0] - 2):\n        for j in range(grayscale_data.shape[1] - 2):\n            filtered_data[i, j] = np.sum(grayscale_data[i:i+3, j:j+3] * filter_kernel)\n    \n    return filtered_data.tolist()"
    },
    {
        "function_name": "assign_students_to_projects",
        "file_name": "project_assigner.py",
        "parameters": {
            "students": "List[List[int]] (A 2D list representing the students' skills, where each inner list contains the skills of a student, and each skill is represented as a binary number)",
            "projects": "List[List[int]] (A 2D list representing the required skills for each project, where each inner list contains the required skills for a project, and each skill is represented as a binary number)",
            "max_students_per_project": "int (The maximum number of students that can be assigned to a project)"
        },
        "objectives": [
            "Assign students to projects based on their skills, ensuring that each project has the required skills and does not exceed the maximum number of students.",
            "Use a greedy algorithm to assign students to projects, prioritizing projects that require the most skills.",
            "Ensure that each student is assigned to only one project."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def assign_students_to_projects(students: List[List[int]], projects: List[List[int]], max_students_per_project: int) -> List[List[int]]:\n    project_skills = []\n    for project in projects:\n        required_skills = 0\n        for skill in project:\n            required_skills |= skill\n        project_skills.append(required_skills)\n    \n    assigned_students = []\n    for project_index, project in enumerate(projects):\n        assigned_students.append([])\n        for student in students:\n            student_skills = 0\n            for skill in student:\n                student_skills |= skill\n            if student_skills >= project_skills[project_index] and len(assigned_students[project_index]) < max_students_per_project:\n                assigned_students[project_index].append(student)\n    \n    return assigned_students"
    },
    {
        "function_name": "longest_consecutive_subsequence",
        "file_name": "sequence_finder.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of integer sequences, where each sequence represents a series of events)",
            "max_distance": "int (The maximum distance between two events to be considered consecutive)"
        },
        "objectives": [
            "Find the longest consecutive subsequence of events across all sequences, considering two events to be consecutive if the distance between them is less than or equal to max_distance.",
            "Return the longest consecutive subsequence and the sequences it appears in."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_consecutive_subsequence(sequences: List[List[int]], max_distance: int) -> (List[int], List[int]):\n    longest_subsequence = []\n    sequences_with_subsequence = []\n    \n    for sequence_index, sequence in enumerate(sequences):\n        current_subsequence = [sequence[0]]\n        for event_index, event in enumerate(sequence[1:], start=1):\n            if event - sequence[event_index - 1] <= max_distance:\n                current_subsequence.append(event)\n            else:\n                if len(current_subsequence) > len(longest_subsequence):\n                    longest_subsequence = current_subsequence\n                    sequences_with_subsequence = [sequence_index]\n                elif len(current_subsequence) == len(longest_subsequence):\n                    sequences_with_subsequence.append(sequence_index)\n                current_subsequence = [event]\n        if len(current_subsequence) > len(longest_subsequence):\n            longest_subsequence = current_subsequence\n            sequences_with_subsequence = [sequence_index]\n        elif len(current_subsequence) == len(longest_subsequence):\n            sequences_with_subsequence.append(sequence_index)\n    \n    return longest_subsequence, sequences_with_subsequence"
    },
    {
        "function_name": "approximate_numbers",
        "file_name": "number_approximator.py",
        "parameters": {
            "numbers": "List[float] (A list of floating-point numbers)",
            "max_error": "float (The maximum error allowed when approximating the numbers)"
        },
        "objectives": [
            "Approximate the input numbers as a list of integers, minimizing the total error.",
            "Use a greedy algorithm to select the integers that minimize the total error.",
            "Ensure that the total error is less than or equal to max_error."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def approximate_numbers(numbers: List[float], max_error: float) -> List[int]:\n    total_error = 0\n    approximated_numbers = []\n    \n    for number in numbers:\n        approximated_number = round(number)\n        error = abs(number - approximated_number)\n        if total_error + error <= max_error:\n            total_error += error\n            approximated_numbers.append(approximated_number)\n        else:\n            # Find the closest integer that minimizes the error\n            lower_error = abs(number - (approximated_number - 1))\n            upper_error = abs(number - (approximated_number + 1))\n            if lower_error < upper_error:\n                approximated_numbers.append(approximated_number - 1)\n            else:\n                approximated_numbers.append(approximated_number + 1)\n    \n    return approximated_numbers"
    },
    {
        "function_name": "shortest_concatenated_string",
        "file_name": "string_finder.py",
        "parameters": {
            "strings": "List[str] (A list of strings)",
            "max_length": "int (The maximum length of the concatenated string)",
            "target_string": "str (The target string to find)"
        },
        "objectives": [
            "Find the shortest concatenated string that contains the target string.",
            "Use a greedy algorithm to select the strings that minimize the length of the concatenated string.",
            "Ensure that the length of the concatenated string is less than or equal to max_length."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def shortest_concatenated_string(strings: List[str], max_length: int, target_string: str) -> str:\n    concatenated_string = \"\"\n    \n    for string in strings:\n        if target_string in string and len(concatenated_string) + len(string) <= max_length:\n            concatenated_string += string\n            break\n        elif len(concatenated_string) + len(string) <= max_length:\n            concatenated_string += string\n    \n    return concatenated_string"
    },
    {
        "function_name": "slcs",
        "file_name": "slcs.py",
        "parameters": {
            "`sequences`": "`List[List[int]]` (A list of integer sequences)",
            "`k`": "`int` (The length of the subsequence)"
        },
        "objectives": [
            "Implement the Second-Longest Common Subsequence (SLCS) algorithm to find the SLCS among all sequences.",
            "Use dynamic programming to build a 2D table of lengths of common subsequences.",
            "Return the SLCS as a list of integers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def slcs(sequences: List[List[int]], k: int) -> List[int]:\n    if not sequences:\n        return []\n    \n    lengths = [[0] * (k + 1) for _ in range(len(sequences[0]) + 1)]\n    \n    for seq in sequences[1:]:\n        for i in range(1, len(sequences[0]) + 1):\n            for j in range(1, k + 1):\n                if sequences[0][i - 1] == seq[j - 1]:\n                    lengths[i][j] = lengths[i - 1][j - 1] + 1\n                else:\n                    lengths[i][j] = max(lengths[i - 1][j], lengths[i][j - 1])\n    \n    slcs = []\n    i, j = len(sequences[0]), k\n    while i > 0 and j > 0:\n        if sequences[0][i - 1] == sequences[1][j - 1]:\n            if (i, j) != (len(sequences[0]), k):\n                slcs.append(sequences[0][i - 1])\n            i -= 1\n            j -= 1\n        elif lengths[i - 1][j] > lengths[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return slcs[::-1]"
    },
    {
        "function_name": "cumulative_sum_filter",
        "file_name": "cumulative_sum.py",
        "parameters": {
            "numbers": "List[int] - A list of integers to process.",
            "threshold": "int - The threshold value to filter numbers."
        },
        "objectives": [
            "Filter the input list to include only numbers that are greater than the specified threshold.",
            "Calculate the cumulative sum of the filtered numbers.",
            "Return a tuple containing the filtered list and the cumulative sum."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def cumulative_sum_filter(numbers: List[int], threshold: int) -> Tuple[List[int], int]:\n    filtered_numbers = [num for num in numbers if num > threshold]\n    cumulative_sum = sum(filtered_numbers)\n    return filtered_numbers, cumulative_sum"
    },
    {
        "function_name": "schedule_appointment",
        "file_name": "scheduler.py",
        "parameters": {
            "schedule": "List[List[Tuple[int, int]]] - A 2D schedule representing the time slots for each day of the week.",
            "appointment": "Tuple[int, int] - A time slot requested for an appointment."
        },
        "objectives": [
            "Check if the appointment can be scheduled without conflicts.",
            "Ensure that there is at least a 30-minute gap between appointments.",
            "If the appointment can be scheduled, update the schedule and return the updated schedule.",
            "Return a boolean indicating whether the appointment was scheduled successfully."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def schedule_appointment(schedule: List[List[Tuple[int, int]]], appointment: Tuple[int, int]) -> Tuple[bool, List[List[Tuple[int, int]]]]:\n    day, start_time, end_time = appointment\n    if day < 0 or day >= len(schedule):\n        return False, schedule\n    \n    # Check for conflicts\n    for existing_appointment in schedule[day]:\n        if start_time < existing_appointment[1] and end_time > existing_appointment[0]:\n            return False, schedule\n        \n        # Check for 30-minute gap\n        if existing_appointment[1] < end_time and existing_appointment[1] + 30 > end_time:\n            return False, schedule\n        if existing_appointment[0] > start_time and existing_appointment[0] - 30 < start_time:\n            return False, schedule\n    \n    # Schedule the appointment\n    schedule[day].append((start_time, end_time))\n    schedule[day].sort()\n    return True, schedule"
    },
    {
        "function_name": "evaluate_students",
        "file_name": "grading.py",
        "parameters": {
            "students": "List[List[int]] - A 2D list representing the grades of students in different subjects.",
            "threshold": "int - The minimum grade required to pass."
        },
        "objectives": [
            "Calculate the average grade for each student.",
            "Identify students who have passed or failed based on their average grade.",
            "Return a dictionary with the student's index as the key and their pass/fail status as the value."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def evaluate_students(students: List[List[int]], threshold: int) -> Dict[int, str]:\n    results = {}\n    for i, student in enumerate(students):\n        average_grade = sum(student) / len(student)\n        if average_grade >= threshold:\n            results[i] = \"Pass\"\n        else:\n            results[i] = \"Fail\"\n    return results"
    },
    {
        "function_name": "dbscan_clustering",
        "file_name": "clustering_algorithms.py",
        "parameters": {
            "points": "List[Tuple[float, float]] (A list of points in 2D space)",
            "epsilon": "float (The epsilon value for DBSCAN clustering)",
            "min_samples": "int (The minimum number of samples for DBSCAN clustering)"
        },
        "objectives": [
            "Implement the DBSCAN clustering algorithm on the given points.",
            "Use the epsilon value to determine the density-based clusters.",
            "Return a dictionary with the cluster labels and the points in each cluster."
        ],
        "import_lines": [
            "from typing import List, Dict, Tuple"
        ],
        "function_def": "def dbscan_clustering(points: List[Tuple[float, float]], epsilon: float, min_samples: int) -> Dict[int, List[Tuple[float, float]]]:\n    from sklearn.cluster import DBSCAN\n    clustering = DBSCAN(eps=epsilon, min_samples=min_samples).fit(points)\n    clusters = {}\n    for i, label in enumerate(clustering.labels_):\n        if label not in clusters:\n            clusters[label] = []\n        clusters[label].append(points[i])\n    \n    return clusters"
    },
    {
        "function_name": "min_operations_to_threshold",
        "file_name": "threshold_achiever.py",
        "parameters": {
            "nums": "List[int] (A list of integers)",
            "threshold": "int (The threshold value)"
        },
        "objectives": [
            "Implement an algorithm to find the minimum number of operations (addition or subtraction) required to make all elements in the list greater than the threshold value.",
            "Ensure that the algorithm operates in a time complexity better than O(n^2).",
            "The operations should be applied in such a way that the list remains sorted after each operation.",
            "Return the minimum number of operations required."
        ],
        "import_lines": [
            "from typing import List",
            "import heapq"
        ],
        "function_def": "def min_operations_to_threshold(nums: List[int], threshold: int) -> int:\n    heap = []\n    operations = 0\n    \n    for num in nums:\n        heapq.heappush(heap, num)\n        \n        while heap[0] < threshold:\n            operations += threshold - heap[0]\n            heapq.heappop(heap)\n            heapq.heappush(heap, threshold)\n    \n    return operations"
    },
    {
        "function_name": "k_hops_away",
        "file_name": "k_hops_away.py",
        "parameters": {
            "graph": "Dict[int, List[int]] (An adjacency list representation of a graph)",
            "source": "int (The source node for the graph traversal)",
            "k": "int (The number of hops)"
        },
        "objectives": [
            "Implement an algorithm to find all nodes in the graph that are exactly k hops away from the source node.",
            "Ensure that the algorithm operates in a time complexity better than O(n^2).",
            "The graph can contain cycles.",
            "Return the list of nodes that are exactly k hops away from the source node."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import deque"
        ],
        "function_def": "def k_hops_away(graph: Dict[int, List[int]], source: int, k: int) -> List[int]:\n    queue = deque([(source, 0)])\n    visited = set([source])\n    result = []\n    \n    while queue:\n        node, hops = queue.popleft()\n        \n        if hops == k:\n            result.append(node)\n        \n        elif hops < k:\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, hops + 1))\n                    visited.add(neighbor)\n    \n    return result"
    },
    {
        "function_name": "process_transactions",
        "file_name": "accounting.py",
        "parameters": {
            "transactions": "List[Tuple[int, int, str]] (A list of transactions with account number, amount, and type)"
        },
        "objectives": [
            "Implement a transaction processor that can handle different types of transactions (e.g., deposit, withdrawal).",
            "Calculate the net balance for each account.",
            "Return a dictionary mapping each account number to its corresponding net balance."
        ],
        "import_lines": [
            "from typing import List, Tuple, Dict"
        ],
        "function_def": "def process_transactions(transactions: List[Tuple[int, int, str]]) -> Dict[int, int]:\n    balances = {}\n    \n    for account, amount, transaction_type in transactions:\n        if account not in balances:\n            balances[account] = 0\n        \n        if transaction_type == \"deposit\":\n            balances[account] += amount\n        elif transaction_type == \"withdrawal\":\n            balances[account] -= amount\n    \n    return balances"
    },
    {
        "function_name": "find_overlapping_rectangles",
        "file_name": "rectangle_overlap.py",
        "parameters": {
            "rectangles": "List[Tuple[int, int, int, int]] (A list of rectangles with x, y, width, and height)"
        },
        "objectives": [
            "Implement a sweep line algorithm to find all overlapping rectangles.",
            "Return a list of pairs of overlapping rectangles."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def find_overlapping_rectangles(rectangles: List[Tuple[int, int, int, int]]) -> List[Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]]:\n    events = []\n    \n    for x, y, w, h in rectangles:\n        events.append((x, 1, (x, y, w, h)))\n        events.append((x + w, -1, (x, y, w, h)))\n    \n    events.sort()\n    \n    active_rectangles = []\n    overlapping_pairs = []\n    \n    for x, delta, rectangle in events:\n        if delta == 1:\n            active_rectangles.append(rectangle)\n        else:\n            active_rectangles.remove(rectangle)\n        \n        for other in active_rectangles:\n            if (rectangle[0] < other[0] + other[2] and\n                rectangle[0] + rectangle[2] > other[0] and\n                rectangle[1] < other[1] + other[3] and\n                rectangle[1] + rectangle[3] > other[1]):\n                overlapping_pairs.append((rectangle, other))\n    \n    return overlapping_pairs"
    },
    {
        "function_name": "largest_subgrid",
        "file_name": "grid_processor.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix representing a grid)",
            "threshold": "int (The threshold value)"
        },
        "objectives": [
            "Implement a function to find the largest rectangular sub-grid in the matrix where all values are greater than the threshold.",
            "Ensure the function handles cases where no sub-grid has all values greater than the threshold.",
            "Return the coordinates of the top-left and bottom-right corners of the largest sub-grid."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def largest_subgrid(matrix: List[List[int]], threshold: int) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    max_size = 0\n    max_coords = ((0, 0), (0, 0))\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] > threshold:\n                dp[i][j] = 1\n                if i > 0 and j > 0:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                if dp[i][j] > max_size:\n                    max_size = dp[i][j]\n                    max_coords = ((i - max_size + 1, j - max_size + 1), (i, j))\n    \n    return max_coords"
    },
    {
        "function_name": "multiple_sequence_aligner",
        "file_name": "sequence_aligner.py",
        "parameters": {
            "sequences": "List[str] (A list of DNA sequences)",
            "match_score": "int (The score for a match)",
            "mismatch_score": "int (The score for a mismatch)"
        },
        "objectives": [
            "Implement a function to perform a multiple sequence alignment using dynamic programming.",
            "The function should return the aligned sequences as a list of strings.",
            "The function should handle cases where the input sequences have different lengths."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def multiple_sequence_aligner(sequences: List[str], match_score: int, mismatch_score: int) -> List[str]:\n    if len(sequences) == 0:\n        return []\n    \n    # Initialize the score matrix\n    score_matrix = [[0] * (len(sequences[0]) + 1) for _ in range(len(sequences))]\n    \n    # Initialize the alignment matrix\n    alignment_matrix = [[[''] * (len(sequences[0]) + 1) for _ in range(len(sequences[0]) + 1)] for _ in range(len(sequences))]\n    \n    # Fill in the score matrix\n    for i in range(len(sequences)):\n        for j in range(len(sequences[0]) + 1):\n            if j == 0:\n                score_matrix[i][j] = 0\n            else:\n                score_matrix[i][j] = max(score_matrix[i-1][j-1] + (match_score if sequences[i][j-1] == sequences[0][j-1] else mismatch_score),\n                                        score_matrix[i-1][j] + mismatch_score,\n                                        score_matrix[i][j-1] + mismatch_score)\n    \n    # Fill in the alignment matrix\n    for i in range(len(sequences)):\n        for j in range(len(sequences[0]) + 1):\n            if j == 0:\n                alignment_matrix[i][j][0] = sequences[i][0:j]\n            else:\n                alignment_matrix[i][j][0] = sequences[i][0:j-1]\n                if sequences[i][j-1] == sequences[0][j-1]:\n                    alignment_matrix[i][j][0] += sequences[0][j-1]\n                else:\n                    alignment_matrix[i][j][0] += '-'\n    \n    # Reconstruct the aligned sequences\n    aligned_sequences = []\n    for i in range(len(sequences)):\n        aligned_sequence = ''\n        for j in range(len(sequences[0])):\n            if sequences[i][j] == sequences[0][j]:\n                aligned_sequence += sequences[0][j]\n            else:\n                aligned_sequence += '-'\n        aligned_sequences.append(aligned_sequence)\n    \n    return aligned_sequences"
    },
    {
        "function_name": "kmeans_clustering",
        "file_name": "kmeans_clustering.py",
        "parameters": {
            "points": "List[Tuple[int, int]] (A list of 2D points)",
            "k": "int (The number of clusters to find)"
        },
        "objectives": [
            "Perform the k-means clustering algorithm on the given points.",
            "The function should return a list of cluster centroids.",
            "The function should initialize the centroids randomly."
        ],
        "import_lines": [
            "import random",
            "from typing import List, Tuple"
        ],
        "function_def": "def kmeans_clustering(points: List[Tuple[int, int]], k: int) -> List[Tuple[float, float]]:\n    centroids = random.sample(points, k)\n    while True:\n        clusters = [[] for _ in range(k)]\n        for point in points:\n            closest_centroid_index = min(range(k), key=lambda i: ((point[0] - centroids[i][0]) ** 2 + (point[1] - centroids[i][1]) ** 2) ** 0.5)\n            clusters[closest_centroid_index].append(point)\n        new_centroids = [(sum(x for x, y in cluster) / len(cluster), sum(y for x, y in cluster) / len(cluster)) for cluster in clusters]\n        if new_centroids == centroids:\n            break\n        centroids = new_centroids\n    return centroids"
    },
    {
        "function_name": "word_tokenizer",
        "file_name": "word_tokenizer.py",
        "parameters": {
            "text": "str (A piece of text)",
            "stop_words": "List[str] (A list of stop words to ignore)"
        },
        "objectives": [
            "Tokenize the given text into individual words.",
            "Ignore the stop words and punctuation.",
            "Return a list of unique words in the text."
        ],
        "import_lines": [
            "import re",
            "from typing import List"
        ],
        "function_def": "def word_tokenizer(text: str, stop_words: List[str]) -> List[str]:\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    return list(set(word for word in words if word not in stop_words))"
    },
    {
        "function_name": "ngram_extractor",
        "file_name": "nlp_utils.py",
        "parameters": {
            "text": "str",
            "ngrams": "int",
            "threshold": "float"
        },
        "objectives": [
            "Calculate the TF-IDF scores for each word in the given text.",
            "Extract the top N-grams (sequences of n words) from the text based on their TF-IDF scores.",
            "Filter out N-grams with a score below the specified threshold.",
            "Return the extracted N-grams along with their scores."
        ],
        "import_lines": [
            "import re",
            "from collections import defaultdict",
            "from typing import List, Tuple",
            "from math import log"
        ],
        "function_def": "def ngram_extractor(text: str, ngrams: int, threshold: float) -> List[Tuple[List[str], float]]:\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    word_freq = defaultdict(int)\n    for word in words:\n        word_freq[word] += 1\n    \n    total_words = len(words)\n    tf_idf_scores = {}\n    for word, freq in word_freq.items():\n        tf = freq / total_words\n        idf = log(total_words / (1 + freq))\n        tf_idf_scores[word] = tf * idf\n    \n    ngrams_list = []\n    for i in range(len(words) - ngrams + 1):\n        ngram = tuple(words[i:i+ngrams])\n        ngram_score = sum(tf_idf_scores.get(word, 0) for word in ngram) / ngrams\n        if ngram_score > threshold:\n            ngrams_list.append((list(ngram), ngram_score))\n    \n    return ngrams_list"
    },
    {
        "function_name": "min_coins_for_change",
        "file_name": "dp_algorithms.py",
        "parameters": {
            "coins": "List[int] (A list of coin denominations)",
            "amount": "int (The target amount to make change for)",
            "max_coins": "int (The maximum number of coins allowed in the change)"
        },
        "objectives": [
            "Implement dynamic programming to find the minimum number of coins required to make change for the target amount.",
            "Ensure that the number of coins does not exceed the maximum allowed.",
            "Handle cases where the target amount cannot be made with the given coin denominations."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_coins_for_change(coins: List[int], amount: int, max_coins: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n            \n    if dp[amount] > max_coins:\n        return -1\n    \n    return dp[amount]"
    },
    {
        "function_name": "max_non_overlapping_intervals",
        "file_name": "greedy_algorithms.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] (A list of intervals, where each interval is a tuple of two integers representing the start and end points)"
        },
        "objectives": [
            "Implement a greedy algorithm to find the maximum number of non-overlapping intervals that can be selected.",
            "Ensure that the selected intervals do not overlap with each other.",
            "Handle cases where the input list is empty."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[1])\n    selected = [intervals[0]]\n    \n    for interval in intervals[1:]:\n        if interval[0] >= selected[-1][1]:\n            selected.append(interval)\n            \n    return selected"
    },
    {
        "function_name": "interval_counts",
        "file_name": "interval_counter.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]]",
            "points": "List[int]"
        },
        "objectives": [
            "Implement a function to find the number of intervals that each point falls into.",
            "Handle edge cases where the intervals or points list is empty.",
            "Return a list of counts corresponding to each point."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def interval_counts(intervals: List[Tuple[int, int]], points: List[int]) -> List[int]:\n    if not intervals or not points:\n        return [0] * len(points)\n    \n    points_with_index = sorted((point, i) for i, point in enumerate(points))\n    sorted_intervals = sorted(intervals)\n    \n    result = [0] * len(points)\n    interval_index = 0\n    point_index = 0\n    \n    while interval_index < len(sorted_intervals) and point_index < len(points_with_index):\n        point, index = points_with_index[point_index]\n        start, end = sorted_intervals[interval_index]\n        \n        if point >= start and point <= end:\n            result[index] += 1\n            point_index += 1\n        elif point < start:\n            point_index += 1\n        else:\n            interval_index += 1\n    \n    return result"
    },
    {
        "function_name": "median_filter",
        "file_name": "matrix_filters.py",
        "parameters": {
            "`data`": "List[List[int]] - A 2D array of integers representing a matrix.",
            "`threshold`": "int - The threshold value to filter matrix elements."
        },
        "objectives": [
            "Apply a median filter to the matrix elements to reduce noise, using a kernel of size 3x3.",
            "Filter out matrix elements that are below the given threshold.",
            "Return the filtered matrix."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def median_filter(data: List[List[int]], threshold: int) -> List[List[int]]:\n    matrix = np.array(data)\n    filtered_matrix = np.zeros_like(matrix)\n    kernel_size = 3\n    pad = kernel_size // 2\n    padded_matrix = np.pad(matrix, pad, mode='constant')\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            window = padded_matrix[i:i+kernel_size, j:j+kernel_size]\n            median = np.median(window)\n            if median > threshold:\n                filtered_matrix[i, j] = median\n    return filtered_matrix.astype(int).tolist()"
    },
    {
        "function_name": "select_longest_strings",
        "file_name": "string_selector.py",
        "parameters": {
            "strings": "List[str] - A list of strings.",
            "k": "int - The number of strings to select."
        },
        "objectives": [
            "Implement an algorithm to select k strings from the list such that the total length of the selected strings is maximized.",
            "Ensure the algorithm operates in a time complexity better than O(n log n).",
            "Handle the case where k is greater than the length of the list.",
            "Return the selected strings as a list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def select_longest_strings(strings: List[str], k: int) -> List[str]:\n    if k > len(strings):\n        return strings\n    \n    # Sort the strings by their lengths in descending order\n    strings.sort(key=len, reverse=True)\n    \n    # Select the k longest strings\n    return strings[:k]"
    },
    {
        "function_name": "interval_overlap_check",
        "file_name": "interval_overlap.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] - A list of intervals.",
            "target": "int - The target interval to search for."
        },
        "objectives": [
            "Implement a function that checks if the target interval overlaps with any of the intervals in the list.",
            "Ensure the function handles the case where the list is empty.",
            "Return True if the target interval overlaps with any of the intervals, False otherwise."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def interval_overlap_check(intervals: List[Tuple[int, int]], target: Tuple[int, int]) -> bool:\n    for interval in intervals:\n        if (interval[0] <= target[1] and interval[1] >= target[0]):\n            return True\n    \n    return False"
    },
    {
        "function_name": "sentiment_analysis_twitter",
        "file_name": "sentiment_analysis_twitter.py",
        "parameters": {
            "twitter_data": "List[dict] (A list of tweets, where each tweet is a dictionary containing 'text' and 'user')",
            "keywords": "List[str] (A list of keywords to search for in the tweets)",
            "sentiment_threshold": "float (The minimum sentiment score to consider)"
        },
        "objectives": [
            "Perform sentiment analysis on each tweet.",
            "Search for the specified keywords in each tweet.",
            "Only consider tweets with a sentiment score greater than or equal to the threshold.",
            "Return a dictionary containing the sentiment scores for each user."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "from nltk.sentiment.vader import SentimentIntensityAnalyzer"
        ],
        "function_def": "def sentiment_analysis_twitter(twitter_data: List[Dict], keywords: List[str], sentiment_threshold: float) -> Dict[str, float]:\n    if not twitter_data or not keywords:\n        return {}\n    \n    sia = SentimentIntensityAnalyzer()\n    result = {}\n    \n    for tweet in twitter_data:\n        tweet_text = tweet['text']\n        sentiment_score = sia.polarity_scores(tweet_text)['compound']\n        if sentiment_score >= sentiment_threshold:\n            for keyword in keywords:\n                if keyword.lower() in tweet_text.lower():\n                    if tweet['user'] not in result:\n                        result[tweet['user']] = []\n                    result[tweet['user']].append(sentiment_score)\n    \n    for user in result:\n        result[user] = sum(result[user]) / len(result[user])\n    \n    return result"
    },
    {
        "function_name": "item_frequency_ranking",
        "file_name": "item_frequency_ranking.py",
        "parameters": {
            "ranking_data": "List[dict] (A list of ranking data, where each dictionary contains the rank and the item being ranked)",
            "threshold": "int (The minimum frequency for an item to be considered)"
        },
        "objectives": [
            "Count the frequency of each item in the ranking data.",
            "Use a dictionary to store the frequency of each item.",
            "Only consider items with a frequency greater than or equal to the threshold.",
            "Return a dictionary containing the frequency of each item."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def item_frequency_ranking(ranking_data: List[Dict], threshold: int) -> Dict:\n    if not ranking_data or threshold <= 0:\n        return {}\n    \n    frequency_dict = {}\n    \n    for item in ranking_data:\n        item_name = item['item']\n        if item_name not in frequency_dict:\n            frequency_dict[item_name] = 0\n        frequency_dict[item_name] += 1\n    \n    result = {item: frequency for item, frequency in frequency_dict.items() if frequency >= threshold}\n    \n    return result"
    },
    {
        "function_name": "balance_parentheses",
        "file_name": "parentheses_balancer.py",
        "parameters": {
            "string": "str - A string of parentheses that need to be balanced.",
            "open_paren": "str - The opening parenthesis character.",
            "close_paren": "str - The closing parenthesis character."
        },
        "objectives": [
            "Check if the input string is empty or the opening and closing parentheses are the same, in which case the function should return the original string.",
            "Balance the parentheses in the string by ensuring that every opening parenthesis has a corresponding closing parenthesis.",
            "Use a stack data structure to keep track of the opening parentheses and match them with the closing parentheses.",
            "Return the balanced string of parentheses."
        ],
        "import_lines": [],
        "function_def": "def balance_parentheses(string, open_paren, close_paren):\n    if not string or open_paren == close_paren:\n        return string\n    stack = []\n    balanced_string = \"\"\n    \n    for char in string:\n        if char == open_paren:\n            stack.append(char)\n            balanced_string += char\n        elif char == close_paren:\n            if stack:\n                stack.pop()\n                balanced_string += char\n            else:\n                balanced_string += open_paren\n        else:\n            balanced_string += char\n    \n    balanced_string += close_paren * len(stack)\n    return balanced_string"
    },
    {
        "function_name": "triangle_product",
        "file_name": "triangle_calculator.py",
        "parameters": {
            "triangle": "List[List[int]] (A 2D list representing a triangle)",
            "depth": "int (The current depth of the triangle)"
        },
        "objectives": [
            "Calculate the sum of the individual elements in each sub-triangle.",
            "For each sub-triangle, check if the sum is equal to the last element of the sub-triangle.",
            "If the sum equals the last element, calculate the product of the remaining elements in the sub-triangle.",
            "Return a list of these products."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def triangle_product(triangle: List[List[int]], depth: int) -> List[int]:\n    if len(triangle) == 1:\n        return []\n    \n    products = []\n    for i in range(len(triangle) - 1):\n        sub_triangle = [row[:i+1] for row in triangle[:i+2]]\n        sub_triangle_sum = sum(num for row in sub_triangle for num in row[:-1])\n        if sub_triangle_sum == sub_triangle[-1][-1]:\n            product = 1\n            for row in sub_triangle:\n                for num in row[:-1]:\n                    product *= num\n            products.append(product)\n    \n    if depth > 0:\n        new_triangle = [row[:-1] for row in triangle[:-1]]\n        products.extend(triangle_product(new_triangle, depth - 1))\n    \n    return products"
    },
    {
        "function_name": "phrase_extraction",
        "file_name": "phrase_extractor.py",
        "parameters": {
            "text": "str (The input text)",
            "keywords": "List[str] (A list of keywords)",
            "min_length": "int (The minimum length of a phrase)"
        },
        "objectives": [
            "Implement a phrase extraction algorithm using a combination of natural language processing (NLP) and information theory.",
            "Calculate the entropy of each possible phrase in the text.",
            "Check each phrase against the given keywords.",
            "Return a list of extracted phrases that contain at least one keyword and meet the minimum length requirement."
        ],
        "import_lines": [
            "from collections import Counter",
            "from math import log",
            "import re",
            "from typing import List"
        ],
        "function_def": "def phrase_extraction(text: str, keywords: List[str], min_length: int) -> List[str]:\n    words = re.findall(r'\\b\\w+\\b', text)\n    phrases = set()\n    for length in range(1, len(words) + 1):\n        for i in range(len(words) - length + 1):\n            phrase = ' '.join(words[i:i+length])\n            phrases.add(phrase)\n    \n    extracted_phrases = []\n    for phrase in phrases:\n        if len(phrase) >= min_length and any(keyword in phrase for keyword in keywords):\n            entropy = 0\n            counter = Counter(re.findall(r'\\b\\w+\\b', phrase))\n            for count in counter.values():\n                probability = count / len(re.findall(r'\\b\\w+\\b', phrase))\n                entropy -= probability * log(probability, 2)\n            if entropy < log(len(re.findall(r'\\b\\w+\\b', phrase)), 2) / 2:\n                extracted_phrases.append(phrase)\n    \n    return extracted_phrases"
    },
    {
        "function_name": "triplet_sum",
        "file_name": "triplet_sum.py",
        "parameters": {
            "arrays": "List[List[int]] - A list of sorted arrays.",
            "target": "int - The target sum."
        },
        "objectives": [
            "Implement a function to find all unique triplets in the given lists that sum up to the target value.",
            "Use a two-pointer technique to efficiently find the triplets.",
            "Handle edge cases where the input lists are empty or have duplicate elements."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def triplet_sum(arrays: List[List[int]], target: int) -> List[List[int]]:\n    result = []\n    for i in range(len(arrays)):\n        for j in range(len(arrays[i]) - 2):\n            left, right = j + 1, len(arrays[i]) - 1\n            while left < right:\n                current_sum = arrays[i][j] + arrays[i][left] + arrays[i][right]\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    triplet = sorted([arrays[i][j], arrays[i][left], arrays[i][right]])\n                    if triplet not in result:\n                        result.append(triplet)\n                    left += 1\n                    right -= 1\n    return result"
    },
    {
        "function_name": "gaussian_blur",
        "file_name": "gaussian_blur.py",
        "parameters": {
            "image_data": "List[List[List[int]]] (A 3D list representing a color image)"
        },
        "objectives": [
            "Apply a Gaussian blur to the input image.",
            "Calculate the standard deviation of the blur.",
            "Return the blurred image and its standard deviation."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np",
            "from scipy.ndimage import gaussian_filter"
        ],
        "function_def": "def gaussian_blur(image_data: List[List[List[int]]]) -> (List[List[List[int]]], float):\n    image_array = np.array(image_data)\n    blurred_image = gaussian_filter(image_array, sigma=2)\n    std_dev = np.std(blurred_image)\n    blurred_image_list = blurred_image.tolist()\n    \n    return blurred_image_list, std_dev"
    },
    {
        "function_name": "trading_simulator",
        "file_name": "trading_simulator.py",
        "parameters": {
            "prices": "List[float] (A list of stock prices over time)",
            "transactions": "List[str] (A list of buy and sell transactions)"
        },
        "objectives": [
            "Implement a function that simulates a trading system with the given stock prices and transactions.",
            "Use a stack to keep track of the buy and sell transactions.",
            "Return the net profit from all transactions."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def trading_simulator(prices: List[float], transactions: List[str]) -> float:\n    stack = []\n    profit = 0\n    \n    for i, transaction in enumerate(transactions):\n        if transaction == 'buy':\n            stack.append(prices[i])\n        elif transaction == 'sell' and stack:\n            buy_price = stack.pop()\n            profit += prices[i] - buy_price\n    \n    return profit"
    },
    {
        "function_name": "most_frequent_subsequences",
        "file_name": "subsequence_frequencies.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of sequences of integers)",
            "k": "int (The length of the subsequences to consider)"
        },
        "objectives": [
            "Calculate the frequency of each subsequence of length `k` in the given sequences.",
            "Identify the most frequent subsequences that occur with the same maximum frequency.",
            "Return a list of the most frequent subsequences."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def most_frequent_subsequences(sequences: List[List[int]], k: int) -> List[List[int]]:\n    frequencies = defaultdict(int)\n    \n    for sequence in sequences:\n        for i in range(len(sequence) - k + 1):\n            subsequence = tuple(sequence[i:i+k])\n            frequencies[subsequence] += 1\n    \n    max_frequency = max(frequencies.values())\n    \n    most_frequent_subsequences = [list(subsequence) for subsequence, frequency in frequencies.items() if frequency == max_frequency]\n    \n    return most_frequent_subsequences"
    },
    {
        "function_name": "sequence_combinations",
        "file_name": "sequence_combiner.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of integer sequences)",
            "target_sum": "int (The target sum to achieve)"
        },
        "objectives": [
            "Identify all possible combinations of sequences that sum up to the target sum.",
            "Use dynamic programming to build a solution that avoids duplicate combinations.",
            "Return a list of combinations, where each combination is a list of sequences."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def sequence_combinations(sequences, target_sum):\n    dp = [[] for _ in range(target_sum + 1)]\n    dp[0] = [[]]\n    \n    for sequence in sequences:\n        for i in range(target_sum, -1, -1):\n            if i >= sequence[-1]:\n                for prev_combination in dp[i - sequence[-1]]:\n                    dp[i].append(prev_combination + [sequence])\n    \n    return dp[target_sum]"
    },
    {
        "function_name": "binomial_coefficient_calculator",
        "file_name": "binomial_coefficient.py",
        "parameters": {
            "n": "int",
            "m": "int",
            "k": "int"
        },
        "objectives": [
            "Calculate the binomial coefficients (n choose k) for all values of n from 0 to 'm'.",
            "Store the coefficients in a 2D array where each row corresponds to a value of n and each column corresponds to a value of k.",
            "Return the 2D array of binomial coefficients."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def binomial_coefficient_calculator(n: int, m: int, k: int) -> List[List[int]]:\n    coefficients = [[0] * (k + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        coefficients[i][0] = 1\n        coefficients[i][min(i, k)] = 1\n    \n    for i in range(1, m + 1):\n        for j in range(1, min(i, k) + 1):\n            coefficients[i][j] = coefficients[i - 1][j - 1] + coefficients[i - 1][j]\n    \n    return coefficients"
    },
    {
        "function_name": "sequence_padder",
        "file_name": "sequence_processor.py",
        "parameters": {
            "sequences": "List[List[int]] - A list of sequences of integers.",
            "sequence_length": "int - The desired length of the sequences."
        },
        "objectives": [
            "Implement a function to pad or truncate sequences to a specific length using a specific padding value.",
            "Use a padding value of -1 to pad sequences shorter than the desired length.",
            "Truncate sequences longer than the desired length.",
            "Return a list of padded or truncated sequences."
        ],
        "import_lines": [],
        "function_def": "def sequence_padder(sequences, sequence_length):\n    padded_sequences = []\n    \n    for sequence in sequences:\n        if len(sequence) > sequence_length:\n            padded_sequences.append(sequence[:sequence_length])\n        else:\n            padded_sequence = sequence + [-1] * (sequence_length - len(sequence))\n            padded_sequences.append(padded_sequence)\n    \n    return padded_sequences"
    },
    {
        "function_name": "digit_manipulator",
        "file_name": "digit_processor.py",
        "parameters": {
            "digits": "List[int] - A list of digits to manipulate.",
            "num_operations": "int - The number of operations to perform."
        },
        "objectives": [
            "Implement a function to perform a sequence of operations on a list of digits.",
            "The operations include removing the first digit, removing the last digit, and removing all occurrences of a specific digit.",
            "Return the final list of digits after performing all operations."
        ],
        "import_lines": [],
        "function_def": "def digit_manipulator(digits, num_operations):\n    for _ in range(num_operations):\n        operation = input(\"Enter operation (remove_first, remove_last, remove_digit): \")\n        \n        if operation == \"remove_first\":\n            digits = digits[1:]\n        elif operation == \"remove_last\":\n            digits = digits[:-1]\n        elif operation == \"remove_digit\":\n            digit = int(input(\"Enter digit to remove: \"))\n            digits = [x for x in digits if x != digit]\n    \n    return digits"
    },
    {
        "function_name": "kth_smallest_unique_score",
        "file_name": "score_utils.py",
        "parameters": {
            "`scores`": "List[int] (A list of scores)",
            "`k`": "int (The number of top scores to select)"
        },
        "objectives": [
            "Implement a function to find the kth smallest score that is not a duplicate.",
            "If there are less than k unique scores, return -1.",
            "Use a heap data structure to keep track of the k smallest scores."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def kth_smallest_unique_score(scores, k):\n    seen = set()\n    unique_scores = []\n    \n    for score in scores:\n        if score not in seen:\n            seen.add(score)\n            unique_scores.append(score)\n        if len(seen) == k:\n            break\n    \n    if len(seen) < k:\n        return -1\n    \n    return heapq.nsmallest(k, unique_scores)[-1]"
    },
    {
        "function_name": "currency_converter",
        "file_name": "currency_converter.py",
        "parameters": {
            "rates": "List[List[float]] (A 2D list of exchange rates between different currencies)",
            "amounts": "List[float] (A list of amounts to be converted)",
            "source_currency": "int (The index of the source currency in the rates list)",
            "target_currency": "int (The index of the target currency in the rates list)"
        },
        "objectives": [
            "Implement a function to convert a list of amounts from a source currency to a target currency.",
            "Ensure that the exchange rates are applied correctly to each amount.",
            "Handle cases where the source and target currencies are the same.",
            "Return the list of converted amounts."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def currency_converter(rates: List[List[float]], amounts: List[float], source_currency: int, target_currency: int) -> List[float]:\n    if source_currency == target_currency:\n        return amounts\n    \n    converted_amounts = []\n    for amount in amounts:\n        if source_currency != 0:\n            amount = amount / rates[source_currency][0]\n        converted_amount = amount * rates[target_currency][0]\n        converted_amounts.append(converted_amount)\n    \n    return converted_amounts"
    },
    {
        "function_name": "regex_matcher",
        "file_name": "regex_matcher.py",
        "parameters": {
            "pattern": "str - A regular expression pattern to match strings against.",
            "strings": "List[str] - A list of strings to match against the pattern."
        },
        "objectives": [
            "Compile the regular expression pattern into a pattern object.",
            "Use the pattern object to match each string in the list against the pattern.",
            "Return a list of boolean values indicating whether each string matches the pattern."
        ],
        "import_lines": [
            "from typing import List",
            "import re"
        ],
        "function_def": "def regex_matcher(pattern: str, strings: List[str]) -> List[bool]:\n    compiled_pattern = re.compile(pattern)\n    \n    return [bool(compiled_pattern.fullmatch(string)) for string in strings]"
    },
    {
        "function_name": "find_sublists_with_threshold",
        "file_name": "sliding_window.py",
        "parameters": {
            "nums": "List[int] - A list of integers",
            "threshold": "int - The maximum difference between adjacent elements",
            "window_size": "int - The size of the window"
        },
        "objectives": [
            "Implement a sliding window algorithm to find all sublists of size 'window_size' that have a difference of at most 'threshold' between adjacent elements.",
            "Handle cases where the input list is empty or the window size is larger than the list.",
            "Return the sublists as a list of lists."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_sublists_with_threshold(nums: List[int], threshold: int, window_size: int) -> List[List[int]]:\n    if not nums or window_size > len(nums):\n        return []\n    \n    result = []\n    for i in range(len(nums) - window_size + 1):\n        sublist = nums[i:i + window_size]\n        if all(abs(sublist[j] - sublist[j - 1]) <= threshold for j in range(1, len(sublist))):\n            result.append(sublist)\n    \n    return result"
    },
    {
        "function_name": "word_break",
        "file_name": "dynamic_programming.py",
        "parameters": {
            "text": "str - The input text",
            "dictionary": "List[str] - A list of valid words"
        },
        "objectives": [
            "Implement a dynamic programming algorithm to break the input text into a valid sequence of words.",
            "Handle cases where the input text is empty or the dictionary is empty.",
            "Return the sequence of words as a list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def word_break(text: str, dictionary: List[str]) -> List[str]:\n    if not text or not dictionary:\n        return []\n    \n    n = len(text)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and text[j:i] in dictionary:\n                dp[i] = True\n                break\n    \n    if not dp[-1]:\n        return []\n    \n    result = []\n    i = n\n    while i > 0:\n        for j in range(i):\n            if dp[j] and text[j:i] in dictionary:\n                result.append(text[j:i])\n                i = j\n                break\n    \n    return result[::-1]"
    },
    {
        "function_name": "phong_shading",
        "file_name": "phong_shading.py",
        "parameters": {
            "`mesh`": "List[List[List[float]]] - A 3D mesh represented as a list of vertices",
            "`normals`": "List[List[float]] - The list of normals"
        },
        "objectives": [
            "Implement the phong shading algorithm to calculate the color of each vertex.",
            "Handle cases where the mesh or normals are empty.",
            "Return the colored mesh as a list of vertices."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def phong_shading(mesh: List[List[List[float]]], normals: List[List[float]]) -> List[List[List[float]]]:\n    # Define the light source\n    light_source = [1, 1, 1]\n    \n    # Define the ambient light\n    ambient_light = [0.5, 0.5, 0.5]\n    \n    # Define the diffuse light\n    diffuse_light = [0.5, 0.5, 0.5]\n    \n    # Define the specular light\n    specular_light = [0.5, 0.5, 0.5]\n    \n    # Create a list to store the colored mesh\n    colored_mesh = []\n    \n    # Iterate over the vertices\n    for i, vertex in enumerate(mesh):\n        # Calculate the normal vector\n        normal = normals[i]\n        \n        # Calculate the ambient color\n        ambient_color = [ambient_light[0], ambient_light[1], ambient_light[2]]\n        \n        # Calculate the diffuse color\n        diffuse_color = [diffuse_light[0] * max(0, sum(a * b for a, b in zip(normal, light_source))), \n                         diffuse_light[1] * max(0, sum(a * b for a, b in zip(normal, light_source))), \n                         diffuse_light[2] * max(0, sum(a * b for a, b in zip(normal, light_source)))]\n        \n        # Calculate the specular color\n        specular_color = [specular_light[0] * (max(0, sum(a * b for a, b in zip(normal, light_source))) ** 128), \n                          specular_light[1] * (max(0, sum(a * b for a, b in zip(normal, light_source))) ** 128), \n                          specular_light[2] * (max(0, sum(a * b for a, b in zip(normal, light_source))) ** 128)]\n        \n        # Calculate the final color\n        color = [ambient_color[0] + diffuse_color[0] + specular_color[0], \n                 ambient_color[1] + diffuse_color[1] + specular_color[1], \n                 ambient_color[2] + diffuse_color[2] + specular_color[2]]\n        \n        # Add the colored vertex to the colored mesh\n        colored_mesh.append(color)\n    \n    return colored_mesh"
    },
    {
        "function_name": "travelling_salesman",
        "file_name": "tsp_solver.py",
        "parameters": {
            "`routes`": "List[List[int]] - A list of routes where each route is a list of city IDs.",
            "`distances`": "List[List[int]] - A 2D array representing the distances between cities."
        },
        "objectives": [
            "Implement a function to find the shortest route that visits each city exactly once and returns to the starting city.",
            "Use the Nearest Neighbor algorithm to efficiently find the shortest route.",
            "Handle cases where the input routes or distances are empty."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def travelling_salesman(routes: List[List[int]], distances: List[List[int]]) -> List[int]:\n    if not routes or not distances:\n        return []\n    \n    num_cities = len(distances)\n    visited = [False] * num_cities\n    current_city = 0\n    route = [current_city]\n    visited[current_city] = True\n    \n    for _ in range(num_cities - 1):\n        min_distance = float('inf')\n        next_city = None\n        for i in range(num_cities):\n            if not visited[i] and distances[current_city][i] < min_distance:\n                min_distance = distances[current_city][i]\n                next_city = i\n        route.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    \n    route.append(route[0])\n    return route"
    },
    {
        "function_name": "otsu_thresholding",
        "file_name": "image_segmentation.py",
        "parameters": {
            "image": "List[List[int]] (A 2D list representing a grayscale image)",
            "threshold": "int (The threshold value for binary segmentation)"
        },
        "objectives": [
            "Implement the Otsu's thresholding algorithm to segment the image into foreground and background.",
            "Calculate the variance between the foreground and background classes.",
            "Determine the optimal threshold value based on the variance.",
            "Return the segmented image as a 2D list of binary values."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def otsu_thresholding(image: List[List[int]], threshold: int) -> List[List[int]]:\n    histogram = np.histogram(image, bins=256, range=(0, 256))[0]\n    total_pixels = sum(histogram)\n    \n    sum_background = 0\n    sum_foreground = sum(i * histogram[i] for i in range(256))\n    count_background = 0\n    count_foreground = total_pixels\n    \n    max_variance = 0\n    optimal_threshold = 0\n    for i in range(1, 256):\n        count_background += histogram[i - 1]\n        count_foreground -= histogram[i - 1]\n        sum_background += (i - 1) * histogram[i - 1]\n        sum_foreground -= i * histogram[i - 1]\n        \n        mean_background = sum_background / count_background\n        mean_foreground = sum_foreground / count_foreground\n        \n        variance = count_background * count_foreground * (mean_background - mean_foreground) ** 2\n        \n        if variance > max_variance:\n            max_variance = variance\n            optimal_threshold = i\n    \n    segmented_image = [[1 if pixel > optimal_threshold else 0 for pixel in row] for row in image]\n    \n    return segmented_image"
    },
    {
        "function_name": "convolve_image",
        "file_name": "cnn.py",
        "parameters": {
            "image": "np.ndarray (The input image)",
            "kernel": "np.ndarray (The convolution kernel)"
        },
        "objectives": [
            "Implement a convolutional neural network (CNN) to apply the convolution kernel to the input image.",
            "Apply the kernel to each pixel in the image, using a sliding window approach.",
            "Return the resulting feature map after applying the kernel."
        ],
        "import_lines": [
            "import numpy as np"
        ],
        "function_def": "def convolve_image(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    image_height, image_width = image.shape\n    kernel_height, kernel_width = kernel.shape\n    feature_map = np.zeros((image_height - kernel_height + 1, image_width - kernel_width + 1))\n    \n    for i in range(image_height - kernel_height + 1):\n        for j in range(image_width - kernel_width + 1):\n            patch = image[i:i+kernel_height, j:j+kernel_width]\n            feature_map[i, j] = np.sum(patch * kernel)\n    \n    return feature_map"
    },
    {
        "function_name": "topological_sorter",
        "file_name": "topological_sorter.py",
        "parameters": {
            "graph": "List[List[int]] - An adjacency matrix representing a directed graph.",
            "start_vertex": "int - The starting vertex for the topological sort."
        },
        "objectives": [
            "Implement a Topological Sort algorithm to sort the vertices of the graph based on their dependencies.",
            "Use Kahn's algorithm to find a valid ordering of vertices that ensures no vertex is visited before its dependencies.",
            "Return the ordering of vertices if a valid ordering exists; otherwise, raise an exception indicating a cyclic dependency."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def topological_sorter(graph: List[List[int]], start_vertex: int) -> List[int]:\n    in_degree = [0] * len(graph)\n    for i in range(len(graph)):\n        for j in range(len(graph[i])):\n            if graph[i][j] == 1:\n                in_degree[j] += 1\n    \n    ordering = []\n    queue = []\n    for i in range(len(in_degree)):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        vertex = queue.pop(0)\n        ordering.append(vertex)\n        for i in range(len(graph[vertex])):\n            if graph[vertex][i] == 1:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    queue.append(i)\n    \n    if len(ordering) != len(graph):\n        raise Exception(\"Cyclic dependency detected\")\n    \n    return ordering"
    },
    {
        "function_name": "suspicious_transactions",
        "file_name": "suspicious_transactions.py",
        "parameters": {
            "transactions": "List[Tuple[str, str, int]] (A list of transactions, where each transaction is a tuple of (sender, receiver, amount))",
            "threshold": "int (The minimum amount required for a transaction to be considered suspicious)"
        },
        "objectives": [
            "Implement a function to detect suspicious transactions in a list of transactions.",
            "A transaction is suspicious if the amount is greater than or equal to the threshold.",
            "The function should return a list of suspicious transactions, along with the total amount of suspicious transactions."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def suspicious_transactions(transactions: List[Tuple[str, str, int]], threshold: int) -> Tuple[List[Tuple[str, str, int]], int]:\n    suspicious_transactions = [transaction for transaction in transactions if transaction[2] >= threshold]\n    total_amount = sum(transaction[2] for transaction in suspicious_transactions)\n    \n    return (suspicious_transactions, total_amount)"
    },
    {
        "function_name": "sequence_comparison",
        "file_name": "sequence_comparison.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of sequences of integers)",
            "window_size": "int (The size of the window to compare sequences)"
        },
        "objectives": [
            "Implement a function to compare sequences of integers using a sliding window approach.",
            "The function should return a list of indices where the sequences match, along with the length of the match.",
            "If a sequence matches multiple times, it should be reported only once."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def sequence_comparison(sequences: List[List[int]], window_size: int) -> List[Tuple[int, int]]:\n    sequence_matches = []\n    for i in range(len(sequences[0]) - window_size + 1):\n        window = sequences[0][i:i + window_size]\n        for j in range(1, len(sequences)):\n            for k in range(len(sequences[j]) - window_size + 1):\n                if sequences[j][k:k + window_size] == window and (i, len(window)) not in sequence_matches:\n                    sequence_matches.append((i, len(window)))\n    \n    return sequence_matches"
    },
    {
        "function_name": "expected_heads",
        "file_name": "probability_algorithms.py",
        "parameters": {
            "`probabilities`": "List[List[float]] (A 2D list of probabilities)",
            "`n`": "int (The number of coin flips)"
        },
        "objectives": [
            "Implement a function to calculate the expected number of heads given a set of probabilities for a sequence of coin flips.",
            "Use dynamic programming to calculate the expected number of heads.",
            "Return the expected number of heads."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def expected_heads(probabilities: List[List[float]], n: int) -> float:\n    rows, cols = len(probabilities), len(probabilities[0])\n    \n    expected_heads = [[0.0] * cols for _ in range(rows)]\n    expected_heads[0] = [p[0] for p in probabilities[0]]\n    \n    for i in range(1, rows):\n        for j in range(cols):\n            expected_heads[i][j] = (expected_heads[i - 1][j] * probabilities[i - 1][j][0] +\n                                    expected_heads[i - 1][j - 1] * probabilities[i - 1][j - 1][1] +\n                                    (j + 1) * probabilities[i][j][1])\n    \n    return expected_heads[-1][-1]"
    },
    {
        "function_name": "closest_point",
        "file_name": "geometry_algorithms.py",
        "parameters": {
            "`points`": "List[List[int]] (A list of points in 2D space)",
            "`x`": "int (The x-coordinate of the target point)",
            "`y`": "int (The y-coordinate of the target point)"
        },
        "objectives": [
            "Implement a function to find the closest point to a target point in 2D space.",
            "Use the Euclidean distance metric to calculate the closest point.",
            "Return the index of the closest point."
        ],
        "import_lines": [
            "from typing import List",
            "import math"
        ],
        "function_def": "def closest_point(points: List[List[int]], x: int, y: int) -> int:\n    closest_index = 0\n    closest_distance = float('inf')\n    \n    for i, point in enumerate(points):\n        distance = math.sqrt((point[0] - x) ** 2 + (point[1] - y) ** 2)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_index = i\n    \n    return closest_index"
    },
    {
        "function_name": "image_grayscaler",
        "file_name": "image_processor.py",
        "parameters": {
            "image": "List[List[List[int]]] (A 3D grid representing the image, where each pixel is an RGB value)",
            "threshold": "int (The threshold value for converting the image to grayscale)"
        },
        "objectives": [
            "Convert the color image to grayscale using the provided threshold value.",
            "Calculate the intensity of each pixel based on its RGB values.",
            "Apply the threshold to determine whether each pixel should be black or white.",
            "Return the grayscale image."
        ],
        "import_lines": [],
        "function_def": "def image_grayscaler(image, threshold):\n    grayscale_image = []\n    \n    for row in image:\n        grayscale_row = []\n        \n        for pixel in row:\n            intensity = sum(pixel) // 3\n            grayscale_pixel = [0, 0, 0] if intensity < threshold else [255, 255, 255]\n            grayscale_row.append(grayscale_pixel)\n        \n        grayscale_image.append(grayscale_row)\n    \n    return grayscale_image"
    },
    {
        "function_name": "shortest_terrain_path",
        "file_name": "terrain_pathfinder.py",
        "parameters": {
            "`matrix`": "`List[List[int]]` (A 2D matrix representing the terrain elevation)",
            "`start_position`": "`Tuple[int, int]` (The starting position coordinates)",
            "`end_position`": "`Tuple[int, int]` (The ending position coordinates)"
        },
        "objectives": [
            "Find the shortest path in a 2D terrain matrix from the start position to the end position.",
            "The path can only move in cardinal directions (north, south, east, west).",
            "The path should minimize the total elevation change.",
            "Return a list of coordinates representing the shortest path."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def shortest_terrain_path(matrix: List[List[int]], start_position: Tuple[int, int], end_position: Tuple[int, int]) -> List[Tuple[int, int]]:\n    rows, cols = len(matrix), len(matrix[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = [(start_position, [start_position], 0)]\n    visited = set()\n    \n    while queue:\n        (x, y), path, elevation_change = queue.pop(0)\n        visited.add((x, y))\n        \n        if (x, y) == end_position:\n            return path\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited:\n                new_elevation_change = elevation_change + abs(matrix[nx][ny] - matrix[x][y])\n                queue.append(((nx, ny), path + [(nx, ny)], new_elevation_change))\n    \n    return []"
    },
    {
        "function_name": "ngram_index",
        "file_name": "ngram_index.py",
        "parameters": {
            "`text`": "`str` (The input text to be indexed)",
            "`max_window_size`": "`int` (The maximum window size)"
        },
        "objectives": [
            "Create an N-gram index of a given text.",
            "An N-gram is a contiguous sequence of `n` items from a text or speech.",
            "The index should support query lookups for N-grams of varying sizes up to `max_window_size`.",
            "Return a dictionary mapping N-grams to their frequencies."
        ],
        "import_lines": [
            "from typing import Dict"
        ],
        "function_def": "def ngram_index(text: str, max_window_size: int) -> Dict[str, int]:\n    text = text.lower().split()\n    index = {}\n    \n    for window_size in range(1, max_window_size + 1):\n        for i in range(len(text) - window_size + 1):\n            ngram = ' '.join(text[i:i + window_size])\n            index[ngram] = index.get(ngram, 0) + 1\n    \n    return index"
    },
    {
        "function_name": "reachable_positions",
        "file_name": "grid_traversal.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D list representing a grid)",
            "k": "int (The number of steps allowed to move)"
        },
        "objectives": [
            "Implement a function that returns all possible positions on the grid that are reachable within k steps.",
            "Use a breadth-first search approach.",
            "Consider only moves in the four cardinal directions (up, down, left, right).",
            "Ensure that positions outside the grid boundaries are not considered."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def reachable_positions(grid: List[List[int]], k: int) -> List[tuple]:\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n    queue = deque([(0, 0, 0)])  # (row, col, steps)\n    reachable = []\n    \n    while queue:\n        row, col, steps = queue.popleft()\n        \n        if steps > k:\n            break\n        \n        if (row, col) not in visited:\n            visited.add((row, col))\n            reachable.append((row, col))\n            \n            for dr, dc in directions:\n                r, c = row + dr, col + dc\n                \n                if 0 <= r < rows and 0 <= c < cols:\n                    queue.append((r, c, steps + 1))\n    \n    return reachable"
    },
    {
        "function_name": "min_parentheses_to_add",
        "file_name": "parenthesis_balance.py",
        "parameters": {
            "text": "str (A string containing parentheses)"
        },
        "objectives": [
            "Implement a function that returns the minimum number of parentheses that need to be added to the string to make it balanced.",
            "Use a stack to keep track of the opening parentheses.",
            "Consider cases where the string is already balanced."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_parentheses_to_add(text: str) -> int:\n    stack = []\n    balance = 0\n    \n    for char in text:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                balance += 1\n    \n    balance += len(stack)\n    return balance"
    },
    {
        "function_name": "num_sub_matrices",
        "file_name": "sub_matrix_sums.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list representing a matrix)",
            "target": "int (The target value)"
        },
        "objectives": [
            "Implement a function that returns the number of sub-matrices that sum up to the target value.",
            "Use a hashmap to store the cumulative sums.",
            "Consider cases where the target value is zero."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict"
        ],
        "function_def": "def num_sub_matrices(matrix: List[List[int]], target: int) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    prefix_sum = [[0] * cols for _ in range(rows)]\n    count = 0\n    hashmap = defaultdict(int)\n    hashmap[0] = 1\n    \n    for r in range(rows):\n        for c in range(cols):\n            if r > 0:\n                prefix_sum[r][c] += prefix_sum[r - 1][c]\n            if c > 0:\n                prefix_sum[r][c] += prefix_sum[r][c - 1]\n            if r > 0 and c > 0:\n                prefix_sum[r][c] -= prefix_sum[r - 1][c - 1]\n            prefix_sum[r][c] += matrix[r][c]\n            \n            count += hashmap[prefix_sum[r][c] - target]\n            hashmap[prefix_sum[r][c]] += 1\n    \n    return count"
    },
    {
        "function_name": "subarray_threshold",
        "file_name": "subarray_threshold.py",
        "parameters": {
            "`arr`": "`List[int]` (A list of integers)",
            "`k`": "`int` (The length of the subarrays to consider)",
            "`threshold`": "`int` (The minimum sum of subarray elements required)"
        },
        "objectives": [
            "Find all subarrays of length `k` in `arr` that have a sum greater than or equal to the `threshold`.",
            "Use a sliding window approach to efficiently calculate the sum of subarray elements.",
            "Return a list of tuples, where each tuple contains the start and end indices of a subarray that meets the threshold."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def subarray_threshold(arr: List[int], k: int, threshold: int) -> List[Tuple[int, int]]:\n    window_sum = sum(arr[:k])\n    result = []\n    \n    if window_sum >= threshold:\n        result.append((0, k - 1))\n    \n    for i in range(k, len(arr)):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        \n        if window_sum >= threshold:\n            result.append((i - k + 1, i))\n    \n    return result"
    },
    {
        "function_name": "largest_subset",
        "file_name": "subset_threshold.py",
        "parameters": {
            "`nums`": "`List[int]` (A list of integers)",
            "`threshold`": "`int` (The maximum allowed difference between the largest and smallest element in the subset)"
        },
        "objectives": [
            "Find the largest subset of `nums` that has a difference between the largest and smallest element less than or equal to the `threshold`.",
            "Use a greedy algorithm to select elements that minimize the difference between the largest and smallest element.",
            "Return the subset of `nums` that meets the threshold."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def largest_subset(nums: List[int], threshold: int) -> List[int]:\n    nums.sort()\n    max_len = 0\n    max_subset = []\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[i] <= threshold:\n                if j - i + 1 > max_len:\n                    max_len = j - i + 1\n                    max_subset = nums[i:j + 1]\n    \n    return max_subset"
    },
    {
        "function_name": "min_operations_to_valid_string",
        "file_name": "parenthesis_validator.py",
        "parameters": {
            "s": "str - The input string containing parentheses.",
            "k": "int - The maximum number of operations allowed to make the string valid."
        },
        "objectives": [
            "Implement a function to find the minimum number of operations required to make the string valid by removing parentheses.",
            "Use a stack data structure to keep track of opening parentheses.",
            "Handle cases where the string is already valid or where k is zero."
        ],
        "import_lines": [],
        "function_def": "def min_operations_to_valid_string(s, k):\n    stack = []\n    count = 0\n    \n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    \n    count += len(stack)\n    \n    if count > k:\n        return -1\n    \n    return count"
    },
    {
        "function_name": "zag_algorithm",
        "file_name": "zag_algorithm.py",
        "parameters": {
            "`time_series`": "List[int] (A time series data)",
            "`window_size`": "int (The size of the sliding window)",
            "`stride`": "int (The stride of the sliding window)"
        },
        "objectives": [
            "Implement a sliding window approach to segment the time series data.",
            "Use a zag algorithm to segment the data.",
            "Return a list of segments."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def zag_algorithm(time_series: List[int], window_size: int, stride: int) -> List[List[int]]:\n    segments = []\n    i = 0\n    \n    while i < len(time_series):\n        if i + window_size > len(time_series):\n            segments.append(time_series[i:])\n            break\n        \n        max_diff = 0\n        max_diff_index = -1\n        for j in range(window_size - 1):\n            diff = abs(time_series[i + j] - time_series[i + j + 1])\n            if diff > max_diff:\n                max_diff = diff\n                max_diff_index = j + 1\n        \n        if max_diff_index == -1:\n            segments.append(time_series[i:i + window_size])\n        else:\n            segments.append(time_series[i:i + max_diff_index + 1])\n        \n        i += stride\n    \n    return segments"
    },
    {
        "function_name": "bwt",
        "file_name": "bwt_transform.py",
        "parameters": {
            "`sequence`": "`str` (A DNA sequence)"
        },
        "objectives": [
            "Implement the Burrows-Wheeler transform (BWT) on the input sequence.",
            "Build the suffix array and then transform it into the BWT.",
            "Return the BWT as a string."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def bwt(sequence: str) -> str:\n    # Build suffix array\n    suffixes = [(sequence[i:] + sequence[:i], i) for i in range(len(sequence))]\n    suffixes.sort()\n    \n    # Transform into BWT\n    bwt_sequence = ''\n    for suffix, _ in suffixes:\n        bwt_sequence += suffix[-1]\n    \n    return bwt_sequence"
    },
    {
        "function_name": "max_length_intervals",
        "file_name": "interval_selector.py",
        "parameters": {
            "intervals": "List[List[int]] (A list of intervals where each interval is a list of two integers)",
            "k": "int (The number of intervals to select)"
        },
        "objectives": [
            "Find \"k\" non-overlapping intervals from the input list that have the maximum total length.",
            "Use dynamic programming to store the intermediate results for efficient computation.",
            "Ensure that if an interval does not overlap with the previously selected interval, it is considered for selection.",
            "Return the selected intervals."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def max_length_intervals(intervals: List[List[int]], k: int) -> List[List[int]]:\n    intervals.sort(key=lambda x: x[1])\n    dp = [[None for _ in range(k + 1)] for _ in range(len(intervals) + 1)]\n    result = []\n    \n    for i in range(1, len(intervals) + 1):\n        for j in range(1, min(i + 1, k + 1)):\n            max_length = 0\n            prev_interval = None\n            for prev in range(i):\n                if intervals[prev][1] <= intervals[i - 1][0] and dp[prev][j - 1] is not None:\n                    length = intervals[i - 1][1] - intervals[i - 1][0] + dp[prev][j - 1][0]\n                    if length > max_length:\n                        max_length = length\n                        prev_interval = prev\n            if max_length > 0:\n                dp[i][j] = (max_length, intervals[i - 1])\n                if prev_interval is not None:\n                    dp[i][j] += dp[prev_interval][j - 1][1:]\n    \n    if dp[-1][-1] is not None:\n        result = [dp[-1][-1][1]]\n        i, j = len(intervals), k\n        while j > 1:\n            i = dp[i][j][2]\n            result.append(dp[i][j - 1][1])\n            j -= 1\n        result.reverse()\n    \n    return result"
    },
    {
        "function_name": "rows_with_sum",
        "file_name": "row_sum.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list representing a matrix)",
            "threshold": "int (The threshold for the sum of each row)"
        },
        "objectives": [
            "Find all rows within the matrix that have a sum greater than or equal to the threshold.",
            "Use dynamic programming to store the intermediate results for efficient computation.",
            "Ensure that the order of rows in the output is the same as their occurrence in the input matrix.",
            "Return all such rows."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def rows_with_sum(matrix: List[List[int]], threshold: int) -> List[List[int]]:\n    result = []\n    \n    for row in matrix:\n        current_sum = 0\n        for num in row:\n            current_sum += num\n            if current_sum >= threshold:\n                result.append(row)\n                break\n    \n    return result"
    },
    {
        "function_name": "porter_stemmer",
        "file_name": "text_processing.py",
        "parameters": {
            "sentences": "List[str] (A list of sentences)"
        },
        "objectives": [
            "Implement the Porter Stemmer algorithm to reduce words to their base form.",
            "Handle cases where the input list is empty.",
            "Return a list of stemmed words."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def porter_stemmer(sentences: List[str]) -> List[str]:\n    if not sentences:\n        return []\n    \n    stemmed_words = []\n    for sentence in sentences:\n        words = sentence.split()\n        for word in words:\n            # Remove prefixes\n            if word.endswith('ing'):\n                word = word[:-3]\n            elif word.endswith('ed'):\n                word = word[:-2]\n            \n            # Remove suffixes\n            if word.endswith('ly'):\n                word = word[:-2]\n            \n            stemmed_words.append(word.lower())\n    \n    return stemmed_words"
    },
    {
        "function_name": "can_add_event",
        "file_name": "schedule_validator.py",
        "parameters": {
            "`schedule`": "List[Tuple[int, int]] - A list of tuples representing the start and end times of events.",
            "`new_event`": "Tuple[int, int] - The start and end times of the new event to be added."
        },
        "objectives": [
            "Implement a function to determine whether the new event can be added to the schedule without conflicting with existing events.",
            "Handle cases where the schedule is empty or the new event has invalid times.",
            "Return a boolean indicating whether the new event can be added."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def can_add_event(schedule: List[Tuple[int, int]], new_event: Tuple[int, int]) -> bool:\n    if not schedule or new_event[0] >= new_event[1]:\n        return False\n    \n    for event in schedule:\n        if new_event[0] < event[1] and new_event[1] > event[0]:\n            return False\n    \n    return True"
    },
    {
        "function_name": "sliding_window",
        "file_name": "time_series_analysis.py",
        "parameters": {
            "time_series": "List[float] (A list representing the time series data)",
            "window_size": "int (The window size for segmentation)"
        },
        "objectives": [
            "Implement the Sliding Window algorithm to segment the time series data.",
            "Use a median filter to smooth the data.",
            "Return a list of segmented time series data."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def sliding_window(time_series: List[float], window_size: int) -> List[List[float]]:\n    # Smooth data using median filter\n    smoothed_data = []\n    for i in range(len(time_series)):\n        window = time_series[max(0, i - window_size // 2): min(len(time_series), i + window_size // 2 + 1)]\n        smoothed_data.append(sorted(window)[len(window) // 2])\n    \n    # Segment time series data\n    segmented_data = []\n    for i in range(0, len(smoothed_data), window_size):\n        segmented_data.append(smoothed_data[i: min(len(smoothed_data), i + window_size)])\n    \n    return segmented_data"
    },
    {
        "function_name": "calculate_relevance",
        "file_name": "text_analyzer.py",
        "parameters": {
            "text": "str",
            "keywords": "List[str]",
            "threshold": "float"
        },
        "objectives": [
            "Implement a function to determine the relevance of a given text based on the presence of specific keywords.",
            "Use the TF-IDF (Term Frequency-Inverse Document Frequency) algorithm to calculate the importance of each keyword in the text.",
            "Compare the calculated importance with a given threshold to determine the relevance of the text."
        ],
        "import_lines": [
            "from sklearn.feature_extraction.text import TfidfVectorizer",
            "from typing import List"
        ],
        "function_def": "def calculate_relevance(text: str, keywords: List[str], threshold: float) -> bool:\n    vectorizer = TfidfVectorizer()\n    tfidf = vectorizer.fit_transform([text])\n    keyword_tfidf = vectorizer.transform(keywords)\n    \n    importance = tfidf.dot(keyword_tfidf.T).toarray()[0].sum()\n    \n    return importance >= threshold"
    },
    {
        "function_name": "find_k_closest_numbers",
        "file_name": "number_finder.py",
        "parameters": {
            "nums": "List[int]",
            "target": "int",
            "k": "int"
        },
        "objectives": [
            "Implement a function to find the k closest numbers to a target value in a given list of numbers.",
            "Use a priority queue to store the k closest numbers and maintain the queue size.",
            "Ensure that the returned numbers are in the correct order (i.e., the closest number first)."
        ],
        "import_lines": [
            "from typing import List",
            "import heapq"
        ],
        "function_def": "def find_k_closest_numbers(nums: List[int], target: int, k: int) -> List[int]:\n    queue = []\n    for num in nums:\n        diff = abs(num - target)\n        if len(queue) < k:\n            heapq.heappush(queue, (-diff, num))\n        else:\n            heapq.heappushpop(queue, (-diff, num))\n    \n    return [x[1] for x in sorted(queue)]"
    },
    {
        "function_name": "tf_idf",
        "file_name": "text_processing.py",
        "parameters": {
            "text": "str (The input text to be processed)",
            "stopwords": "List[str] (A list of stopwords to ignore)"
        },
        "objectives": [
            "Implement a function to extract keywords from the text using the TF-IDF algorithm.",
            "Tokenize the text into words and remove stopwords.",
            "Calculate the term frequency (TF) and inverse document frequency (IDF) for each word.",
            "Return a list of keywords with their corresponding TF-IDF scores."
        ],
        "import_lines": [
            "from typing import List",
            "import re",
            "from collections import Counter",
            "import math"
        ],
        "function_def": "def tf_idf(text: str, stopwords: List[str]) -> List[tuple]:\n    # Tokenize the text into words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    \n    # Remove stopwords\n    words = [word for word in words if word not in stopwords]\n    \n    # Calculate term frequency (TF)\n    tf = Counter(words)\n    tf = {word: count / len(words) for word, count in tf.items()}\n    \n    # Calculate inverse document frequency (IDF)\n    idf = {word: math.log(1 + 1 / (1 + tf[word])) for word in tf}\n    \n    # Calculate TF-IDF scores\n    tf_idf_scores = {word: tf[word] * idf[word] for word in tf}\n    \n    # Return the top keywords with their TF-IDF scores\n    return sorted(tf_idf_scores.items(), key=lambda x: x[1], reverse=True)[:10]"
    },
    {
        "function_name": "find_neighboring_points",
        "file_name": "point_cloud.py",
        "parameters": {
            "points": "List[Tuple[float, float]] (A list of 2D points)",
            "radius": "float (The radius of the circle)"
        },
        "objectives": [
            "Find the points within a specified radius from each point in the list.",
            "For each point, return a set of indices of points that are within the specified radius.",
            "Ignore the point itself when calculating neighboring points.",
            "Handle floating-point precision issues by using a tolerance value (e.g., 1e-6)."
        ],
        "import_lines": [
            "from typing import List, Tuple, Set",
            "import math"
        ],
        "function_def": "def find_neighboring_points(points: List[Tuple[float, float]], radius: float) -> List[Set[int]]:\n    neighboring_points = []\n    \n    for i in range(len(points)):\n        neighbors = set()\n        for j in range(len(points)):\n            if i == j:\n                continue\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            if distance <= radius + 1e-6:\n                neighbors.add(j)\n        neighboring_points.append(neighbors)\n    \n    return neighboring_points"
    },
    {
        "function_name": "find_smallest_element",
        "file_name": "rotated_array.py",
        "parameters": {
            "array": "List[int] (A sorted array of integers)",
            "rotations": "int (The number of times the array has been rotated)"
        },
        "objectives": [
            "Determine the original position of the smallest element in the rotated array.",
            "Use a modified binary search algorithm to find the pivot element.",
            "Return the index of the smallest element in the original array."
        ],
        "import_lines": [],
        "function_def": "def find_smallest_element(array, rotations):\n    low, high = 0, len(array) - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        if array[mid] > array[high]:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low"
    },
    {
        "function_name": "most_frequent_substring",
        "file_name": "sequence_analyzer.py",
        "parameters": {
            "sequence": "str (A string of characters)",
            "k": "int (The length of the substrings to consider)"
        },
        "objectives": [
            "Implement a function to find the most frequent substring of length k in a sequence.",
            "Ensure that the function uses a sliding window approach to efficiently consider all substrings.",
            "Handle cases where the sequence is empty or k is larger than the sequence length.",
            "Return the most frequent substring as a string."
        ],
        "import_lines": [
            "from collections import defaultdict"
        ],
        "function_def": "def most_frequent_substring(sequence, k):\n    if not sequence or k > len(sequence):\n        return \"\"\n    frequency_map = defaultdict(int)\n    max_frequency = 0\n    most_frequent_substring = \"\"\n    for i in range(len(sequence) - k + 1):\n        substring = sequence[i:i + k]\n        frequency_map[substring] += 1\n        if frequency_map[substring] > max_frequency:\n            max_frequency = frequency_map[substring]\n            most_frequent_substring = substring\n    return most_frequent_substring"
    },
    {
        "function_name": "simulate_tournaments",
        "file_name": "tournament_simulator.py",
        "parameters": {
            "tournaments": "List[List[int]] (A list of tournaments where each tournament is a list of teams)",
            "teams": "List[str] (A list of team names)",
            "num_matches": "int (The number of matches to simulate)"
        },
        "objectives": [
            "Implement a function to simulate a series of matches between teams in a set of tournaments.",
            "Ensure that the function uses a round-robin approach to schedule the matches.",
            "Handle cases where the number of teams is not a power of 2.",
            "Return the simulated results as a list of match outcomes."
        ],
        "import_lines": [
            "import random"
        ],
        "function_def": "def simulate_tournaments(tournaments, teams, num_matches):\n    simulated_results = []\n    for tournament in tournaments:\n        for i in range(num_matches):\n            team1 = random.choice(tournament)\n            team2 = random.choice(tournament)\n            while team1 == team2:\n                team2 = random.choice(tournament)\n            simulated_results.append((team1, team2, random.choice([0, 1])))\n    return simulated_results"
    },
    {
        "function_name": "textrank_summarization",
        "file_name": "natural_language_processing.py",
        "parameters": {
            "text": "str - The input text to be summarized.",
            "n": "int - The number of sentences to include in the summary."
        },
        "objectives": [
            "Implement a TextRank-based algorithm to summarize the text.",
            "Calculate the importance of each sentence based on its similarity to other sentences.",
            "Ensure that the top n most important sentences are included in the summary."
        ],
        "import_lines": [
            "from typing import List",
            "import re",
            "import collections",
            "import numpy as np"
        ],
        "function_def": "def textrank_summarization(text: str, n: int) -> List[str]:\n    # Preprocess the text\n    sentences = re.split(r'[.!?]', text)\n    sentences = [sentence.strip() for sentence in sentences if sentence]\n    \n    # Calculate sentence similarities\n    similarities = np.zeros((len(sentences), len(sentences)))\n    for i in range(len(sentences)):\n        for j in range(i + 1, len(sentences)):\n            similarity = len(set(sentences[i].split()) & set(sentences[j].split())) / len(set(sentences[i].split()) | set(sentences[j].split()))\n            similarities[i, j] = similarities[j, i] = similarity\n    \n    # Calculate sentence importance\n    importance = np.array([sum(similarities[i]) for i in range(len(sentences))])\n    importance /= importance.sum()\n    \n    # Rank sentences\n    ranked_sentences = sorted(zip(sentences, importance), key=lambda x: x[1], reverse=True)\n    \n    # Select top n sentences\n    summary = [sentence for sentence, _ in ranked_sentences[:n]]\n    \n    return summary"
    },
    {
        "function_name": "partition_list",
        "file_name": "list_partitioner.py",
        "parameters": {
            "numbers": "List[int] - A list of integers to be partitioned.",
            "partition_size": "int - The size of each partition."
        },
        "objectives": [
            "Partition the list of numbers into sublists of size partition_size.",
            "If the length of the list is not divisible by partition_size, the last partition should contain the remaining elements.",
            "Return the partitioned list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def partition_list(numbers: List[int], partition_size: int) -> List[List[int]]:\n    return [numbers[i:i+partition_size] for i in range(0, len(numbers), partition_size)]"
    },
    {
        "function_name": "search_trees",
        "file_name": "tree_search.py",
        "parameters": {
            "trees": "List[Dict[str, Any]] - A list of dictionaries representing trees, where each node has a 'value' key and a 'children' key.",
            "target_value": "Any - The value to search for in the trees."
        },
        "objectives": [
            "Implement a function to search for the target value in each tree.",
            "If the target value is found in a tree, return the path from the root node to the node containing the target value.",
            "If the target value is not found in any tree, return an empty list."
        ],
        "import_lines": [
            "from typing import Dict, List, Any"
        ],
        "function_def": "def search_trees(trees: List[Dict[str, Any]], target_value: Any) -> List[List[Any]]:\n    paths = []\n    for tree in trees:\n        queue = [(tree, [tree['value']])]\n        while queue:\n            node, path = queue.pop(0)\n            if node['value'] == target_value:\n                paths.append(path)\n                break\n            for child in node['children']:\n                new_path = list(path)\n                new_path.append(child['value'])\n                queue.append((child, new_path))\n    return paths"
    },
    {
        "function_name": "sharp_turn_detector",
        "file_name": "trajectory_analyzer.py",
        "parameters": {
            "`trajectory`": "List[List[float]] (A 2D trajectory of a moving object)",
            "`threshold`": "float (A threshold for detecting sharp turns)",
            "`window_size`": "int (The size of the sliding window for calculating velocity)"
        },
        "objectives": [
            "Calculate the velocity of the moving object at each point using the sliding window approach.",
            "Detect sharp turns by analyzing the angle between consecutive velocity vectors.",
            "Return a list of points where sharp turns are detected."
        ],
        "import_lines": [
            "import math"
        ],
        "function_def": "def sharp_turn_detector(trajectory, threshold, window_size):\n    sharp_turns = []\n    velocities = []\n    \n    for i in range(len(trajectory) - window_size):\n        velocity_x = trajectory[i + window_size][0] - trajectory[i][0]\n        velocity_y = trajectory[i + window_size][1] - trajectory[i][1]\n        velocity = math.sqrt(velocity_x**2 + velocity_y**2)\n        velocities.append((velocity_x, velocity_y))\n    \n    for i in range(len(velocities) - 1):\n        dot_product = velocities[i][0]*velocities[i+1][0] + velocities[i][1]*velocities[i+1][1]\n        magnitude_product = math.sqrt(velocities[i][0]**2 + velocities[i][1]**2)*math.sqrt(velocities[i+1][0]**2 + velocities[i+1][1]**2)\n        angle = math.acos(dot_product/magnitude_product)\n        \n        if angle > threshold:\n            sharp_turns.append(trajectory[i + window_size])\n    \n    return sharp_turns"
    },
    {
        "function_name": "cluster_merger",
        "file_name": "cluster_analyzer.py",
        "parameters": {
            "`clusters`": "List[List[float]] (A list of clusters represented as lists of floating-point numbers)",
            "`threshold`": "float (A threshold for merging clusters)",
            "`distance_metric`": "str (The distance metric to use for calculating distances between clusters)"
        },
        "objectives": [
            "Calculate the distances between clusters using the specified distance metric.",
            "Merge clusters that are closer than the specified threshold.",
            "Return the merged clusters."
        ],
        "import_lines": [
            "import math"
        ],
        "function_def": "def cluster_merger(clusters, threshold, distance_metric):\n    merged_clusters = clusters[:]\n    \n    for i in range(len(merged_clusters)):\n        for j in range(i+1, len(merged_clusters)):\n            if distance_metric == \"euclidean\":\n                distance = math.sqrt(sum((a-b)**2 for a, b in zip(merged_clusters[i], merged_clusters[j])))\n            elif distance_metric == \"manhattan\":\n                distance = sum(abs(a-b) for a, b in zip(merged_clusters[i], merged_clusters[j]))\n            elif distance_metric == \"cosine\":\n                dot_product = sum(a*b for a, b in zip(merged_clusters[i], merged_clusters[j]))\n                magnitude_product = math.sqrt(sum(a**2 for a in merged_clusters[i]))*math.sqrt(sum(a**2 for a in merged_clusters[j]))\n                distance = 1 - dot_product/magnitude_product\n            \n            if distance < threshold:\n                merged_clusters[i] = [(a+b)/2 for a, b in zip(merged_clusters[i], merged_clusters[j])]\n                del merged_clusters[j]\n                break\n    \n    return merged_clusters"
    },
    {
        "function_name": "huffman_coding",
        "file_name": "data_compression.py",
        "parameters": {
            "text": "str (A string of text to be compressed)"
        },
        "objectives": [
            "Implement the Huffman coding algorithm to compress the text.",
            "Use a priority queue to efficiently build the Huffman tree.",
            "Handle cases where the text is empty."
        ],
        "import_lines": [
            "import heapq"
        ],
        "function_def": "def huffman_coding(text: str) -> dict:\n    if not text:\n        return {}\n    \n    frequency = {}\n    for char in text:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n            \n    priority_queue = [[weight, [symbol, \"\"]] for symbol, weight in frequency.items()]\n    heapq.heapify(priority_queue)\n    \n    while len(priority_queue) > 1:\n        lo = heapq.heappop(priority_queue)\n        hi = heapq.heappop(priority_queue)\n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n        heapq.heappush(priority_queue, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n                \n    return sorted(heapq.heappop(priority_queue)[1:], key=lambda p: (len(p[-1]), p))"
    },
    {
        "function_name": "array_rotator",
        "file_name": "array_rotator.py",
        "parameters": {
            "array": "List[int] - The input array to be rotated.",
            "rotations": "int - The number of rotations to perform.",
            "mode": "str - The direction of rotation, either 'left' or 'right'."
        },
        "objectives": [
            "Rotate the input array by the specified number of positions.",
            "Perform the rotation in the specified direction.",
            "Return the rotated array."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def array_rotator(array: List[int], rotations: int, mode: str) -> List[int]:\n    if mode == 'left':\n        rotations = -rotations\n    return array[rotations:] + array[:rotations]"
    },
    {
        "function_name": "quicksort",
        "file_name": "sorting.py",
        "parameters": {
            "unsorted_list": "List[int] - An unsorted list of integers.",
            "pivot_type": "str - The type of pivot to use (either \"first\", \"last\", or \"median\")."
        },
        "objectives": [
            "Implement a function to perform the quicksort algorithm on the given unsorted list using the specified pivot.",
            "Ensure the function handles cases where the list contains duplicate elements.",
            "Return the sorted list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def quicksort(unsorted_list: List[int], pivot_type: str) -> List[int]:\n    if len(unsorted_list) <= 1:\n        return unsorted_list\n    \n    if pivot_type == \"first\":\n        pivot = unsorted_list[0]\n    elif pivot_type == \"last\":\n        pivot = unsorted_list[-1]\n    elif pivot_type == \"median\":\n        mid = len(unsorted_list) // 2\n        pivot = sorted([unsorted_list[0], unsorted_list[mid], unsorted_list[-1]])[1]\n    else:\n        raise ValueError(\"Invalid pivot type\")\n    \n    left = [x for x in unsorted_list[1:] if x <= pivot]\n    right = [x for x in unsorted_list[1:] if x > pivot]\n    \n    return quicksort(left, pivot_type) + [pivot] + quicksort(right, pivot_type)"
    },
    {
        "function_name": "robust_kth_smallest",
        "file_name": "outlier_resistant.py",
        "parameters": {
            "array": "List[int]",
            "k": "int",
            "sigma": "float"
        },
        "objectives": [
            "Implement a robust solution to calculate the kth smallest element in an unsorted array that is robust to outliers in the data.",
            "Handle cases where the dataset contains outliers or noisy data using the median absolute deviation (MAD) method.",
            "Use a multi-step approach involving data normalization and partition-based selection.",
            "Return the kth smallest element."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def robust_kth_smallest(array: List[int], k: int, sigma: float) -> int:\n    array = np.array(array)\n    median = np.median(array)\n    dev = np.median(np.abs(array - median))\n    normalized_array = (array - median) / (sigma * dev)\n    sorted_indices = np.argsort(normalized_array)\n    return array[sorted_indices[k - 1]]"
    },
    {
        "function_name": "matrix_segmentation",
        "file_name": "matrix_segmentor.py",
        "parameters": {
            "matrix": "List[List[int]]",
            "threshold": "int"
        },
        "objectives": [
            "Design a solution to segment a matrix into sub-matrices based on the given threshold.",
            "Identify clusters of elements with similar values using DBSCAN (Density-based spatial clustering of applications with noise) algorithm.",
            "Handle cases where the matrix contains a large number of elements.",
            "Return a list of sub-matrices."
        ],
        "import_lines": [
            "from typing import List",
            "from sklearn.cluster import DBSCAN",
            "import numpy as np"
        ],
        "function_def": "def matrix_segmentation(matrix: List[List[int]], threshold: int) -> List[List[List[int]]]:\n    X = np.array(matrix).reshape(-1, 1)\n    clustering = DBSCAN(eps=threshold, min_samples=2).fit(X)\n    labels = clustering.labels_\n    unique_labels = set(labels)\n    sub_matrices = []\n    for label in unique_labels:\n        sub_matrix = []\n        for i, x in enumerate(labels):\n            if x == label:\n                sub_matrix.append(matrix[i // len(matrix[0])][i % len(matrix[0])])\n        sub_matrices.append(sub_matrix)\n    return sub_matrices"
    },
    {
        "function_name": "astar_shortest_path",
        "file_name": "graph_searcher.py",
        "parameters": {
            "edges": "List[List[int]]",
            "source": "int",
            "target": "int"
        },
        "objectives": [
            "Implement a solution to find the shortest path in a weighted graph using A\\* search algorithm.",
            "Handle cases where the graph contains negative edge weights or the source/target nodes are not reachable.",
            "Return the shortest path and its cost."
        ],
        "import_lines": [
            "from typing import List",
            "from heapq import heappop, heappush"
        ],
        "function_def": "def astar_shortest_path(edges: List[List[int]], source: int, target: int) -> List[int]:\n    graph = {}\n    for u, v, cost in edges:\n        if u not in graph:\n            graph[u] = {}\n        graph[u][v] = cost\n    queue = [(0, source, [])]\n    visited = set()\n    while queue:\n        cost, node, path = heappop(queue)\n        if node == target:\n            return path + [node], cost\n        if node in visited:\n            continue\n        visited.add(node)\n        for neighbor, neighbor_cost in graph.get(node, {}).items():\n            if neighbor not in visited:\n                heappush(queue, (cost + neighbor_cost, neighbor, path + [node]))\n    return None, float('inf')"
    },
    {
        "function_name": "check_anagram",
        "file_name": "anagram_checker.py",
        "parameters": {
            "str1": "str (The first string for anagram checking)",
            "str2": "str (The second string for anagram checking)"
        },
        "objectives": [
            "Implement a function to check if two input strings are anagrams of each other.",
            "Use the sorting technique to compare the characters of both strings.",
            "If the sorted characters of both strings are equal, return True; otherwise, return False."
        ],
        "import_lines": [],
        "function_def": "def check_anagram(str1: str, str2: str) -> bool:\n    return sorted(str1) == sorted(str2)"
    },
    {
        "function_name": "smith_waterman_alignment",
        "file_name": "smith_waterman.py",
        "parameters": {
            "`sequence`": "str (A DNA sequence)",
            "`pattern`": "str (A pattern to search for in the sequence)",
            "`mismatch_tolerance`": "int (The maximum number of mismatches allowed)"
        },
        "objectives": [
            "Implement the Smith-Waterman algorithm to find the best local alignment of the pattern within the sequence.",
            "The function should return the aligned pattern and the corresponding sequence substring.",
            "The function should use a scoring matrix to score the alignments."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from numpy import zeros"
        ],
        "function_def": "def smith_waterman_alignment(sequence: str, pattern: str, mismatch_tolerance: int) -> List[str]:\n    scoring_matrix = zeros((len(pattern) + 1, len(sequence) + 1), dtype=int)\n    for i in range(1, len(pattern) + 1):\n        for j in range(1, len(sequence) + 1):\n            match = scoring_matrix[i - 1, j - 1] + (1 if pattern[i - 1] == sequence[j - 1] else -1)\n            delete = scoring_matrix[i - 1, j] - 1\n            insert = scoring_matrix[i, j - 1] - 1\n            scoring_matrix[i, j] = max(0, match, delete, insert)\n    max_score = 0\n    max_position = (0, 0)\n    for i in range(len(pattern) + 1):\n        for j in range(len(sequence) + 1):\n            if scoring_matrix[i, j] > max_score:\n                max_score = scoring_matrix[i, j]\n                max_position = (i, j)\n    aligned_pattern = \"\"\n    aligned_sequence = \"\"\n    i, j = max_position\n    while scoring_matrix[i, j] > 0:\n        if i > 0 and j > 0 and pattern[i - 1] == sequence[j - 1]:\n            aligned_pattern = pattern[i - 1] + aligned_pattern\n            aligned_sequence = sequence[j - 1] + aligned_sequence\n            i -= 1\n            j -= 1\n        elif i > 0 and scoring_matrix[i, j] == scoring_matrix[i - 1, j] - 1:\n            aligned_pattern = pattern[i - 1] + aligned_pattern\n            aligned_sequence = \"-\" + aligned_sequence\n            i -= 1\n        elif j > 0 and scoring_matrix[i, j] == scoring_matrix[i, j - 1] - 1:\n            aligned_pattern = \"-\" + aligned_pattern\n            aligned_sequence = sequence[j - 1] + aligned_sequence\n            j -= 1\n    return aligned_pattern, aligned_sequence"
    },
    {
        "function_name": "max_histogram_area",
        "file_name": "histogram.py",
        "parameters": {
            "array": "List[int] (A list of integers representing the heights of a histogram)",
            "k": "int (The number of rectangles to remove)"
        },
        "objectives": [
            "Implement a stack-based algorithm to find the maximum area of a histogram after removing k rectangles.",
            "Use a stack to keep track of the indices of the histogram bars.",
            "Handle cases where k is zero or where the histogram has less than k + 1 bars.",
            "Return the maximum area of the histogram after removing k rectangles."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_histogram_area(array, k):\n    stack = []\n    n = len(array)\n    max_area = 0\n    \n    for i in range(n):\n        while stack and array[stack[-1]] >= array[i]:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, array[top] * width)\n        stack.append(i)\n    \n    while stack and k > 0:\n        top = stack.pop()\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, array[top] * width)\n        k -= 1\n    \n    while stack:\n        top = stack.pop()\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, array[top] * width)\n    \n    return max_area"
    },
    {
        "function_name": "replace_largest_values",
        "file_name": "grid_modifier.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix representing a grid of values)",
            "k": "int (The number of values to replace)"
        },
        "objectives": [
            "Implement a priority queue-based algorithm to find the k largest values in a grid and replace them with zeros.",
            "Use a min heap to keep track of the k largest values.",
            "Handle cases where k is zero or where the grid is empty.",
            "Return the modified grid."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List"
        ],
        "function_def": "def replace_largest_values(matrix, k):\n    if not matrix:\n        return matrix\n    \n    pq = []\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if len(pq) < k:\n                heapq.heappush(pq, (matrix[i][j], i, j))\n            else:\n                heapq.heappushpop(pq, (matrix[i][j], i, j))\n    \n    max_values = []\n    while pq:\n        value, i, j = heapq.heappop(pq)\n        max_values.append((value, i, j))\n    \n    for _, i, j in max_values:\n        matrix[i][j] = 0\n    \n    return matrix"
    },
    {
        "function_name": "precision_rounding",
        "file_name": "precision_rounding.py",
        "parameters": {
            "numbers": "List[float] (A list of floating-point numbers)",
            "precision": "int (The precision for rounding the numbers)"
        },
        "objectives": [
            "Implement a function to round the given list of numbers to a specified precision.",
            "Use a greedy approach to minimize the cumulative error.",
            "Return the list of rounded numbers."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def precision_rounding(numbers: List[float], precision: int) -> List[float]:\n    cumulative_error = 0\n    rounded_numbers = []\n    \n    for num in numbers:\n        rounded_num = round(num + cumulative_error, precision)\n        cumulative_error += (num - rounded_num)\n        rounded_numbers.append(rounded_num)\n    \n    return rounded_numbers"
    },
    {
        "function_name": "best_clique",
        "file_name": "clique_finder.py",
        "parameters": {
            "`adj_matrix`": "List[List[int]] - An adjacency matrix representing a graph.",
            "`k`": "int - The number of nodes to find in the best clique."
        },
        "objectives": [
            "Implement a function to find the best clique in the graph, which is a subgraph with k nodes where every node is connected to every other node.",
            "Use the concept of graph density to optimize the search for the best clique.",
            "Handle cases where the graph is not fully connected or where k is larger than the number of nodes in the graph."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def best_clique(adj_matrix: List[List[int]], k: int) -> List[int]:\n    if k > len(adj_matrix):\n        return []\n    \n    best_clique_nodes = []\n    max_density = 0\n    \n    for i in range(len(adj_matrix)):\n        clique_nodes = [i]\n        visited = [False] * len(adj_matrix)\n        visited[i] = True\n        \n        while len(clique_nodes) < k:\n            max_neighbors = -1\n            next_node = None\n            for j in range(len(adj_matrix)):\n                if not visited[j] and sum(adj_matrix[j][n] for n in clique_nodes) > max_neighbors:\n                    max_neighbors = sum(adj_matrix[j][n] for n in clique_nodes)\n                    next_node = j\n            if next_node is None:\n                break\n            clique_nodes.append(next_node)\n            visited[next_node] = True\n        \n        if len(clique_nodes) == k:\n            density = sum(adj_matrix[i][j] for i in clique_nodes for j in clique_nodes if i < j) / (k * (k - 1) / 2)\n            if density > max_density:\n                max_density = density\n                best_clique_nodes = clique_nodes\n    \n    return best_clique_nodes"
    },
    {
        "function_name": "quadratic_roots",
        "file_name": "quadratic_calculator.py",
        "parameters": {
            "`numbers`": "List[int] - A list of integers to be used as discriminants in the quadratic formula.",
            "`precision`": "int - The maximum decimal places for the roots."
        },
        "objectives": [
            "Implement a function to calculate the roots of a quadratic equation for a list of discriminants.",
            "Use the concept of quadratic formula to calculate the roots.",
            "Handle cases where the discriminant is negative, resulting in complex roots."
        ],
        "import_lines": [
            "from typing import List",
            "import math"
        ],
        "function_def": "def quadratic_roots(numbers: List[int], precision: int) -> List[tuple]:\n    roots = []\n    for num in numbers:\n        if num < 0:\n            real_part = 0\n            imaginary_part = math.sqrt(-num)\n            roots.append((round(real_part, precision), round(imaginary_part, precision)))\n        else:\n            root = math.sqrt(num)\n            roots.append((round(root, precision), 0))\n    return roots"
    },
    {
        "function_name": "smooth_pixel_art",
        "file_name": "pixel_art_smooth.py",
        "parameters": {
            "`trace_list`": "List[List[int]] - A list of 2D points representing a pixel art image.",
            "`k`": "int - The number of points to use for interpolation."
        },
        "objectives": [
            "Implement a function to smooth a pixel art image using linear interpolation.",
            "Use the concept of interpolation to find intermediate points.",
            "Handle cases where the input image is empty or where k is larger than the number of points in the image."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def smooth_pixel_art(trace_list: List[List[int]], k: int) -> List[List[int]]:\n    if k > len(trace_list):\n        return trace_list\n    \n    smoothed_trace_list = [trace_list[0]]\n    \n    for i in range(len(trace_list) - 1):\n        diff = [(trace_list[i+1][0] - trace_list[i][0]) / k, (trace_list[i+1][1] - trace_list[i][1]) / k]\n        for j in range(1, k + 1):\n            point = [trace_list[i][0] + j * diff[0], trace_list[i][1] + j * diff[1]]\n            smoothed_trace_list.append(point)\n    \n    if k == 1:\n        smoothed_trace_list.pop()\n    \n    return smoothed_trace_list"
    },
    {
        "function_name": "password_validator",
        "file_name": "password_validator.py",
        "parameters": {
            "`password`": "str - The password to be checked.",
            "`rules`": "List[str] - A list of rules that the password must follow."
        },
        "objectives": [
            "Implement a function to check a password against a list of predefined rules.",
            "Use the concept of regular expressions to parse and validate the password.",
            "Handle cases where the password or rules are empty."
        ],
        "import_lines": [
            "from typing import List",
            "import re"
        ],
        "function_def": "def password_validator(password: str, rules: List[str]) -> bool:\n    if not password or not rules:\n        return False\n    \n    for rule in rules:\n        if rule == \"length\":\n            if len(password) < 8:\n                return False\n        elif rule == \"uppercase\":\n            if not re.search(\"[A-Z]\", password):\n                return False\n        elif rule == \"lowercase\":\n            if not re.search(\"[a-z]\", password):\n                return False\n        elif rule == \"numbers\":\n            if not re.search(\"[0-9]\", password):\n                return False\n        elif rule == \"special\":\n            if not re.search(\"[!@#$%^&*()_+=-{};:'<>,./?]\", password):\n                return False\n    \n    return True"
    },
    {
        "function_name": "text_normalizer",
        "file_name": "text_normalizer.py",
        "parameters": {
            "`text`": "str - The text to be normalized.",
            "`chars`": "str - The set of characters to normalize."
        },
        "objectives": [
            "Implement a function to normalize a string by converting it to lowercase and removing unwanted characters.",
            "Use the concept of character translation to convert characters.",
            "Handle cases where the input text or characters to normalize are empty."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def text_normalizer(text: str, chars: str) -> str:\n    if not text or not chars:\n        return \"\"\n    \n    trans_table = str.maketrans(chars, len(chars) * ' ')\n    lower_text = text.lower()\n    \n    return lower_text.translate(trans_table).replace(\" \", \"\")"
    },
    {
        "function_name": "min_time_slots",
        "file_name": "scheduler.py",
        "parameters": {
            "schedules": "List[List[int]] - A list of schedules represented as lists of integers.",
            "num_slots": "int - The number of time slots."
        },
        "objectives": [
            "Implement a function to find the minimum number of time slots required to accommodate all schedules.",
            "Use a greedy approach to assign schedules to time slots.",
            "Return the minimum number of time slots."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_time_slots(schedules: List[List[int]], num_slots: int) -> int:\n    end_times = [0] * num_slots\n    \n    for schedule in schedules:\n        assigned = False\n        \n        for i in range(num_slots):\n            if end_times[i] <= schedule[0]:\n                end_times[i] = schedule[1]\n                assigned = True\n                break\n        \n        if not assigned:\n            min_end_time = min(end_times)\n            end_times[end_times.index(min_end_time)] = schedule[1]\n    \n    return len(set(end_times))"
    },
    {
        "function_name": "min_arrays_sum",
        "file_name": "array_analyzer.py",
        "parameters": {
            "arrays": "List[List[int]] - A list of integer arrays.",
            "target_sum": "int - The target sum to find."
        },
        "objectives": [
            "Implement a function to find the minimum number of arrays that sum up to the target sum.",
            "Use dynamic programming to efficiently count the number of arrays.",
            "Return the minimum number of arrays."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_arrays_sum(arrays: List[List[int]], target_sum: int) -> int:\n    dp = [float('inf')] * (target_sum + 1)\n    dp[0] = 0\n    \n    for array in arrays:\n        array_sum = sum(array)\n        \n        for i in range(target_sum, array_sum - 1, -1):\n            dp[i] = min(dp[i], dp[i - array_sum] + 1)\n    \n    return dp[target_sum] if dp[target_sum] != float('inf') else -1"
    },
    {
        "function_name": "find_unique_submatrices",
        "file_name": "matrix_search.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "target_sum": "int (A target sum to compare the submatrices against)"
        },
        "objectives": [
            "Implement a function to find all unique submatrices in the given matrix whose sum is equal to the 'target_sum'.",
            "Use a bottom-up dynamic programming approach to efficiently calculate the sum of submatrices.",
            "Return a list of tuples representing the coordinates of the top-left and bottom-right corners of the submatrices."
        ],
        "import_lines": [],
        "function_def": "def find_unique_submatrices(matrix, target_sum):\n    if not matrix or not matrix[0]:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + matrix[i - 1][j - 1]\n    \n    result = []\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for last_col in range(j, cols + 1):\n                    submatrix_sum = prefix_sum[k][last_col] - prefix_sum[k][j - 1] - prefix_sum[i - 1][last_col] + prefix_sum[i - 1][j - 1]\n                    if submatrix_sum == target_sum:\n                        result.append(((i - 1, j - 1), (k - 1, last_col - 1)))\n    \n    return result"
    },
    {
        "function_name": "find_files_by_extension",
        "file_name": "file_search.py",
        "parameters": {
            "all_file_paths": "List[str] (A list of file paths)",
            "max_depth": "int (The maximum depth to traverse)"
        },
        "objectives": [
            "Implement a function to find all files with a specific extension (e.g., '.txt') within a specified directory and its subdirectories, up to a certain depth.",
            "Use a recursive depth-first search approach to traverse the directory tree.",
            "Return a list of file paths that match the specified extension."
        ],
        "import_lines": [
            "import os"
        ],
        "function_def": "def find_files_by_extension(all_file_paths, max_depth):\n    if max_depth < 0:\n        return []\n    \n    result = []\n    \n    for file_path in all_file_paths:\n        if os.path.isfile(file_path) and file_path.endswith('.txt'):\n            result.append(file_path)\n        elif os.path.isdir(file_path):\n            files = os.listdir(file_path)\n            for file in files:\n                sub_file_path = os.path.join(file_path, file)\n                result.extend(find_files_by_extension([sub_file_path], max_depth - 1))\n    \n    return result"
    },
    {
        "function_name": "identify_fraudulent_transactions",
        "file_name": "fraud_detection.py",
        "parameters": {
            "transactions": "List[List[int]] (A list of transactions with their timestamps and amounts)",
            "max_time_diff": "int (The maximum time difference between transactions)",
            "min_amount": "int (The minimum amount for a transaction)"
        },
        "objectives": [
            "Implement a function to identify potentially fraudulent transactions based on their timestamps and amounts.",
            "Use a sliding window approach to find transactions that occur within a certain time frame and exceed a certain amount.",
            "Return a list of transactions that are potentially fraudulent."
        ],
        "import_lines": [],
        "function_def": "def identify_fraudulent_transactions(transactions, max_time_diff, min_amount):\n    transactions.sort(key=lambda x: x[0])\n    result = []\n    window = []\n    \n    for transaction in transactions:\n        timestamp, amount = transaction\n        while window and timestamp - window[0][0] > max_time_diff:\n            window.pop(0)\n        window.append(transaction)\n        if amount >= min_amount and len(window) > 1:\n            result.append(transaction)\n    \n    return result"
    },
    {
        "function_name": "maze_solver",
        "file_name": "maze_solver.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid representing a maze",
            "start": "Tuple[int, int] - The starting position of the maze",
            "end": "Tuple[int, int] - The ending position of the maze"
        },
        "objectives": [
            "Implement a Depth-First Search algorithm to find a path between the start and end positions in the maze.",
            "Avoid revisiting positions by keeping track of the visited positions using a set.",
            "Return the shortest path as a list of coordinates if a path exists; otherwise, return an empty list."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def maze_solver(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n    stack = [(start, [start])]\n    \n    while stack:\n        (x, y), path = stack.pop()\n        if (x, y) == end:\n            return path\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and\n                grid[nx][ny] == 0 and (nx, ny) not in visited):\n                stack.append(((nx, ny), path + [(nx, ny)]))\n    \n    return []"
    },
    {
        "function_name": "median_absolute_difference",
        "file_name": "absolute_difference.py",
        "parameters": {
            "numbers": "List[int] - A list of numbers to find the median of the absolute differences",
            "size": "int - The size of the subarray"
        },
        "objectives": [
            "Implement a function to find the median of the absolute differences of a given subarray size.",
            "Use a sorted array approach to optimize the function for large lists.",
            "Return the median of the absolute differences if a valid subarray exists; otherwise, return None."
        ],
        "import_lines": [
            "from typing import List",
            "import statistics"
        ],
        "function_def": "def median_absolute_difference(numbers: List[int], size: int) -> float:\n    if size > len(numbers):\n        return None\n    \n    differences = []\n    for i in range(len(numbers) - size + 1):\n        subarray = numbers[i:i + size]\n        subarray.sort()\n        for j in range(1, len(subarray)):\n            differences.append(abs(subarray[j] - subarray[j - 1]))\n    \n    return statistics.median(differences)"
    },
    {
        "function_name": "moving_window_lis",
        "file_name": "dynamic_programming.py",
        "parameters": {
            "sequence": "List[int] - A list of integers representing a sequence.",
            "m": "int - The size of the moving window."
        },
        "objectives": [
            "Implement the Longest Increasing Subsequence (LIS) algorithm using dynamic programming.",
            "Find the longest increasing subsequence within the moving window of size m.",
            "Return the length of the longest increasing subsequence and the subsequence itself."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def moving_window_lis(sequence: List[int], m: int) -> tuple:\n    lis = [1] * len(sequence)\n    prev = [None] * len(sequence)\n    max_length = 1\n    max_idx = 0\n    \n    for i in range(1, len(sequence)):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                prev[i] = j\n        if lis[i] > max_length:\n            max_length = lis[i]\n            max_idx = i\n    \n    window_lis = []\n    for i in range(len(sequence) - m + 1):\n        window_sequence = sequence[i:i+m]\n        window_lis_idx = max(range(len(window_sequence)), key=lambda x: lis[x+i])\n        window_lis.append(window_sequence[window_lis_idx])\n    \n    return max_length, window_lis"
    },
    {
        "function_name": "lca_queries",
        "file_name": "tree_algorithms.py",
        "parameters": {
            "tree": "List[List[int]] - An adjacency list representing a tree.",
            "queries": "List[List[int]] - A list of queries where each query is a list of two nodes."
        },
        "objectives": [
            "Implement the Lowest Common Ancestor (LCA) algorithm for a tree using dynamic programming.",
            "Use a 2D array to store the LCA of each pair of nodes.",
            "Find the LCA for each query and return the results."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def lca_queries(tree: List[List[int]], queries: List[List[int]]) -> List[int]:\n    n = len(tree)\n    lca = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                lca[i][j] = i\n            elif j in tree[i]:\n                lca[i][j] = i\n                lca[j][i] = i\n            else:\n                for neighbor in tree[i]:\n                    if neighbor != j and lca[neighbor][j] != 0:\n                        lca[i][j] = lca[neighbor][j]\n                        lca[j][i] = lca[i][j]\n    \n    results = []\n    for query in queries:\n        results.append(lca[query[0]][query[1]])\n    \n    return results"
    },
    {
        "function_name": "reverse_linked_list_after_k_nodes",
        "file_name": "linked_list_modifier.py",
        "parameters": {
            "linked_list": "List[int] - A list representing a linked list where each element is a node's value.",
            "k": "int - The number of nodes to skip before reversing the linked list."
        },
        "objectives": [
            "Implement a function to reverse a linked list after every k nodes.",
            "Ensure the function properly handles the edge case where the number of nodes is less than k.",
            "Return the modified linked list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def reverse_linked_list_after_k_nodes(linked_list: List[int], k: int) -> List[int]:\n    if not linked_list:\n        return linked_list\n    \n    result = []\n    i = 0\n    while i < len(linked_list):\n        if i + k <= len(linked_list):\n            result += linked_list[i + k - 1:i - 1:-1]\n        else:\n            result += linked_list[len(linked_list) - 1:i - 1:-1]\n            break\n        i += k\n    \n    return result"
    },
    {
        "function_name": "calculate_student_average_grades",
        "file_name": "grade_calculator.py",
        "parameters": {
            "student_grades": "Dict[str, List[int]] - A dictionary where each key is a student's name and the value is a list of their grades.",
            "threshold": "int - The minimum average grade required to pass."
        },
        "objectives": [
            "Implement a function to calculate the average grade of each student and determine if they have passed or failed based on a threshold.",
            "Ensure the function ignores any non-numeric grades.",
            "Return a dictionary with the student's name as the key and a tuple of their average grade and a boolean indicating whether they passed."
        ],
        "import_lines": [
            "from typing import Dict, List, Tuple"
        ],
        "function_def": "def calculate_student_average_grades(student_grades: Dict[str, List[int]], threshold: int) -> Dict[str, Tuple[float, bool]]:\n    result = {}\n    \n    for student, grades in student_grades.items():\n        numeric_grades = [grade for grade in grades if isinstance(grade, (int, float))]\n        if numeric_grades:\n            average_grade = sum(numeric_grades) / len(numeric_grades)\n            result[student] = (average_grade, average_grade >= threshold)\n    \n    return result"
    },
    {
        "function_name": "louvain_community_detection",
        "file_name": "community_detector.py",
        "parameters": {
            "matrix": "List[List[float]] (An adjacency matrix representing a graph)",
            "min_community_size": "int (The minimum size of a community)",
            "num_runs": "int (The number of runs for the algorithm)"
        },
        "objectives": [
            "Implement a graph clustering algorithm based on modularity maximization.",
            "Use the Louvain algorithm to recursively divide the graph into communities until no further improvement in modularity is possible.",
            "Identify communities with at least min_community_size nodes.",
            "Repeat the algorithm num_runs times and return the community assignment that yields the highest modularity."
        ],
        "import_lines": [
            "from typing import List",
            "import math",
            "import random"
        ],
        "function_def": "def louvain_community_detection(matrix: List[List[float]], min_community_size: int, num_runs: int) -> List[int]:\n    num_nodes = len(matrix)\n    community_assignments = [random.randint(0, num_nodes - 1) for _ in range(num_nodes)]\n    \n    max_modularity = float('-inf')\n    optimal_community_assignments = []\n    \n    for _ in range(num_runs):\n        modularity = 0\n        while True:\n            community_sizes = [0] * num_nodes\n            community_degrees = [0.0] * num_nodes\n            community_gain = [0.0] * num_nodes\n            \n            for i in range(num_nodes):\n                community_sizes[community_assignments[i]] += 1\n                degree = sum(matrix[i])\n                community_degrees[community_assignments[i]] += degree\n                \n                for j in range(num_nodes):\n                    if i != j:\n                        community_gain[community_assignments[i]] += matrix[i][j]\n            \n            total_degree = sum(community_degrees)\n            \n            for i in range(num_nodes):\n                old_community = community_assignments[i]\n                old_modularity = (community_gain[old_community] - (community_degrees[old_community] ** 2) / total_degree) / total_degree\n                \n                max_new_modularity = float('-inf')\n                new_community = old_community\n                \n                for j in range(num_nodes):\n                    new_communities = community_assignments[:]\n                    community_sizes[old_community] -= 1\n                    community_sizes[j] += 1\n                    \n                    community_degrees[old_community] -= sum(matrix[i])\n                    community_degrees[j] += sum(matrix[i])\n                    \n                    community_gain[old_community] -= sum(matrix[i][k] for k in range(num_nodes))\n                    community_gain[j] += sum(matrix[i][k] for k in range(num_nodes))\n                    \n                    new_modularity = (community_gain[j] - (community_degrees[j] ** 2) / total_degree) / total_degree - old_modularity\n                    \n                    community_degrees[old_community] += sum(matrix[i])\n                    community_degrees[j] -= sum(matrix[i])\n                    \n                    community_gain[old_community] += sum(matrix[i][k] for k in range(num_nodes))\n                    community_gain[j] -= sum(matrix[i][k] for k in range(num_nodes))\n                    \n                    community_sizes[old_community] += 1\n                    community_sizes[j] -= 1\n                    \n                    if new_modularity > max_new_modularity:\n                        max_new_modularity = new_modularity\n                        new_community = j\n                \n                if community_sizes[old_community] > min_community_size and max_new_modularity > 0:\n                    modularity += max_new_modularity\n                    community_assignments[i] = new_community\n            \n            if modularity > max_modularity:\n                max_modularity = modularity\n                optimal_community_assignments = community_assignments[:]\n            \n            if modularity == 0:\n                break\n    \n    return optimal_community_assignments"
    },
    {
        "function_name": "text_segmenter",
        "file_name": "text_segmenter.py",
        "parameters": {
            "text": "str (The input text)",
            "window_size": "int (The size of the sliding window)",
            "step_size": "int (The step size of the sliding window)"
        },
        "objectives": [
            "Implement a text segmentation algorithm based on word frequency analysis.",
            "Divide the text into segments using a sliding window approach.",
            "Calculate the word frequency within each window.",
            "Identify segment boundaries where the word frequency changes significantly."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import defaultdict",
            "import math"
        ],
        "function_def": "def text_segmenter(text: str, window_size: int, step_size: int) -> List[str]:\n    words = text.split()\n    word_freq = defaultdict(int)\n    window_word_freq = defaultdict(int)\n    segment_boundaries = [0]\n    \n    for start in range(0, len(words), step_size):\n        if start + window_size <= len(words):\n            for word in words[start:start + window_size]:\n                window_word_freq[word] += 1\n            \n            entropy = 0\n            for word, freq in window_word_freq.items():\n                prob = freq / window_size\n                entropy -= prob * math.log2(prob)\n            \n            for word in words[start:start + window_size]:\n                if word not in word_freq:\n                    word_freq[word] = defaultdict(int)\n                \n                word_freq[word][entropy] += 1\n            \n            max_entropy_change = 0\n            max_entropy_change_index = -1\n            \n            for i in range(start + window_size, len(words)):\n                entropy_change = 0\n                \n                for word in words[i:i + window_size]:\n                    if word not in word_freq:\n                        word_freq[word] = defaultdict(int)\n                    \n                    entropy_change += word_freq[word][i] - word_freq[word][i - step_size]\n                \n                if entropy_change > max_entropy_change:\n                    max_entropy_change = entropy_change\n                    max_entropy_change_index = i\n            \n            if max_entropy_change_index != -1:\n                segment_boundaries.append(max_entropy_change_index)\n        \n    segments = []\n    for i in range(len(segment_boundaries) - 1):\n        segments.append(' '.join(words[segment_boundaries[i]:segment_boundaries[i + 1]]))\n    \n    return segments"
    },
    {
        "function_name": "cast_shadow",
        "file_name": "building_shadow.py",
        "parameters": {
            "sequence": "List[int] (A sequence of integers representing the heights of buildings)",
            "directions": "List[str] (A list of strings representing the directions of the sun, either 'N', 'S', 'E', or 'W')"
        },
        "objectives": [
            "Find the buildings that cast a shadow on other buildings based on the given direction of the sun.",
            "Use a stack data structure to keep track of the buildings that cast shadows.",
            "Return the list of indices of buildings that cast shadows."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def cast_shadow(sequence: List[int], directions: List[str]) -> List[int]:\n    casts_shadow = []\n    for direction in directions:\n        stack = []\n        for i, height in enumerate(sequence):\n            while stack and sequence[stack[-1]] < height:\n                stack.pop()\n            if stack and sequence[stack[-1]] == height:\n                stack.append(i)\n            elif not stack:\n                stack.append(i)\n            else:\n                casts_shadow.append(i)\n    return casts_shadow"
    },
    {
        "function_name": "non_conflicting_intervals",
        "file_name": "interval_scheduler.py",
        "parameters": {
            "intervals": "List[List[int]] (A 2D list of integers representing intervals with start and end times)",
            "meetings": "List[List[int]] (A 2D list of integers representing meeting times with start and end times)"
        },
        "objectives": [
            "Find the intervals that do not conflict with any meeting times.",
            "Use a sorting algorithm to sort the intervals and meeting times by their start times.",
            "Return the list of non-conflicting intervals."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def non_conflicting_intervals(intervals: List[List[int]], meetings: List[List[int]]) -> List[List[int]]:\n    intervals.sort(key=lambda x: x[0])\n    meetings.sort(key=lambda x: x[0])\n    non_conflicting = []\n    j = 0\n    \n    for start, end in intervals:\n        while j < len(meetings) and meetings[j][1] <= start:\n            j += 1\n        if j == len(meetings) or meetings[j][0] >= end:\n            non_conflicting.append([start, end])\n    \n    return non_conflicting"
    },
    {
        "function_name": "find_kth_smallest_sum",
        "file_name": "array_analysis.py",
        "parameters": {
            "a": "List[int] (A list of integers representing the first array)",
            "b": "List[int] (A list of integers representing the second array)",
            "k": "int (The number of elements to find)"
        },
        "objectives": [
            "Find the kth smallest element in the sum of the two arrays.",
            "The sum of the two arrays is defined as the multiset of all possible sums of pairs of elements, one from each array.",
            "Return the kth smallest element."
        ],
        "import_lines": [
            "from typing import List",
            "import heapq"
        ],
        "function_def": "def find_kth_smallest_sum(a: List[int], b: List[int], k: int) -> int:\n    min_heap = []\n    for num_a in a:\n        for num_b in b:\n            heapq.heappush(min_heap, num_a + num_b)\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n    \n    return min_heap[0]"
    },
    {
        "function_name": "apply_convolution",
        "file_name": "image_processing.py",
        "parameters": {
            "pixels": "List[List[Tuple[int, int, int]]] (A 2D list of pixel values, where each pixel is a tuple of RGB values)",
            "kernel": "List[List[int]] (A 2D kernel to apply to the image)"
        },
        "objectives": [
            "Apply a convolution operation to the image using the provided kernel.",
            "Handle boundary cases by padding the image with zeros.",
            "Return the resulting image after applying the convolution operation."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def apply_convolution(pixels: List[List[Tuple[int, int, int]]], kernel: List[List[int]]) -> List[List[Tuple[int, int, int]]]:\n    kernel_height, kernel_width = len(kernel), len(kernel[0])\n    image_height, image_width = len(pixels), len(pixels[0])\n    padded_image = [[(0, 0, 0) for _ in range(image_width + kernel_width - 1)] for _ in range(image_height + kernel_height - 1)]\n    \n    for i in range(image_height):\n        for j in range(image_width):\n            padded_image[i + kernel_height // 2][j + kernel_width // 2] = pixels[i][j]\n    \n    result = [[(0, 0, 0) for _ in range(image_width)] for _ in range(image_height)]\n    \n    for i in range(image_height):\n        for j in range(image_width):\n            for k in range(kernel_height):\n                for index in range(kernel_width):\n                    pixel_value = padded_image[i + k][j + index]\n                    result[i][j] = tuple(sum(x) for x in zip(result[i][j], tuple(pixel_value[x] * kernel[k][index] for x in range(3))))\n    \n    return result"
    },
    {
        "function_name": "decode_variable_length_codes",
        "file_name": "compression_algorithms.py",
        "parameters": {
            "binary_string": "str (A binary string to be decoded)",
            "codes": "Dict[str, str] (A dictionary of variable-length codes and their corresponding characters)"
        },
        "objectives": [
            "Decode the binary string using the provided variable-length codes.",
            "Handle cases where the binary string is not a valid code.",
            "Return the decoded string."
        ],
        "import_lines": [
            "from typing import Dict"
        ],
        "function_def": "def decode_variable_length_codes(binary_string: str, codes: Dict[str, str]) -> str:\n    decoded_string = \"\"\n    temp = \"\"\n    \n    for bit in binary_string:\n        temp += bit\n        if temp in codes:\n            decoded_string += codes[temp]\n            temp = \"\"\n    \n    if temp:  # If the binary string is not a valid code\n        raise ValueError(\"Invalid binary string\")\n    \n    return decoded_string"
    },
    {
        "function_name": "phong_illumination",
        "file_name": "lighting.py",
        "parameters": {
            "`triangle`": "List[List[float]] - A list of 3D coordinates representing the vertices of a triangle.",
            "`light_source`": "List[float] - A list representing the coordinates of a light source.",
            "`ambient_light`": "float - The amount of ambient light in the scene.",
            "`specularity`": "float - The specularity of the triangle's material."
        },
        "objectives": [
            "Calculate the color of a triangle in a 3D scene using the Phong reflection model.",
            "Take into account the ambient light, diffuse light, and specular light.",
            "Handle cases where the light source is behind the triangle."
        ],
        "import_lines": [
            "from typing import List",
            "import math"
        ],
        "function_def": "def phong_illumination(triangle: List[List[float]], light_source: List[float], ambient_light: float, specularity: float) -> List[float]:\n    # Calculate the normal vector of the triangle\n    v1 = [triangle[1][0] - triangle[0][0], triangle[1][1] - triangle[0][1], triangle[1][2] - triangle[0][2]]\n    v2 = [triangle[2][0] - triangle[0][0], triangle[2][1] - triangle[0][1], triangle[2][2] - triangle[0][2]]\n    normal = [v1[1]*v2[2] - v1[2]*v2[1], v1[2]*v2[0] - v1[0]*v2[2], v1[0]*v2[1] - v1[1]*v2[0]]\n    normal_length = math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2)\n    normal = [normal[0]/normal_length, normal[1]/normal_length, normal[2]/normal_length]\n    \n    # Calculate the light direction vector\n    light_direction = [light_source[0] - triangle[0][0], light_source[1] - triangle[0][1], light_source[2] - triangle[0][2]]\n    light_length = math.sqrt(light_direction[0]**2 + light_direction[1]**2 + light_direction[2]**2)\n    light_direction = [light_direction[0]/light_length, light_direction[1]/light_length, light_direction[2]/light_length]\n    \n    # Calculate the diffuse light\n    diffuse_light = max(0, normal[0]*light_direction[0] + normal[1]*light_direction[1] + normal[2]*light_direction[2])\n    \n    # Calculate the specular light\n    view_direction = [0, 0, 1]\n    reflection_direction = [2*normal[0]*diffuse_light - light_direction[0], 2*normal[1]*diffuse_light - light_direction[1], 2*normal[2]*diffuse_light - light_direction[2]]\n    specular_light = max(0, view_direction[0]*reflection_direction[0] + view_direction[1]*reflection_direction[1] + view_direction[2]*reflection_direction[2])\n    specular_light = specular_light ** specularity\n    \n    # Calculate the final color\n    color = [ambient_light + diffuse_light, ambient_light + diffuse_light, ambient_light + diffuse_light]\n    color = [min(max(color[0] + specular_light, 0), 1), min(max(color[1] + specular_light, 0), 1), min(max(color[2] + specular_light, 0), 1)]\n    \n    return color"
    },
    {
        "function_name": "astar_pathfinder",
        "file_name": "pathfinder.py",
        "parameters": {
            "`grid`": "List[List[int]] - A 2D grid representing a map with obstacles.",
            "`start`": "Tuple[int, int] - The starting position in the map.",
            "`end`": "Tuple[int, int] - The ending position in the map.",
            "`unit_cost`": "int - The cost of moving one unit in the map.",
            "`diagonal_cost`": "int - The cost of moving diagonally in the map."
        },
        "objectives": [
            "Implement the A\\* pathfinding algorithm to find the shortest path from the start to the end in the map.",
            "Take into account the unit cost and diagonal cost of moving.",
            "Handle cases where there are obstacles in the map."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import heapq"
        ],
        "function_def": "def astar_pathfinder(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int], unit_cost: int, diagonal_cost: int) -> List[Tuple[int, int]]:\n    open_list = []\n    heapq.heappush(open_list, (0, start))\n    came_from = {start: None}\n    cost_so_far = {start: 0}\n    \n    while open_list:\n        current = heapq.heappop(open_list)[1]\n        if current == end:\n            break\n        \n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\n            next = current[0] + dx, current[1] + dy\n            if 0 <= next[0] < len(grid) and 0 <= next[1] < len(grid[0]) and grid[next[0]][next[1]] != 1:\n                new_cost = cost_so_far[current] + (unit_cost if abs(dx) + abs(dy) == 1 else diagonal_cost)\n                if next not in cost_so_far or new_cost < cost_so_far[next]:\n                    cost_so_far[next] = new_cost\n                    priority = new_cost + abs(next[0] - end[0]) + abs(next[1] - end[1])\n                    heapq.heappush(open_list, (priority, next))\n                    came_from[next] = current\n    \n    # Reconstruct the path\n    current = end\n    path = []\n    while current != start:\n        path.append(current)\n        current = came_from[current]\n    path.append(start)\n    path.reverse()\n    \n    return path"
    },
    {
        "function_name": "project_triangle",
        "file_name": "projection.py",
        "parameters": {
            "`triangle`": "List[List[float]] - A list of 3D coordinates representing the vertices of a triangle.",
            "`axis`": "int - The axis to project the triangle onto.",
            "`precision`": "float - The precision of the projection."
        },
        "objectives": [
            "Project a triangle onto a plane defined by the given axis.",
            "Calculate the area of the projected triangle.",
            "Handle cases where the triangle is degenerate."
        ],
        "import_lines": [
            "from typing import List",
            "import math"
        ],
        "function_def": "def project_triangle(triangle: List[List[float]], axis: int, precision: float) -> float:\n    # Calculate the normal vector of the triangle\n    v1 = [triangle[1][0] - triangle[0][0], triangle[1][1] - triangle[0][1], triangle[1][2] - triangle[0][2]]\n    v2 = [triangle[2][0] - triangle[0][0], triangle[2][1] - triangle[0][1], triangle[2][2] - triangle[0][2]]\n    normal = [v1[1]*v2[2] - v1[2]*v2[1], v1[2]*v2[0] - v1[0]*v2[2], v1[0]*v2[1] - v1[1]*v2[0]]\n    normal_length = math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2)\n    normal = [normal[0]/normal_length, normal[1]/normal_length, normal[2]/normal_length]\n    \n    # Project the triangle onto the plane\n    projected_triangle = []\n    for point in triangle:\n        projected_point = [point[0] - normal[0]*point[axis], point[1] - normal[1]*point[axis], point[2] - normal[2]*point[axis]]\n        projected_triangle.append(projected_point)\n    \n    # Calculate the area of the projected triangle\n    v1 = [projected_triangle[1][0] - projected_triangle[0][0], projected_triangle[1][1] - projected_triangle[0][1]]\n    v2 = [projected_triangle[2][0] - projected_triangle[0][0], projected_triangle[2][1] - projected_triangle[0][1]]\n    area = abs(v1[0]*v2[1] - v1[1]*v2[0]) / 2\n    \n    return area"
    },
    {
        "function_name": "common_words",
        "file_name": "text_analysis.py",
        "parameters": {
            "`words`": "List[str] - A list of words.",
            "`threshold`": "int - The minimum frequency of a word to be considered common."
        },
        "objectives": [
            "Calculate the frequency of each word in the list.",
            "Identify the common words that appear more than the given threshold.",
            "Handle cases where there are ties in the frequencies."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import Counter"
        ],
        "function_def": "def common_words(words: List[str], threshold: int) -> List[str]:\n    # Calculate the frequency of each word\n    frequency = Counter(words)\n    \n    # Identify the common words\n    common = [word for word, count in frequency.items() if count > threshold]\n    \n    return common"
    },
    {
        "function_name": "closest_pair_equal_elements",
        "file_name": "closest_pair.py",
        "parameters": {
            "nums": "List[int]"
        },
        "objectives": [
            "Implement a function to find the closest pair of equal elements in the list.",
            "Use two pointers technique to achieve this.",
            "Handle cases where there are no pairs of equal elements or the list is empty."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def closest_pair_equal_elements(nums: List[int]) -> int:\n    if len(nums) < 2:\n        raise ValueError(\"List has less than two elements\")\n    \n    nums.sort()\n    min_diff = float('inf')\n    \n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            min_diff = min(min_diff, i - (i - 1))\n    \n    if min_diff == float('inf'):\n        raise ValueError(\"No pairs of equal elements\")\n    \n    return min_diff"
    },
    {
        "function_name": "triangle_properties",
        "file_name": "geometry.py",
        "parameters": {
            "triangles": "List[List[int]] (A list of triangles where each triangle is represented by three sides)",
            "precision": "float (The precision for floating point calculations)"
        },
        "objectives": [
            "Implement a function that calculates the area of each triangle in the list using Heron's formula.",
            "For each triangle, calculate the radius of its inscribed circle.",
            "Return a list of tuples containing the area and the radius of the inscribed circle for each triangle."
        ],
        "import_lines": [
            "from typing import List",
            "import math"
        ],
        "function_def": "def triangle_properties(triangles: List[List[int]], precision: float) -> List[tuple]:\n    result = []\n    \n    for triangle in triangles:\n        a, b, c = triangle\n        # Calculate semi-perimeter\n        s = (a + b + c) / 2\n        \n        # Calculate area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        \n        # Calculate radius of the inscribed circle\n        r = area / s\n        \n        # Round to the specified precision\n        area = round(area, precision)\n        r = round(r, precision)\n        \n        result.append((area, r))\n    \n    return result"
    },
    {
        "function_name": "min_trucks",
        "file_name": "route_optimization.py",
        "parameters": {
            "routes": "List[List[int]] (A list of routes where each route is represented by a list of nodes)",
            "capacity": "int (The capacity of each truck)"
        },
        "objectives": [
            "Implement a function that calculates the minimum number of trucks required to deliver goods along all routes.",
            "The function should ensure that the total demand of each route does not exceed the capacity of the truck.",
            "Return the minimum number of trucks required."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def min_trucks(routes: List[List[int]], capacity: int) -> int:\n    demand = [0] * len(routes)\n    for i, route in enumerate(routes):\n        demand[i] = max(route)\n    \n    return sum((d + capacity - 1) // capacity for d in demand)"
    },
    {
        "function_name": "schedule_jobs",
        "file_name": "job_scheduling.py",
        "parameters": {
            "jobs": "List[Tuple[int, int]] (A list of jobs where each job is represented by its start and end time)",
            "machines": "int (The number of machines available)"
        },
        "objectives": [
            "Implement a function that schedules the jobs on the machines to minimize the total processing time.",
            "The function should ensure that each job is assigned to a machine and that the total processing time of each machine is minimized.",
            "Return the scheduled jobs for each machine."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import heapq"
        ],
        "function_def": "def schedule_jobs(jobs: List[Tuple[int, int]], machines: int) -> List[List[Tuple[int, int]]]:\n    pq = [(0, i) for i in range(machines)]\n    heapq.heapify(pq)\n    scheduled_jobs = [[] for _ in range(machines)]\n    \n    for job in sorted(jobs):\n        _, machine_id = heapq.heappop(pq)\n        scheduled_jobs[machine_id].append(job)\n        heapq.heappush(pq, (job[1], machine_id))\n    \n    return scheduled_jobs"
    },
    {
        "function_name": "n_sum",
        "file_name": "n_sum_solutions.py",
        "parameters": {
            "nums": "List[int] - A list of integers",
            "target": "int - The target sum"
        },
        "objectives": [
            "Implement the 4Sum problem solution, where all unique quadruplets in the list add up to the target sum.",
            "Ensure to handle duplicate quadruplets by skipping them.",
            "Return a list of unique quadruplets."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def n_sum(nums: List[int], target: int) -> List[List[int]]:\n    nums.sort()\n    result = []\n    \n    for first in range(len(nums) - 3):\n        if first > 0 and nums[first] == nums[first - 1]:\n            continue\n        for second in range(first + 1, len(nums) - 2):\n            if second > first + 1 and nums[second] == nums[second - 1]:\n                continue\n            left, right = second + 1, len(nums) - 1\n            \n            while left < right:\n                current_sum = nums[first] + nums[second] + nums[left] + nums[right]\n                \n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    result.append([nums[first], nums[second], nums[left], nums[right]])\n                    \n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    \n                    left += 1\n                    right -= 1\n                    \n    return result"
    },
    {
        "function_name": "astar_search",
        "file_name": "pathfinding_algorithms.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid representing a maze",
            "start": "Tuple[int, int] - The starting coordinates",
            "end": "Tuple[int, int] - The ending coordinates"
        },
        "objectives": [
            "Implement a pathfinding algorithm using A* search to find the shortest path from the start to the end.",
            "Ensure to handle obstacles in the maze (represented by 1s in the grid).",
            "Return the shortest path as a list of coordinates."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import heapq"
        ],
        "function_def": "def astar_search(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = [(0, start)]\n    distances = {start: 0}\n    previous = {start: None}\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        if current_node == end:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = previous[current_node]\n            return path[::-1]\n        \n        for movement in movements:\n            x, y = current_node[0] + movement[0], current_node[1] + movement[1]\n            if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and grid[x][y] == 0:\n                new_distance = current_distance + 1 + abs(x - end[0]) + abs(y - end[1])\n                \n                if (x, y) not in distances or new_distance < distances[(x, y)]:\n                    distances[(x, y)] = new_distance\n                    priority = new_distance\n                    heapq.heappush(queue, (priority, (x, y)))\n                    previous[(x, y)] = current_node\n                    \n    return None"
    },
    {
        "function_name": "transitive_closure",
        "file_name": "database_queries.py",
        "parameters": {
            "relations": "List[List[str]] (A list of binary relations between entities in a database)",
            "query": "List[str] (A list of entities in a query)"
        },
        "objectives": [
            "Implement a function to find transitive closures of binary relations in a database.",
            "Use Warshall's algorithm to compute the transitive closure.",
            "Handle edge cases where the input relations or query are empty.",
            "Return the transitive closure as a 2D matrix."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def transitive_closure(relations: List[List[str]], query: List[str]) -> List[List[int]]:\n    num_entities = len(query)\n    closure = [[0] * num_entities for _ in range(num_entities)]\n    \n    for i in range(num_entities):\n        for j in range(num_entities):\n            for relation in relations:\n                if relation[0] == query[i] and relation[1] == query[j]:\n                    closure[i][j] = 1\n                    break\n    \n    for k in range(num_entities):\n        for i in range(num_entities):\n            for j in range(num_entities):\n                if closure[i][k] and closure[k][j]:\n                    closure[i][j] = 1\n    \n    return closure"
    },
    {
        "function_name": "check_matrix_means",
        "file_name": "matrix_statistics.py",
        "parameters": {
            "`matrices`": "List[List[List[int]]] - A list of 3D matrices",
            "`threshold`": "int - The threshold value"
        },
        "objectives": [
            "Flatten each 3D matrix into a 1D array.",
            "Calculate the mean of each 1D array.",
            "Check if the mean is greater than the threshold.",
            "Return a list of boolean values indicating whether the mean of each matrix is greater than the threshold."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def check_matrix_means(matrices: List[List[List[int]]], threshold: int) -> List[bool]:\n    means = []\n    for matrix in matrices:\n        flat_array = [num for sublist in matrix for subsublist in sublist for num in subsublist]\n        mean = sum(flat_array) / len(flat_array)\n        means.append(mean > threshold)\n    return means"
    },
    {
        "function_name": "bfs_traversal",
        "file_name": "graph_algorithms.py",
        "parameters": {
            "graph": "Dict[str, List[str]] (An adjacency list representation of a graph)",
            "source_node": "str (The source node for the breadth-first search)"
        },
        "objectives": [
            "Implement a breadth-first search (BFS) algorithm on the graph.",
            "Use a queue data structure to efficiently visit the nodes.",
            "Return a list of nodes in the order they were visited."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import deque"
        ],
        "function_def": "def bfs_traversal(graph: Dict[str, List[str]], source_node: str) -> List[str]:\n    visited = set()\n    traversal_order = []\n    queue = deque([source_node])\n    \n    while queue:\n        node = queue.popleft()\n        \n        if node not in visited:\n            visited.add(node)\n            traversal_order.append(node)\n            \n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    \n    return traversal_order"
    },
    {
        "function_name": "prim_mst_finder",
        "file_name": "graph_algorithms.py",
        "parameters": {
            "n": "int (The number of nodes in the graph)",
            "edges": "List[Tuple[int, int, int]] (A list of weighted edges in the graph)"
        },
        "objectives": [
            "Implement Prim's algorithm for finding the minimum spanning tree (MST) of a graph.",
            "Use a priority queue data structure to efficiently select the minimum-weight edges.",
            "Return a list of edges in the MST."
        ],
        "import_lines": [
            "import heapq",
            "from typing import List, Tuple"
        ],
        "function_def": "def prim_mst_finder(n: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    mst_edges = []\n    visited = [False] * n\n    priority_queue = []\n    \n    for i in range(n):\n        if not visited[i]:\n            heapq.heappush(priority_queue, (0, i))\n            visited[i] = True\n            \n            while priority_queue:\n                weight, node = heapq.heappop(priority_queue)\n                \n                for edge in edges:\n                    if edge[0] == node or edge[1] == node:\n                        neighbor = edge[0] if edge[1] == node else edge[1]\n                        \n                        if not visited[neighbor]:\n                            heapq.heappush(priority_queue, (edge[2], neighbor))\n                            visited[neighbor] = True\n                            mst_edges.append(edge)\n    \n    return mst_edges"
    },
    {
        "function_name": "detect_edges",
        "file_name": "image_processing.py",
        "parameters": {
            "image": "List[List[int]] - A 2D list representing the image pixels.",
            "threshold": "int - The threshold value for edge detection."
        },
        "objectives": [
            "Implement a function to detect edges in the image using the Sobel operator.",
            "Apply the Sobel operator to each pixel in the image.",
            "Return the edge map as a 2D list."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def detect_edges(image: List[List[int]], threshold: int) -> List[List[int]]:\n    # Define the Sobel operator kernels\n    sobel_x = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]\n    sobel_y = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]\n    \n    # Apply the Sobel operator to each pixel\n    edge_map = [[0 for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(1, len(image) - 1):\n        for j in range(1, len(image[0]) - 1):\n            gradient_x = sum(sobel_x[k][l] * image[i + k - 1][j + l - 1] for k in range(3) for l in range(3))\n            gradient_y = sum(sobel_y[k][l] * image[i + k - 1][j + l - 1] for k in range(3) for l in range(3))\n            gradient = (gradient_x ** 2 + gradient_y ** 2) ** 0.5\n            if gradient > threshold:\n                edge_map[i][j] = 1\n    \n    return edge_map"
    },
    {
        "function_name": "is_graph_traversable",
        "file_name": "graph_traversal.py",
        "parameters": {
            "graph": "Dict[int, List[int]] (An adjacency list representation of a graph)",
            "start_node": "int (The node to start the traversal from)",
            "visit_order": "List[int] (The order in which nodes should be visited)"
        },
        "objectives": [
            "Implement a function to check if a given graph is traversable in a specified order.",
            "The graph is traversable if it is possible to visit all nodes exactly once, following the given order.",
            "Ensure that the function handles both directed and undirected graphs.",
            "Return True if the graph is traversable, False otherwise."
        ],
        "import_lines": [
            "from typing import Dict, List"
        ],
        "function_def": "def is_graph_traversable(graph: Dict[int, List[int]], start_node: int, visit_order: List[int]) -> bool:\n    visited = set()\n    for node in visit_order:\n        if node not in graph:\n            return False\n        if node != start_node and node not in visited:\n            return False\n        for neighbor in graph[node]:\n            if neighbor not in visited and neighbor != start_node:\n                return False\n        visited.add(node)\n    return len(visited) == len(graph)"
    },
    {
        "function_name": "find_available_time_slots",
        "file_name": "time_slot_finder.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] - A list of time intervals.",
            "appointments": "List[Tuple[int, int]] - A list of appointment time intervals."
        },
        "objectives": [
            "Implement a function to find the available time slots given a list of intervals and appointments.",
            "Ensure the function correctly handles overlapping intervals and appointments.",
            "Return a list of available time slots."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def find_available_time_slots(intervals: List[Tuple[int, int]], appointments: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    # Combine intervals and appointments into a single list\n    combined = intervals + appointments\n    \n    # Sort the combined list by start time\n    combined.sort(key=lambda x: x[0])\n    \n    # Initialize the list of available time slots\n    available_time_slots = []\n    \n    # Initialize the end time of the last appointment or interval\n    last_end_time = 0\n    \n    # Iterate over the combined list\n    for start, end in combined:\n        # If the current start time is greater than the last end time, add the available time slot\n        if start > last_end_time:\n            available_time_slots.append((last_end_time, start))\n        # Update the last end time if the current end time is greater\n        last_end_time = max(last_end_time, end)\n    \n    # Add the available time slot after the last appointment or interval\n    available_time_slots.append((last_end_time, 24 * 60))  # Assuming a 24-hour clock in minutes\n    \n    return available_time_slots"
    },
    {
        "function_name": "calculate_elo_ratings",
        "file_name": "elo_calculator.py",
        "parameters": {
            "tournaments": "List[List[int]] - A list of tournament outcomes where each outcome is represented as a list of player indices.",
            "players": "List[str] - A list of player names."
        },
        "objectives": [
            "Implement a function to calculate the ELO rating of each player based on the tournament outcomes.",
            "Ensure the function uses the ELO rating system formula to calculate the new ratings.",
            "Return a dictionary mapping player names to their new ELO ratings."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def calculate_elo_ratings(tournaments: List[List[int]], players: List[str]) -> Dict[str, int]:\n    # Initialize the ELO ratings dictionary with default ratings\n    elo_ratings = {player: 1000 for player in players}\n    \n    # Iterate over the tournament outcomes\n    for tournament in tournaments:\n        # Iterate over the players in the tournament\n        for i, player_index in enumerate(tournament):\n            # Calculate the ELO rating change\n            rating_change = 0\n            for j, opponent_index in enumerate(tournament):\n                if i != j:\n                    # Calculate the expected score\n                    expected_score = 1 / (1 + 10 ** ((elo_ratings[players[opponent_index]] - elo_ratings[players[player_index]]) / 400))\n                    # Calculate the ELO rating change\n                    rating_change += 32 * (1 - expected_score)\n            # Update the ELO rating\n            elo_ratings[players[player_index]] += rating_change\n    \n    return elo_ratings"
    },
    {
        "function_name": "find_motif",
        "file_name": "dna_search.py",
        "parameters": {
            "dna_sequence": "str (A DNA sequence)",
            "motif": "str (A motif to search for in the DNA sequence)",
            "mismatches": "int (The maximum number of mismatches allowed)"
        },
        "objectives": [
            "Implement a function to find all occurrences of a given motif in a DNA sequence, allowing for a certain number of mismatches.",
            "Ensure the function properly handles edge cases where the motif is longer than the DNA sequence or the number of mismatches is greater than the motif length.",
            "Return a list of start positions where the motif is found."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_motif(dna_sequence: str, motif: str, mismatches: int) -> List[int]:\n    if len(motif) > len(dna_sequence) or mismatches > len(motif):\n        return []\n    \n    result = []\n    for i in range(len(dna_sequence) - len(motif) + 1):\n        match = True\n        mismatch_count = 0\n        for j in range(len(motif)):\n            if dna_sequence[i + j] != motif[j]:\n                mismatch_count += 1\n                if mismatch_count > mismatches:\n                    match = False\n                    break\n        if match:\n            result.append(i)\n    \n    return result"
    },
    {
        "function_name": "largest_eigenvalues",
        "file_name": "eigenvalues.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix)",
            "k": "int (The number of eigenvalues to find)"
        },
        "objectives": [
            "Implement a function to find the k largest eigenvalues of a given 2D matrix.",
            "Ensure the function properly handles edge cases where the matrix is not square or k is greater than the matrix size.",
            "Return a list of the k largest eigenvalues."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def largest_eigenvalues(matrix: List[List[int]], k: int) -> List[float]:\n    if not matrix or not all(len(row) == len(matrix) for row in matrix) or k > len(matrix):\n        return []\n    \n    eigenvalues = np.linalg.eigvals(np.array(matrix))\n    eigenvalues = sorted(eigenvalues, reverse=True)\n    return [e.real for e in eigenvalues[:k]]"
    },
    {
        "function_name": "max_non_overlapping_coincidences",
        "file_name": "coincidence_finder.py",
        "parameters": {
            "`coincidences`": "List[Tuple[int, int]] (A list of coincidences, where each coincidence is a tuple containing the start and end times of a coincidence)",
            "`tolerance`": "int (The tolerance in seconds to consider two coincidences as the same)"
        },
        "objectives": [
            "Implement a function to find the maximum number of non-overlapping coincidences.",
            "Two coincidences are considered non-overlapping if the difference between the end time of the first coincidence and the start time of the second coincidence is greater than the tolerance.",
            "Return the maximum number of non-overlapping coincidences."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def max_non_overlapping_coincidences(coincidences: List[Tuple[int, int]], tolerance: int) -> int:\n    coincidences.sort(key=lambda x: x[1])\n    max_count = 0\n    end_time = 0\n    \n    for start, end in coincidences:\n        if start - end_time > tolerance:\n            max_count += 1\n            end_time = end\n    \n    return max_count"
    },
    {
        "function_name": "evaluate_expressions",
        "file_name": "expression_evaluator.py",
        "parameters": {
            "`arithmetic_expressions`": "List[str] (A list of arithmetic expressions in the form of strings)",
            "`variables`": "Dict[str, int] (A dictionary of variable names and their corresponding integer values)"
        },
        "objectives": [
            "Implement a function to evaluate a list of arithmetic expressions with variables.",
            "The expressions can contain integer constants, variable names, and basic arithmetic operators (+, -, *, /).",
            "Return a list of evaluated expression values."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def evaluate_expressions(arithmetic_expressions: List[str], variables: Dict[str, int]) -> List[int]:\n    evaluated_values = []\n    \n    for expression in arithmetic_expressions:\n        expression = expression.replace(' ', '')\n        \n        for var, value in variables.items():\n            expression = expression.replace(var, str(value))\n        \n        try:\n            evaluated_values.append(eval(expression))\n        except ZeroDivisionError:\n            evaluated_values.append(None)\n    \n    return evaluated_values"
    },
    {
        "function_name": "rle_compression",
        "file_name": "rle_algorithm.py",
        "parameters": {
            "binary_string": "str (A binary string to compress)"
        },
        "objectives": [
            "Implement the Run-Length Encoding (RLE) algorithm to compress the binary string.",
            "Replace consecutive occurrences of the same bit with a single bit and a count.",
            "Return the compressed binary string."
        ],
        "import_lines": [],
        "function_def": "def rle_compression(binary_string: str) -> str:\n    if not binary_string:\n        return ''\n    \n    compressed = ''\n    count = 1\n    for i in range(1, len(binary_string)):\n        if binary_string[i] == binary_string[i - 1]:\n            count += 1\n        else:\n            compressed += binary_string[i - 1] + str(count)\n            count = 1\n    compressed += binary_string[-1] + str(count)\n    \n    return compressed"
    },
    {
        "function_name": "find_target_row",
        "file_name": "matrix_searcher.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list representing a matrix)",
            "target_row": "int (The target row to search for)"
        },
        "objectives": [
            "Find the first row in the matrix that contains all elements of the target row.",
            "If the target row is not found, return -1.",
            "Ensure that the search is performed efficiently using a hash-based approach."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_target_row(matrix: List[List[int]], target_row: List[int]) -> int:\n    target_row_set = set(target_row)\n    for i, row in enumerate(matrix):\n        if set(row) >= target_row_set:\n            return i\n    return -1"
    },
    {
        "function_name": "word_frequency",
        "file_name": "text_analyzer.py",
        "parameters": {
            "text": "str (The text to process)",
            "max_length": "int (The maximum length of a word to consider)"
        },
        "objectives": [
            "Extract all unique words from the text that have a length less than or equal to max_length.",
            "Count the frequency of each word.",
            "Return a dictionary where the keys are the words and the values are their frequencies."
        ],
        "import_lines": [
            "from typing import Dict",
            "import re",
            "from collections import defaultdict"
        ],
        "function_def": "def word_frequency(text: str, max_length: int) -> Dict[str, int]:\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    word_freq = defaultdict(int)\n    for word in words:\n        if len(word) <= max_length:\n            word_freq[word] += 1\n    return dict(word_freq)"
    },
    {
        "function_name": "find_sequence_pairs",
        "file_name": "sequence_matcher.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of sequences, where each sequence is a list of integers)",
            "target_sum": "int (The target sum to find)"
        },
        "objectives": [
            "Find all pairs of sequences that have a sum equal to the target sum.",
            "Ensure that the pairs are distinct, i.e., (A, B) and (B, A) are considered the same pair.",
            "Return a list of tuples, where each tuple contains a pair of sequence indices."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "from itertools import combinations"
        ],
        "function_def": "def find_sequence_pairs(sequences: List[List[int]], target_sum: int) -> List[Tuple[int, int]]:\n    sequence_sums = [sum(seq) for seq in sequences]\n    pairs = set()\n    for i, j in combinations(range(len(sequences)), 2):\n        if sequence_sums[i] + sequence_sums[j] == target_sum:\n            pairs.add(tuple(sorted((i, j))))\n    return list(pairs)"
    },
    {
        "function_name": "top_k_diagonal",
        "file_name": "top_k_diagonal.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D list representing a matrix)",
            "k": "int (The number of elements to find in the top-k diagonal elements)"
        },
        "objectives": [
            "Implement a function to find the top-k diagonal elements in a matrix.",
            "Handle the case where k is greater than the number of diagonal elements by returning all diagonal elements.",
            "Return the top-k diagonal elements as a list of integers."
        ],
        "import_lines": [
            "from typing import List",
            "import heapq"
        ],
        "function_def": "def top_k_diagonal(matrix: List[List[int]], k: int) -> List[int]:\n    diagonal_elements = []\n    for i in range(min(len(matrix), len(matrix[0]))):\n        diagonal_elements.append(matrix[i][i])\n    \n    return heapq.nlargest(k, diagonal_elements)"
    },
    {
        "function_name": "count_subarrays_with_sum",
        "file_name": "count_subarrays_with_sum.py",
        "parameters": {
            "array": "List[int] (A list of integers to find the count of subarrays with a given sum)",
            "target_sum": "int (The target sum for the subarrays)"
        },
        "objectives": [
            "Implement a function to find the count of subarrays with a given sum.",
            "Handle the case where the input list is empty by returning 0.",
            "Return the count of subarrays with the given sum."
        ],
        "import_lines": [
            "from typing import List",
            "import collections"
        ],
        "function_def": "def count_subarrays_with_sum(array: List[int], target_sum: int) -> int:\n    count = 0\n    prefix_sum_count = collections.defaultdict(int)\n    prefix_sum_count[0] = 1\n    \n    current_sum = 0\n    for num in array:\n        current_sum += num\n        \n        if current_sum - target_sum in prefix_sum_count:\n            count += prefix_sum_count[current_sum - target_sum]\n        \n        prefix_sum_count[current_sum] += 1\n    \n    return count"
    },
    {
        "function_name": "minimize_cost_to_median_difference",
        "file_name": "pair_minimizer.py",
        "parameters": {
            "pairs": "List[Tuple[int, int]] - A list of pairs where each pair consists of two integers.",
            "k": "int - The maximum number of operations allowed to make all pairs have the same difference."
        },
        "objectives": [
            "Find the median of all pair differences.",
            "Calculate the total cost to make all pairs have the median difference, considering the cost to change one pair is the absolute difference between the current difference and the median difference.",
            "Use dynamic programming to minimize the total cost by selecting the optimal pairs to change.",
            "Return the minimum cost."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def minimize_cost_to_median_difference(pairs: List[Tuple[int, int]], k: int) -> int:\n    differences = [abs(pair[0] - pair[1]) for pair in pairs]\n    differences.sort()\n    median_difference = differences[len(differences) // 2]\n    \n    n = len(pairs)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + abs(abs(pairs[i - 1][0] - pairs[i - 1][1]) - median_difference))\n    \n    return dp[n][k]"
    },
    {
        "function_name": "max_seats_with_social_distancing",
        "file_name": "theater_seating.py",
        "parameters": {
            "matrix": "List[List[int]] - A matrix of integers representing the availability of seats in a theater.",
            "rows": "int - The number of rows in the theater.",
            "cols": "int - The number of columns in the theater."
        },
        "objectives": [
            "Find the maximum number of seats that can be occupied in the theater while maintaining social distancing guidelines.",
            "Use dynamic programming to find the optimal arrangement of occupied and empty seats.",
            "Return the maximum number of occupied seats."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_seats_with_social_distancing(matrix: List[List[int]], rows: int, cols: int) -> int:\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                if i > 0 and j > 0:\n                    dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j])\n                elif i > 0:\n                    dp[i][j] = dp[i - 1][j]\n                elif j > 0:\n                    dp[i][j] = dp[i][j - 1]\n                dp[i][j] += 1\n    \n    return max(max(row) for row in dp)"
    },
    {
        "function_name": "bfs_traverser",
        "file_name": "graph_traverser.py",
        "parameters": {
            "`graph`": "`List[List[int]]` - An adjacency matrix representing a directed graph.",
            "`start_vertex`": "`int` - The starting vertex for the graph traversal.",
            "`max_distance`": "`int` - The maximum distance to consider for the graph traversal."
        },
        "objectives": [
            "Perform a Breadth-First Search (BFS) traversal of the graph starting from the specified vertex.",
            "Keep track of the distance of each vertex from the starting vertex.",
            "If a vertex is not reachable within the specified maximum distance, return a special value (e.g., -1) to indicate this.",
            "Return a list of lists, where the first element of each inner list is a vertex ID and the second element is its distance from the starting vertex."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def bfs_traverser(graph: List[List[int]], start_vertex: int, max_distance: int) -> List[List[int]]:\n    visited = [False] * len(graph)\n    distances = [-1] * len(graph)\n    distances[start_vertex] = 0\n    queue = [start_vertex]\n    \n    while queue:\n        vertex = queue.pop(0)\n        if distances[vertex] > max_distance:\n            break\n        visited[vertex] = True\n        for neighbor, edge in enumerate(graph[vertex]):\n            if edge == 1 and not visited[neighbor]:\n                distances[neighbor] = distances[vertex] + 1\n                queue.append(neighbor)\n    \n    result = [[i, distances[i]] for i in range(len(graph)) if distances[i] != -1]\n    return result"
    },
    {
        "function_name": "linear_solver",
        "file_name": "linear_solver.py",
        "parameters": {
            "`matrix`": "`List[List[float]]` - A 2D matrix representing a linear system.",
            "`vector`": "`List[float]` - A vector representing the right-hand side of the linear system.",
            "`tolerance`": "`float` - The tolerance for the solution."
        },
        "objectives": [
            "Use Gauss-Jordan Elimination to solve the linear system.",
            "Check for inconsistent and dependent solutions.",
            "If the system is consistent and independent, return the solution vector.",
            "If the system is inconsistent, return an error message.",
            "If the system is dependent, return a message indicating that there are infinitely many solutions."
        ],
        "import_lines": [
            "from typing import List, Union"
        ],
        "function_def": "def linear_solver(matrix: List[List[float]], vector: List[float], tolerance: float) -> Union[List[float], str]:\n    n = len(matrix)\n    augmented_matrix = [row + [vector[i]] for i, row in enumerate(matrix)]\n    \n    for i in range(n):\n        if augmented_matrix[i][i] == 0:\n            for j in range(i + 1, n):\n                if augmented_matrix[j][i] != 0:\n                    augmented_matrix[i], augmented_matrix[j] = augmented_matrix[j], augmented_matrix[i]\n                    break\n        if augmented_matrix[i][i] == 0:\n            if augmented_matrix[i][-1] != 0:\n                return \"Inconsistent system\"\n            else:\n                return \"Dependent system\"\n        \n        for j in range(n):\n            if j != i:\n                factor = augmented_matrix[j][i] / augmented_matrix[i][i]\n                augmented_matrix[j] = [x - factor * y for x, y in zip(augmented_matrix[j], augmented_matrix[i])]\n    \n    solution = [row[-1] / row[i] for i, row in enumerate(augmented_matrix)]\n    return solution"
    },
    {
        "function_name": "bellman_ford_shortest_path",
        "file_name": "weighted_graphs.py",
        "parameters": {
            "graph": "Dict[str, Dict[str, int]] (An adjacency list representation of a weighted graph)",
            "source_node": "str (The source node for the shortest path)",
            "target_node": "str (The target node for the shortest path)"
        },
        "objectives": [
            "Implement the Bellman-Ford algorithm to find the shortest path in a weighted graph.",
            "Handle negative weight edges.",
            "Detect negative cycles by checking the distance after the final iteration."
        ],
        "import_lines": [
            "from typing import Dict"
        ],
        "function_def": "def bellman_ford_shortest_path(graph: Dict[str, Dict[str, int]], source_node: str, target_node: str) -> int:\n    distance = {node: float('inf') for node in graph}\n    distance[source_node] = 0\n    \n    for _ in range(len(graph) - 1):\n        for node in graph:\n            for neighbor, weight in graph[node].items():\n                distance[neighbor] = min(distance[neighbor], distance[node] + weight)\n    \n    # Check for negative cycle\n    for node in graph:\n        for neighbor, weight in graph[node].items():\n            assert distance[neighbor] <= distance[node] + weight, \"Negative cycle detected\"\n    \n    return distance[target_node]"
    },
    {
        "function_name": "circle_counts",
        "file_name": "sweep_line.py",
        "parameters": {
            "points": "List[List[int]] - A list of 2D points.",
            "radius": "float - The radius of the circles."
        },
        "objectives": [
            "Implement a sweep line algorithm to determine the number of circles that can be drawn through each point.",
            "Return a list of counts for each point."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def circle_counts(points: List[List[int]], radius: float) -> List[int]:\n    events = []\n    for x, y in points:\n        events.append((x - radius, 1, x, y))\n        events.append((x + radius, -1, x, y))\n    events.sort()\n    \n    count = 0\n    result = {}\n    \n    for _, delta, x, y in events:\n        if delta == 1:\n            result[(x, y)] = count\n        count += delta\n    \n    return [result[(x, y)] for x, y in points]"
    },
    {
        "function_name": "sobel_operator",
        "file_name": "image_processor.py",
        "parameters": {
            "image": "List[List[int]] (A 2D matrix representing an image where each pixel is an integer value)",
            "threshold": "int (The threshold value for edge detection)"
        },
        "objectives": [
            "Implement the Sobel operator to detect edges in the given image.",
            "Ensure the function handles cases where the image is empty or the threshold is not met.",
            "Return the edge-detected image."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def sobel_operator(image: List[List[int]], threshold: int) -> List[List[int]]:\n    rows, cols = len(image), len(image[0])\n    edge_detected_image = [[0] * cols for _ in range(rows)]\n    \n    sobel_kernel_x = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]\n    sobel_kernel_y = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]\n    \n    for i in range(1, rows - 1):\n        for j in range(1, cols - 1):\n            gradient_x = sum(image[x][y] * sobel_kernel_x[x - i + 1][y - j + 1] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2))\n            gradient_y = sum(image[x][y] * sobel_kernel_y[x - i + 1][y - j + 1] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2))\n            gradient = (gradient_x ** 2 + gradient_y ** 2) ** 0.5\n            edge_detected_image[i][j] = 1 if gradient >= threshold else 0\n    \n    return edge_detected_image"
    },
    {
        "function_name": "longest_subsequence_sum",
        "file_name": "subsequence_calculator.py",
        "parameters": {
            "sequence": "List[int] (A list of integers representing the input sequence)",
            "target": "int (The target value)"
        },
        "objectives": [
            "Implement a function to find the longest subsequence that sums up to the target value.",
            "Use dynamic programming to keep track of the maximum length of the subsequence.",
            "Handle cases where there are multiple subsequences with the same maximum length and return the one that ends earliest in the sequence."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def longest_subsequence_sum(sequence: List[int], target: int) -> List[int]:\n    if not sequence or target == 0:\n        return []\n    \n    num_elements = len(sequence)\n    dp = [[0] * (target + 1) for _ in range(num_elements + 1)]\n    max_length = 0\n    max_ending_index = 0\n    \n    for i in range(1, num_elements + 1):\n        for j in range(1, target + 1):\n            if sequence[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - sequence[i - 1]] + 1)\n            if dp[i][j] > max_length:\n                max_length = dp[i][j]\n                max_ending_index = i\n    \n    subsequence = []\n    current_index = max_ending_index\n    current_target = target\n    while current_index > 0 and current_target > 0:\n        if dp[current_index][current_target] != dp[current_index - 1][current_target]:\n            subsequence.append(sequence[current_index - 1])\n            current_target -= sequence[current_index - 1]\n        current_index -= 1\n    \n    subsequence.reverse()\n    return subsequence"
    },
    {
        "function_name": "forest_fire_simulation",
        "file_name": "forest_fire.py",
        "parameters": {
            "forest": "List[List[int]] (A 2D list of integers representing the forest)",
            "fires": "List[List[int]] (A 2D list of integers representing the fire locations)"
        },
        "objectives": [
            "Implement a function to simulate the spread of fires in the forest.",
            "Use a queue to keep track of the fire locations and iterate until the fires are extinguished.",
            "Handle cases where the input forest or fire locations are empty."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import deque"
        ],
        "function_def": "def forest_fire_simulation(forest: List[List[int]], fires: List[List[int]]) -> List[List[int]]:\n    if not forest or not fires:\n        return []\n    \n    num_rows = len(forest)\n    num_cols = len(forest[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    burned_areas = [[0] * num_cols for _ in range(num_rows)]\n    \n    queue = deque(fires)\n    while queue:\n        row, col = queue.popleft()\n        if burned_areas[row][col] == 0:\n            burned_areas[row][col] = 1\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n                if 0 <= nr < num_rows and 0 <= nc < num_cols and forest[nr][nc] > 0:\n                    queue.append((nr, nc))\n    \n    return burned_areas"
    },
    {
        "function_name": "sum_rows_above_threshold",
        "file_name": "matrix_processor.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "threshold": "int (A threshold value for the matrix elements)"
        },
        "objectives": [
            "Iterate over the matrix and find all rows where the sum of elements is greater than the threshold.",
            "For each row found, calculate the sum of its elements and return a tuple containing the row index and the sum.",
            "Return a list of tuples, where each tuple contains the row index and the sum."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def sum_rows_above_threshold(matrix, threshold):\n    result = []\n    for i, row in enumerate(matrix):\n        row_sum = sum(row)\n        if row_sum > threshold:\n            result.append((i, row_sum))\n    return result"
    },
    {
        "function_name": "round_and_sum",
        "file_name": "number_rounding.py",
        "parameters": {
            "numbers": "List[float] (A list of floating-point numbers)",
            "precision": "int (The precision for rounding the numbers)"
        },
        "objectives": [
            "Round each number in the list to the specified precision.",
            "Calculate the sum of the rounded numbers.",
            "Return a tuple containing the sum of the rounded numbers and the rounded numbers themselves."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def round_and_sum(numbers, precision):\n    rounded_numbers = [round(num, precision) for num in numbers]\n    total = sum(rounded_numbers)\n    return total, rounded_numbers"
    },
    {
        "function_name": "find_word_occurrences",
        "file_name": "text_search.py",
        "parameters": {
            "text": "str (A string of text)",
            "words": "List[str] (A list of words to be searched in the text)"
        },
        "objectives": [
            "Find all occurrences of each word in the text and return a dictionary where the keys are the words and the values are lists of indices where the word occurs.",
            "Ensure the search is case-insensitive and ignores punctuation.",
            "Return the dictionary of word occurrences."
        ],
        "import_lines": [
            "import re",
            "from typing import List, Dict"
        ],
        "function_def": "def find_word_occurrences(text, words):\n    text = text.lower()\n    text = re.sub(r'[^\\w\\s]', '', text)\n    occurrences = {}\n    for word in words:\n        indices = [i for i in range(len(text)) if text.startswith(word.lower(), i)]\n        occurrences[word] = indices\n    return occurrences"
    },
    {
        "function_name": "find_dates_in_years",
        "file_name": "date_search.py",
        "parameters": {
            "dates": "List[str] (A list of dates in the format 'YYYY-MM-DD')",
            "years": "List[int] (A list of years to be searched in the dates)"
        },
        "objectives": [
            "Find all dates that occur in the specified years.",
            "Return a list of dates that satisfy the condition."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def find_dates_in_years(dates, years):\n    result = []\n    for date in dates:\n        year = int(date.split('-')[0])\n        if year in years:\n            result.append(date)\n    return result"
    },
    {
        "function_name": "betweenness_centrality",
        "file_name": "network_analysis.py",
        "parameters": {
            "`graph`": "Dict[int, List[int]] (An adjacency list representation of a graph)",
            "`k`": "int (The number of nodes to find)"
        },
        "objectives": [
            "Implement a function to find the k most central nodes in a graph using the Betweenness Centrality algorithm.",
            "The centrality of a node is defined as the proportion of shortest paths passing through it.",
            "Return the k nodes with the highest centrality."
        ],
        "import_lines": [
            "from typing import Dict, List",
            "from collections import defaultdict",
            "import networkx as nx"
        ],
        "function_def": "def betweenness_centrality(graph: Dict[int, List[int]], k: int) -> List[int]:\n    G = nx.Graph()\n    for node, neighbors in graph.items():\n        G.add_node(node)\n        for neighbor in neighbors:\n            G.add_edge(node, neighbor)\n    \n    centrality = nx.betweenness_centrality(G)\n    sorted_centralities = sorted(centrality.items(), key=lambda x: x[1], reverse=True)\n    return [node for node, _ in sorted_centralities[:k]]"
    },
    {
        "function_name": "event_scheduler",
        "file_name": "event_planner.py",
        "parameters": {
            "intervals": "List[Tuple[int, int]] (A list of intervals representing time slots)",
            "events": "List[Tuple[int, int]] (A list of events with start and end times)"
        },
        "objectives": [
            "Implement a function to schedule events into time slots without overlaps.",
            "Use a greedy algorithm to schedule events.",
            "Handle cases where there are conflicting events."
        ],
        "import_lines": [],
        "function_def": "def event_scheduler(intervals, events):\n    intervals.sort()\n    events.sort(key=lambda x: x[0])\n    scheduled_events = []\n    \n    for event in events:\n        for interval in intervals:\n            if interval[0] <= event[0] and interval[1] >= event[1]:\n                scheduled_events.append(event)\n                intervals.remove(interval)\n                break\n    \n    return scheduled_events"
    },
    {
        "function_name": "minimum_elements",
        "file_name": "min_elements.py",
        "parameters": {
            "arr": "List[int] (A list of integers representing an array)",
            "target": "int (The target sum)"
        },
        "objectives": [
            "Implement a dynamic programming algorithm to find the minimum number of elements needed to reach the target sum.",
            "Use a table to store the minimum number of elements for different sums.",
            "Ensure that the function handles cases where the target sum is zero or where the array does not contain elements that add up to the target sum.",
            "Return the minimum number of elements needed to reach the target sum."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def minimum_elements(arr: List[int], target: int) -> int:\n    n = len(arr)\n    if target == 0:\n        return 0\n    \n    table = [float('inf')] * (target + 1)\n    table[0] = 0\n    \n    for num in arr:\n        for i in range(num, target + 1):\n            table[i] = min(table[i], table[i - num] + 1)\n    \n    return table[target] if table[target] != float('inf') else -1"
    },
    {
        "function_name": "multiple_sequence_alignment",
        "file_name": "sequence_alignment.py",
        "parameters": {
            "sequences": "List[str] (A list of DNA sequences to align)",
            "scoring_matrix": "Dict[str, Dict[str, int]] (A scoring matrix to evaluate the alignments)",
            "gap_penalty": "int (The penalty for inserting a gap in the alignment)"
        },
        "objectives": [
            "Implement a dynamic programming algorithm to align multiple DNA sequences.",
            "Initialize a 2D matrix to store the scores of the alignments.",
            "Fill in the matrix using the scoring matrix and gap penalty.",
            "Trace back the optimal alignment from the matrix.",
            "Return the aligned sequences."
        ],
        "import_lines": [
            "from typing import List, Dict"
        ],
        "function_def": "def multiple_sequence_alignment(sequences: List[str], scoring_matrix: Dict[str, Dict[str, int]], gap_penalty: int) -> List[str]:\n    # Initialize the matrix\n    matrix = [[0] * (len(sequences[0]) + 1) for _ in range(len(sequences) + 1)]\n    \n    # Fill in the matrix\n    for i in range(1, len(sequences) + 1):\n        for j in range(1, len(sequences[0]) + 1):\n            match_score = scoring_matrix[sequences[i - 1][j - 1]][sequences[i - 1][j - 2]]\n            gap_score = matrix[i - 1][j] + gap_penalty\n            matrix[i][j] = max(match_score, gap_score)\n    \n    # Trace back the optimal alignment\n    aligned_sequences = [''] * len(sequences)\n    i, j = len(sequences), len(sequences[0])\n    while i > 0 and j > 0:\n        if matrix[i][j] == scoring_matrix[sequences[i - 1][j - 1]][sequences[i - 1][j - 2]]:\n            aligned_sequences[i - 1] += sequences[i - 1][j - 1]\n            i -= 1\n            j -= 1\n        else:\n            aligned_sequences[i - 1] += '-'\n            i -= 1\n    \n    return aligned_sequences"
    },
    {
        "function_name": "sum_of_squares",
        "file_name": "number_processor.py",
        "parameters": {
            "numbers": "List[float] (A list of floating point numbers)",
            "precision": "int (The number of decimal places to round the numbers to)",
            "threshold": "float (The threshold value for determining significant numbers)"
        },
        "objectives": [
            "Round each number in the list to the specified precision.",
            "Identify the significant numbers in the list based on the threshold value.",
            "Calculate the sum of squares of the significant numbers.",
            "Return the sum of squares as a float."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def sum_of_squares(numbers: List[float], precision: int, threshold: float) -> float:\n    rounded_numbers = [round(num, precision) for num in numbers]\n    significant_numbers = [num for num in rounded_numbers if abs(num) >= threshold]\n    return sum([num ** 2 for num in significant_numbers])"
    },
    {
        "function_name": "extract_relevant_sentences",
        "file_name": "text_utils.py",
        "parameters": {
            "`text`": "str (A string of text)",
            "`keywords`": "List[str] (A list of keywords)"
        },
        "objectives": [
            "Implement a function to extract the most relevant sentences from a given text based on a list of keywords.",
            "Ensure that the function handles edge cases where the text is empty or the list of keywords is empty.",
            "Optimize the function to handle large texts."
        ],
        "import_lines": [
            "from typing import List",
            "import re",
            "from collections import Counter"
        ],
        "function_def": "def extract_relevant_sentences(text: str, keywords: List[str]) -> List[str]:\n    if not text or not keywords:\n        return []\n    \n    sentences = re.split(r'[.!?]', text)\n    sentences = [sentence.strip() for sentence in sentences if sentence]\n    \n    keyword_counts = Counter(keyword.lower() for keyword in keywords)\n    \n    relevant_sentences = []\n    \n    for sentence in sentences:\n        sentence_keywords = [keyword for keyword in keywords if keyword.lower() in sentence.lower()]\n        sentence_score = sum(keyword_counts[keyword.lower()] for keyword in sentence_keywords)\n        \n        if sentence_score > 0:\n            relevant_sentences.append((sentence, sentence_score))\n    \n    relevant_sentences.sort(key=lambda x: x[1], reverse=True)\n    \n    return [sentence for sentence, _ in relevant_sentences]"
    },
    {
        "function_name": "dbscan_clustering",
        "file_name": "clustering.py",
        "parameters": {
            "`data`": "List[List[int]] (A 2D list of integers)",
            "`threshold`": "int (A threshold value)"
        },
        "objectives": [
            "Implement a function to classify data points into clusters based on a threshold value using the DBSCAN algorithm.",
            "Ensure that the function handles edge cases where the data or threshold is empty.",
            "Optimize the function to handle large datasets."
        ],
        "import_lines": [
            "from typing import List",
            "import math"
        ],
        "function_def": "def dbscan_clustering(data: List[List[int]], threshold: int) -> List[List[int]]:\n    if not data or threshold <= 0:\n        return []\n    \n    clusters = []\n    \n    for point in data:\n        if point not in [p for cluster in clusters for p in cluster]:\n            neighbors = [p for p in data if math.sqrt(sum((a - b) ** 2 for a, b in zip(point, p))) <= threshold]\n            if len(neighbors) >= threshold:\n                cluster = [point]\n                for neighbor in neighbors:\n                    if neighbor not in cluster:\n                        cluster.append(neighbor)\n                        neighbors.extend([n for n in data if math.sqrt(sum((a - b) ** 2 for a, b in zip(neighbor, n))) <= threshold and n not in neighbors])\n                clusters.append(cluster)\n    \n    return clusters"
    },
    {
        "function_name": "max_island_area",
        "file_name": "grid_search.py",
        "parameters": {
            "grid": "List[List[int]] - A 2D grid representing the island.",
            "row": "int - The row index of the starting cell.",
            "col": "int - The column index of the starting cell."
        },
        "objectives": [
            "Implement a function to determine the maximum area of a connected island in the grid.",
            "Use depth-first search (DFS) to explore the connected cells.",
            "Return the maximum area."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_island_area(grid: List[List[int]], row: int, col: int) -> int:\n    if not grid or row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n        return 0\n    \n    grid[row][col] = 0\n    area = 1\n    \n    area += max_island_area(grid, row - 1, col)\n    area += max_island_area(grid, row + 1, col)\n    area += max_island_area(grid, row, col - 1)\n    area += max_island_area(grid, row, col + 1)\n    \n    return area"
    },
    {
        "function_name": "num_ways_matrix",
        "file_name": "matrix_manipulation.py",
        "parameters": {
            "matrix": "List[List[int]] (A 2D matrix of integers)",
            "target": "int (The target sum)"
        },
        "objectives": [
            "Implement a function to determine the number of ways to express the target sum using the elements of the matrix.",
            "Ensure that each element can be used at most once.",
            "Optimize the function to handle large inputs by using dynamic programming.",
            "Return the number of ways to express the target sum."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def num_ways_matrix(matrix: List[List[int]], target: int) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[[0 for _ in range(target + 1)] for _ in range(cols)] for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            dp[i][j][matrix[i][j]] = 1\n            for k in range(matrix[i][j], target + 1):\n                if i > 0:\n                    dp[i][j][k] += dp[i - 1][j][k]\n                if j > 0:\n                    dp[i][j][k] += dp[i][j - 1][k]\n    \n    return dp[rows - 1][cols - 1][target]"
    },
    {
        "function_name": "earliest_deadline_first",
        "file_name": "scheduling.py",
        "parameters": {
            "schedule": "List[List[int]] - A 2D list representing a schedule, where each inner list is a task with a start time, end time, and priority.",
            "max_time": "int - The maximum time for the schedule."
        },
        "objectives": [
            "Implement the Earliest Deadline First (EDF) scheduling algorithm to prioritize tasks based on their deadlines.",
            "Handle edge cases where the schedule is empty or max_time is 0.",
            "Return the scheduled tasks in the order they should be executed."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def earliest_deadline_first(schedule: List[List[int]], max_time: int) -> List[List[int]]:\n    schedule.sort(key=lambda x: x[1])\n    scheduled_tasks = []\n    current_time = 0\n    \n    for task in schedule:\n        start, end, _ = task\n        if current_time < start:\n            current_time = start\n        if current_time + 1 <= end:\n            scheduled_tasks.append(task)\n            current_time += 1\n    \n    return scheduled_tasks[:max_time]"
    },
    {
        "function_name": "points_in_circle",
        "file_name": "circle_points.py",
        "parameters": {
            "`points`": "List[Tuple[float, float]] - A list of points on the 2D plane.",
            "`r`": "float - The radius of the circle."
        },
        "objectives": [
            "Implement a function to find all points that lie within a circle of radius r centered at the origin.",
            "Return all points within the circle."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import math"
        ],
        "function_def": "def points_in_circle(points: List[Tuple[float, float]], r: float) -> List[Tuple[float, float]]:\n    return [(x, y) for x, y in points if math.sqrt(x**2 + y**2) <= r]"
    },
    {
        "function_name": "optimal_schedule",
        "file_name": "scheduler.py",
        "parameters": {
            "`schedule`": "List[List[int]] (A schedule of tasks with start and end times)",
            "`available`": "List[int] (A list of available time slots)"
        },
        "objectives": [
            "Implement a function to find the optimal schedule that maximizes the number of tasks.",
            "Use a greedy algorithm to select the tasks that end earliest.",
            "Return the optimal schedule."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def optimal_schedule(schedule: List[List[int]], available: List[int]) -> List[List[int]]:\n    schedule.sort(key=lambda x: x[1])\n    optimal = []\n    last_end = -1\n    \n    for task in schedule:\n        if task[0] >= last_end and task[1] <= available[0]:\n            optimal.append(task)\n            last_end = task[1]\n            available[0] -= task[1] - task[0]\n    \n    return optimal"
    },
    {
        "function_name": "list_rotator",
        "file_name": "list_rotator.py",
        "parameters": {
            "sorted_list": "List[int] (A sorted list of integers)",
            "rotations": "int (The number of rotations to perform)"
        },
        "objectives": [
            "Perform a series of rotations on the sorted list to create a new list.",
            "Each rotation involves shifting the elements of the list to the right by one position and wrapping the last element around to the first position.",
            "Return the resulting list after all rotations have been performed."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def list_rotator(sorted_list: List[int], rotations: int) -> List[int]:\n    rotations = rotations % len(sorted_list)\n    return sorted_list[-rotations:] + sorted_list[:-rotations]"
    },
    {
        "function_name": "tfidf_extraction",
        "file_name": "text_analysis.py",
        "parameters": {
            "`text`": "str (A block of text)",
            "`n`": "int (The number of keywords to extract)"
        },
        "objectives": [
            "Implement the TF-IDF algorithm to extract the top n keywords from the text.",
            "Use a dictionary to store the document frequency of each word.",
            "Handle cases where the text contains special characters and punctuation."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import Counter",
            "import re",
            "import math"
        ],
        "function_def": "def tfidf_extraction(text: str, n: int):\n    # Preprocess the text by removing special characters and punctuation\n    text = re.sub(r'[^\\w\\s]', '', text)\n    \n    # Split the text into words\n    words = text.split()\n    \n    # Calculate the term frequency\n    tf = Counter(words)\n    \n    # Calculate the document frequency\n    df = {}\n    for word in set(words):\n        df[word] = 1\n    \n    # Calculate the TF-IDF score\n    tfidf = {}\n    for word in tf:\n        tfidf[word] = tf[word] * math.log(len(df) / df[word])\n    \n    # Extract the top n keywords\n    keywords = sorted(tfidf.items(), key=lambda x: x[1], reverse=True)[:n]\n    \n    return keywords"
    },
    {
        "function_name": "min_spanning_tree",
        "file_name": "graph_algorithms.py",
        "parameters": {
            "graph": "List[List[Tuple[int, int]]] (An adjacency list representing a weighted graph)",
            "start_node": "int (The node to start the minimum spanning tree from)",
            "k": "int (The number of nodes to include in the minimum spanning tree)"
        },
        "objectives": [
            "Implement a function that returns the minimum spanning tree of a given weighted graph, including only k nodes.",
            "Use Kruskal's algorithm to find the minimum spanning tree.",
            "Ensure that the returned tree is in the form of a list of edges, where each edge is represented as a tuple (node1, node2, weight)."
        ],
        "import_lines": [
            "from typing import List, Tuple",
            "import heapq"
        ],
        "function_def": "def min_spanning_tree(graph: List[List[Tuple[int, int]]], start_node: int, k: int) -> List[Tuple[int, int, int]]:\n    num_nodes = len(graph)\n    min_heap = []\n    visited = set()\n    mst = []\n    \n    # Add all edges from the start node to the min heap\n    for neighbor, weight in graph[start_node]:\n        heapq.heappush(min_heap, (weight, start_node, neighbor))\n    \n    visited.add(start_node)\n    \n    while len(visited) < k:\n        weight, node1, node2 = heapq.heappop(min_heap)\n        if node2 not in visited:\n            visited.add(node2)\n            mst.append((node1, node2, weight))\n            for neighbor, neighbor_weight in graph[node2]:\n                if neighbor not in visited:\n                    heapq.heappush(min_heap, (neighbor_weight, node2, neighbor))\n    \n    return mst"
    },
    {
        "function_name": "bucket_numbers",
        "file_name": "bucketing.py",
        "parameters": {
            "numbers": "List[float] (A list of floating point numbers)",
            "buckets": "int (The number of buckets to divide the numbers into)"
        },
        "objectives": [
            "Implement a function that returns the list of numbers divided into buckets, where each bucket represents a range of values.",
            "Use the quantile function from the numpy library to calculate the bucket ranges.",
            "Ensure that the returned list is in the form of a list of lists, where each inner list represents a bucket."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np"
        ],
        "function_def": "def bucket_numbers(numbers: List[float], buckets: int) -> List[List[float]]:\n    quantiles = np.quantile(numbers, [i / buckets for i in range(buckets + 1)])\n    buckets_list = []\n    \n    for i in range(buckets):\n        bucket = [num for num in numbers if quantiles[i] <= num < quantiles[i + 1]]\n        buckets_list.append(bucket)\n    \n    return buckets_list"
    },
    {
        "function_name": "total_tree_volume",
        "file_name": "tree_volumes.py",
        "parameters": {
            "trees": "List[Dict[str, int]] (A list of dictionaries representing trees, where each dictionary contains the height and width of a tree)",
            "max_height": "int (The maximum height of trees to consider)"
        },
        "objectives": [
            "Implement a function that returns the total volume of the trees that have a height less than or equal to max_height.",
            "Use the formula for the volume of a cylindrical tree (\u03c0r^2h) to calculate the volume of each tree, where r is the radius of the tree and h is its height.",
            "Ensure that the returned value is the total volume of the considered trees."
        ],
        "import_lines": [
            "from typing import List, Dict",
            "import math"
        ],
        "function_def": "def total_tree_volume(trees: List[Dict[str, int]], max_height: int) -> float:\n    total_volume = 0\n    for tree in trees:\n        if tree['height'] <= max_height:\n            radius = tree['width'] / 2\n            volume = math.pi * radius ** 2 * tree['height']\n            total_volume += volume\n    \n    return total_volume"
    },
    {
        "function_name": "common_words",
        "file_name": "text_processing.py",
        "parameters": {
            "text": "str (The input text to process)",
            "threshold": "int (The minimum frequency for a word to be considered common)"
        },
        "objectives": [
            "Tokenize the input text into individual words and count their frequencies.",
            "Use a dictionary to store the word frequencies and sort them in descending order.",
            "Identify the common words with frequencies above the threshold and return them as a list."
        ],
        "import_lines": [
            "from typing import List",
            "from collections import Counter",
            "import re"
        ],
        "function_def": "def common_words(text: str, threshold: int) -> List[str]:\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    word_freq = Counter(words)\n    common_words = [word for word, freq in word_freq.items() if freq >= threshold]\n    common_words.sort(key=lambda word: word_freq[word], reverse=True)\n    \n    return common_words"
    },
    {
        "function_name": "identify_users_with_no_incoming_transactions",
        "file_name": "transaction_graph.py",
        "parameters": {
            "transactions": "List[Tuple[int, int, int]] (A list of transactions with sender, receiver, and amount)",
            "minimum_amount": "int (The minimum transaction amount to consider)"
        },
        "objectives": [
            "Create a graph with nodes representing users and edges representing transactions.",
            "Identify the users with no incoming transactions and return them as a list.",
            "Filter out transactions with amounts less than the minimum amount."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def identify_users_with_no_incoming_transactions(transactions: List[Tuple[int, int, int]], minimum_amount: int) -> List[int]:\n    graph = {}\n    users_with_no_incoming_transactions = set()\n    \n    for sender, receiver, amount in transactions:\n        if amount < minimum_amount:\n            continue\n        \n        if receiver not in graph:\n            graph[receiver] = []\n        graph[receiver].append(sender)\n        \n        if sender not in graph:\n            graph[sender] = []\n    \n    for user in graph:\n        if user not in [sender for sender in graph.values() for sender in sender]:\n            users_with_no_incoming_transactions.add(user)\n    \n    return list(users_with_no_incoming_transactions)"
    },
    {
        "function_name": "max_subgrid_sum",
        "file_name": "grid_analyzer.py",
        "parameters": {
            "grid": "List[List[int]] (A 2D grid representing a matrix)",
            "k": "int (The number of steps to move)"
        },
        "objectives": [
            "Implement an algorithm to find the maximum sum of a sub-grid of size k x k within the given grid.",
            "Use dynamic programming to efficiently calculate the sum of sub-grids at each position.",
            "Handle edge cases where the sub-grid exceeds the grid boundaries.",
            "Return the maximum sum found."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def max_subgrid_sum(grid: List[List[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + grid[i - 1][j - 1]\n    \n    max_sum = float('-inf')\n    for i in range(k, rows + 1):\n        for j in range(k, cols + 1):\n            subgrid_sum = prefix_sum[i][j] - prefix_sum[i - k][j] - prefix_sum[i][j - k] + prefix_sum[i - k][j - k]\n            max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum"
    },
    {
        "function_name": "quantile_buckets",
        "file_name": "number_buckets.py",
        "parameters": {
            "numbers": "List[float] (A list of floating-point numbers)",
            "num_buckets": "int (The number of buckets to divide the numbers into)"
        },
        "objectives": [
            "Divide the list of numbers into num_buckets buckets using a quantile-based approach.",
            "Ensure that each bucket contains roughly the same number of elements.",
            "Use a sorting-based approach to find the bucket boundaries.",
            "Return a list of bucket boundaries."
        ],
        "import_lines": [
            "from typing import List"
        ],
        "function_def": "def quantile_buckets(numbers: List[float], num_buckets: int) -> List[float]:\n    numbers.sort()\n    bucket_size = len(numbers) / num_buckets\n    boundaries = []\n    for i in range(1, num_buckets):\n        index = int(i * bucket_size)\n        boundaries.append(numbers[index])\n    return boundaries"
    },
    {
        "function_name": "substrings_without_stopwords",
        "file_name": "substrings.py",
        "parameters": {
            "`text`": "str - The input text.",
            "`n`": "int - The maximum length of the substrings."
        },
        "objectives": [
            "Find all substrings of the given text with a maximum length of n.",
            "Remove all stopwords from the substrings.",
            "Return a list of unique substrings."
        ],
        "import_lines": [
            "from typing import List",
            "from nltk.corpus import stopwords",
            "import nltk"
        ],
        "function_def": "def substrings_without_stopwords(text: str, n: int) -> List[str]:\n    stop_words = set(stopwords.words('english'))\n    substrings = set()\n    for length in range(1, min(n+1, len(text)+1)):\n        for i in range(len(text)-length+1):\n            substring = text[i:i+length]\n            substring = ' '.join([word for word in substring.split() if word.lower() not in stop_words])\n            substrings.add(substring)\n    return list(substrings)"
    },
    {
        "function_name": "motif_discovery",
        "file_name": "bioinformatics.py",
        "parameters": {
            "sequences": "List[List[int]] (A list of sequences)",
            "motif_length": "int (The length of the motif to find)"
        },
        "objectives": [
            "Implement a function to find motifs in a list of sequences.",
            "Use the Expectation-Maximization (EM) algorithm to find the most probable motif.",
            "Handle edge cases where the sequences or motif length are invalid.",
            "Return the most probable motif."
        ],
        "import_lines": [
            "from typing import List",
            "import numpy as np",
            "import random"
        ],
        "function_def": "def motif_discovery(sequences: List[List[int]], motif_length: int) -> List[int]:\n    if not sequences or motif_length <= 0:\n        return []\n    \n    num_sequences = len(sequences)\n    sequence_length = len(sequences[0])\n    if motif_length > sequence_length:\n        return []\n    \n    init_prob = 1 / (motif_length * num_sequences)\n    motif_prob = [[init_prob] * motif_length for _ in range(num_sequences)]\n    background_prob = [[1/4] * sequence_length for _ in range(num_sequences)]\n    \n    for _ in range(100):\n        expected_values = [[0] * motif_length for _ in range(num_sequences)]\n        for i in range(num_sequences):\n            for j in range(sequence_length - motif_length + 1):\n                for k in range(motif_length):\n                    expected_values[i][k] += motif_prob[i][k] * background_prob[i][j + k]\n        \n        motif_prob = [[0] * motif_length for _ in range(num_sequences)]\n        for i in range(num_sequences):\n            for j in range(sequence_length - motif_length + 1):\n                motif_prob[i][j % motif_length] += expected_values[i][j % motif_length]\n        \n        motif_prob = [[prob / sum(motif_prob[i]) for prob in motif_prob[i]] for i in range(num_sequences)]\n    \n    motif = []\n    for i in range(motif_length):\n        max_prob = 0\n        max_sequence_index = -1\n        for j in range(num_sequences):\n            if motif_prob[j][i] > max_prob:\n                max_prob = motif_prob[j][i]\n                max_sequence_index = j\n        motif.append(sequences[max_sequence_index][i])\n    \n    return motif"
    },
    {
        "function_name": "submatrix_sums",
        "file_name": "submatrix_calculator.py",
        "parameters": {
            "`matrix`": "`List[List[int]]` (A 2D matrix containing 0s and 1s)",
            "`k`": "`int` (The size of the submatrix)"
        },
        "objectives": [
            "Find all submatrices of size k x k in the given matrix.",
            "For each submatrix, calculate the sum of its elements.",
            "Return a list of tuples, where each tuple contains the top-left corner coordinates of the submatrix and its sum.",
            "Handle cases where k is greater than the matrix size."
        ],
        "import_lines": [
            "from typing import List, Tuple"
        ],
        "function_def": "def submatrix_sums(matrix: List[List[int]], k: int) -> List[Tuple[Tuple[int, int], int]]:\n    rows, cols = len(matrix), len(matrix[0])\n    sums = []\n    \n    for i in range(rows - k + 1):\n        for j in range(cols - k + 1):\n            submatrix_sum = sum(matrix[x][y] for x in range(i, i + k) for y in range(j, j + k))\n            sums.append(((i, j), submatrix_sum))\n    \n    return sums"
    },
    {
        "function_name": "wildcard_match",
        "file_name": "wildcard_matcher.py",
        "parameters": {
            "string": "str (The input string)",
            "wildcard": "str (The wildcard string)"
        },
        "objectives": [
            "Implement a wildcard matching function that matches a given string against a wildcard string.",
            "The wildcard string can contain '?' which matches any single character and '*' which matches any sequence of characters (including an empty sequence).",
            "Use dynamic programming to build a 2D table that stores the match status of substrings."
        ],
        "import_lines": [],
        "function_def": "def wildcard_match(string: str, wildcard: str) -> bool:\n    dp = [[False] * (len(wildcard) + 1) for _ in range(len(string) + 1)]\n    dp[0][0] = True\n    \n    for j in range(1, len(wildcard) + 1):\n        if wildcard[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    \n    for i in range(1, len(string) + 1):\n        for j in range(1, len(wildcard) + 1):\n            if wildcard[j - 1] in {string[i - 1], '?'}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif wildcard[j - 1] == '*':\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n    \n    return dp[len(string)][len(wildcard)]"
    }
]